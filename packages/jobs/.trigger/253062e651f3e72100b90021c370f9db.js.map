{
  "version": 3,
  "sources": ["<define:__PROJECT_CONFIG__>", "../../../node_modules/@trigger.dev/core/src/v3/apiClient/index.ts", "../../../node_modules/@trigger.dev/core/package.json", "../../../node_modules/@trigger.dev/core/src/v3/schemas/tokens.ts", "../../../node_modules/@trigger.dev/core/src/v3/schemas/api.ts", "../../../node_modules/@trigger.dev/core/src/v3/schemas/resources.ts", "../../../node_modules/@trigger.dev/core/src/v3/schemas/schemas.ts", "../../../node_modules/@trigger.dev/core/src/v3/schemas/common.ts", "../../../node_modules/@trigger.dev/core/src/v3/errors.ts", "../../../node_modules/@trigger.dev/core/src/v3/schemas/messages.ts", "../../../node_modules/@trigger.dev/core/src/v3/schemas/style.ts", "../../../node_modules/@trigger.dev/core/src/v3/schemas/fetch.ts", "../../../node_modules/@trigger.dev/core/src/v3/schemas/eventFilter.ts", "../../../node_modules/@trigger.dev/core/src/v3/schemas/openTelemetry.ts", "../../../node_modules/@trigger.dev/core/src/v3/utils/platform.ts", "../../../node_modules/@trigger.dev/core/src/v3/utils/globals.ts", "../../../node_modules/@trigger.dev/core/src/v3/semanticInternalAttributes.ts", "../../../node_modules/@trigger.dev/core/src/v3/taskContext/index.ts", "../../../node_modules/@trigger.dev/core/src/v3/task-context-api.ts", "../../../node_modules/@trigger.dev/core/src/v3/apiClient/core.ts", "../../../node_modules/@trigger.dev/core/src/retry.ts", "../../../node_modules/@trigger.dev/core/src/v3/utils/retries.ts", "../../../node_modules/@trigger.dev/core/src/v3/apiClient/errors.ts", "../../../node_modules/@trigger.dev/core/src/v3/utils/flattenAttributes.ts", "../../../node_modules/@trigger.dev/core/src/v3/utils/styleAttributes.ts", "../../../node_modules/@trigger.dev/core/src/v3/apiClient/pagination.ts", "../../../node_modules/@trigger.dev/core/src/v3/clock/simpleClock.ts", "../../../node_modules/@trigger.dev/core/src/v3/clock/index.ts", "../../../node_modules/@trigger.dev/core/src/v3/clock-api.ts", "../../../node_modules/@trigger.dev/core/src/v3/limits.ts", "../../../node_modules/@trigger.dev/core/src/v3/logger/taskLogger.ts", "../../../node_modules/@trigger.dev/core/src/v3/logger/index.ts", "../../../node_modules/@trigger.dev/core/src/v3/logger-api.ts", "../../../node_modules/@trigger.dev/core/src/v3/runtime/noopRuntimeManager.ts", "../../../node_modules/@trigger.dev/core/src/v3/usage/noopUsageManager.ts", "../../../node_modules/@trigger.dev/core/src/v3/usage/api.ts", "../../../node_modules/@trigger.dev/core/src/v3/usage-api.ts", "../../../node_modules/@trigger.dev/core/src/v3/runtime/index.ts", "../../../node_modules/@trigger.dev/core/src/v3/runtime-api.ts", "../../../node_modules/@trigger.dev/core/src/v3/utils/getEnv.ts", "../../../node_modules/@trigger.dev/core/src/v3/apiClientManager/index.ts", "../../../node_modules/@trigger.dev/core/src/v3/apiClientManager-api.ts", "../../../node_modules/@trigger.dev/core/src/v3/task-catalog/noopTaskCatalog.ts", "../../../node_modules/@trigger.dev/core/src/v3/task-catalog/index.ts", "../../../node_modules/@trigger.dev/core/src/v3/task-catalog-api.ts", "../../../node_modules/@trigger.dev/core/src/v3/utils/durations.ts", "../../../node_modules/@trigger.dev/core/src/v3/tracer.ts", "../../../node_modules/@trigger.dev/core/src/eventFilterMatches.ts", "../../../node_modules/@trigger.dev/core/src/v3/utils/omit.ts", "../../../node_modules/@trigger.dev/core/src/v3/utils/detectDependencyVersion.ts", "../../../node_modules/@trigger.dev/core/src/v3/utils/ioSerialization.ts", "../../../node_modules/@trigger.dev/core/src/v3/workers/taskExecutor.ts", "../../../node_modules/@trigger.dev/core/src/v3/errors.ts", "../../../node_modules/@trigger.dev/core/src/v3/otel/index.ts", "../../../node_modules/@trigger.dev/core/src/v3/otel/tracingSDK.ts", "../../../node_modules/@trigger.dev/core/src/v3/limits.ts", "../../../node_modules/@trigger.dev/core/src/v3/semanticInternalAttributes.ts", "../../../node_modules/@trigger.dev/core/src/v3/utils/flattenAttributes.ts", "../../../node_modules/@trigger.dev/core/src/v3/utils/platform.ts", "../../../node_modules/@trigger.dev/core/src/v3/utils/globals.ts", "../../../node_modules/@trigger.dev/core/src/v3/taskContext/index.ts", "../../../node_modules/@trigger.dev/core/src/v3/task-context-api.ts", "../../../node_modules/@trigger.dev/core/src/v3/taskContext/otelProcessors.ts", "../../../node_modules/@trigger.dev/core/src/v3/utils/getEnv.ts", "../../../node_modules/@trigger.dev/core/package.json", "../../../node_modules/@trigger.dev/core/src/v3/schemas/api.ts", "../../../node_modules/@trigger.dev/core/src/v3/schemas/resources.ts", "../../../node_modules/@trigger.dev/core/src/v3/schemas/schemas.ts", "../../../node_modules/@trigger.dev/core/src/v3/schemas/common.ts", "../../../node_modules/@trigger.dev/core/src/v3/apiClient/index.ts", "../../../node_modules/@trigger.dev/core/src/v3/apiClient/core.ts", "../../../node_modules/@trigger.dev/core/src/v3/utils/retries.ts", "../../../node_modules/@trigger.dev/core/src/v3/apiClient/errors.ts", "../../../node_modules/@trigger.dev/core/src/v3/utils/styleAttributes.ts", "../../../node_modules/@trigger.dev/core/src/v3/apiClient/pagination.ts", "../../../node_modules/@trigger.dev/core/src/v3/apiClientManager/index.ts", "../../../node_modules/@trigger.dev/core/src/v3/apiClientManager-api.ts", "../../../node_modules/@trigger.dev/core/src/v3/utils/ioSerialization.ts", "../../../node_modules/@trigger.dev/core/src/v3/clock/preciseWallClock.ts", "../../../node_modules/@trigger.dev/core/src/v3/logger/taskLogger.ts", "../../../node_modules/@trigger.dev/core/src/v3/icons.ts", "../../../node_modules/@trigger.dev/core/src/v3/clock/simpleClock.ts", "../../../node_modules/@trigger.dev/core/src/v3/clock/index.ts", "../../../node_modules/@trigger.dev/core/src/v3/clock-api.ts", "../../../node_modules/@trigger.dev/core/src/v3/consoleInterceptor.ts", "../../../node_modules/@trigger.dev/core/src/v3/task-catalog/standardTaskCatalog.ts", "../../../node_modules/@trigger.dev/core/src/v3/usage/noopUsageManager.ts", "../../../node_modules/@trigger.dev/core/src/v3/usage/api.ts", "../../../node_modules/@trigger.dev/core/src/v3/usage-api.ts", "../../../node_modules/@trigger.dev/core/src/v3/clock/clock.ts", "../../../node_modules/@trigger.dev/core/src/v3/usage/devUsageManager.ts", "../../../node_modules/@trigger.dev/core/src/v3/usage/prodUsageManager.ts", "../../../node_modules/@trigger.dev/core/src/v3/usage/usageClient.ts", "../../../node_modules/@trigger.dev/core/src/v3/utils/timers.ts", "../../../node_modules/@trigger.dev/core/src/v3/runtime/devRuntimeManager.ts", "../../../node_modules/@trigger.dev/core/src/v3/zodMessageHandler.ts", "../../../node_modules/@supabase/supabase-js/src/lib/version.ts", "../../../node_modules/@supabase/supabase-js/src/lib/constants.ts", "../../../node_modules/@supabase/supabase-js/src/lib/fetch.ts", "../../../node_modules/@supabase/supabase-js/src/lib/helpers.ts", "../../../node_modules/@supabase/supabase-js/src/lib/SupabaseAuthClient.ts", "../../../node_modules/@supabase/supabase-js/src/SupabaseClient.ts", "../../../node_modules/@supabase/supabase-js/src/index.ts", "../../../node_modules/@trigger.dev/core/src/v3/apiClient/core.ts", "../../../node_modules/@trigger.dev/core/src/v3/utils/retries.ts", "../../../node_modules/@trigger.dev/core/src/v3/apiClient/errors.ts", "../../../node_modules/@trigger.dev/core/src/v3/semanticInternalAttributes.ts", "../../../node_modules/@trigger.dev/core/src/v3/utils/flattenAttributes.ts", "../../../node_modules/@trigger.dev/core/src/v3/utils/styleAttributes.ts", "../../../node_modules/@trigger.dev/core/src/v3/apiClient/pagination.ts", "../__entryPoint.ts", "../../../../../../../../private/tmp/bunx-501-trigger.dev@beta/node_modules/trigger.dev/dist/workers/dev/worker-setup.js", "../trigger.config.ts", "../src/trigger/account-deletion-notice.ts", "../../../node_modules/@trigger.dev/sdk/src/v3/cache.ts", "../../../node_modules/@trigger.dev/sdk/src/v3/tracer.ts", "../../../node_modules/@trigger.dev/sdk/package.json", "../../../node_modules/@trigger.dev/sdk/src/v3/retry.ts", "../../../node_modules/@trigger.dev/sdk/src/v3/shared.ts", "../../../node_modules/@trigger.dev/sdk/src/v3/runs.ts", "../../../node_modules/@trigger.dev/sdk/src/v3/idempotencyKeys.ts", "../../../node_modules/@trigger.dev/sdk/src/v3/tasks.ts", "../../../node_modules/@trigger.dev/sdk/src/v3/wait.ts", "../../../node_modules/@trigger.dev/sdk/src/v3/usage.ts", "../../../node_modules/@trigger.dev/sdk/src/v3/tags.ts", "../../../node_modules/@trigger.dev/sdk/src/v3/index.ts", "../../../node_modules/@trigger.dev/sdk/src/v3/schedules/index.ts", "../../../node_modules/@trigger.dev/sdk/src/v3/envvars.ts", "../../../node_modules/resend/dist/index.mjs", "../src/trigger/delete-unconfirmed-emails.ts", "../node_modules/@react-email/components/dist/index.mjs", "../src/trigger/example.ts"],
  "sourcesContent": ["", "import { context, propagation } from \"@opentelemetry/api\";\nimport { z } from \"zod\";\nimport { version } from \"../../../package.json\";\nimport {\n  AddTagsRequestBody,\n  BatchTaskRunExecutionResult,\n  BatchTriggerTaskRequestBody,\n  BatchTriggerTaskResponse,\n  CanceledRunResponse,\n  CreateEnvironmentVariableRequestBody,\n  CreateScheduleOptions,\n  CreateUploadPayloadUrlResponseBody,\n  DeletedScheduleObject,\n  EnvironmentVariableResponseBody,\n  EnvironmentVariableValue,\n  EnvironmentVariables,\n  ListRunResponseItem,\n  ListScheduleOptions,\n  ReplayRunResponse,\n  RescheduleRunRequestBody,\n  RetrieveRunResponse,\n  ScheduleObject,\n  TaskRunExecutionResult,\n  TriggerTaskRequestBody,\n  TriggerTaskResponse,\n  UpdateEnvironmentVariableRequestBody,\n  UpdateScheduleOptions,\n} from \"../schemas\";\nimport { taskContext } from \"../task-context-api\";\nimport {\n  ApiRequestOptions,\n  CursorPagePromise,\n  ZodFetchOptions,\n  isRequestOptions,\n  zodfetch,\n  zodfetchCursorPage,\n  zodfetchOffsetLimitPage,\n} from \"./core\";\nimport { ApiError } from \"./errors\";\nimport {\n  CreateEnvironmentVariableParams,\n  ImportEnvironmentVariablesParams,\n  ListProjectRunsQueryParams,\n  ListRunsQueryParams,\n  UpdateEnvironmentVariableParams,\n} from \"./types\";\n\nexport type {\n  CreateEnvironmentVariableParams,\n  ImportEnvironmentVariablesParams,\n  UpdateEnvironmentVariableParams,\n};\n\nexport type TriggerOptions = {\n  spanParentAsLink?: boolean;\n};\n\nconst DEFAULT_ZOD_FETCH_OPTIONS: ZodFetchOptions = {\n  retry: {\n    maxAttempts: 3,\n    minTimeoutInMs: 1000,\n    maxTimeoutInMs: 30_000,\n    factor: 2,\n    randomize: false,\n  },\n};\n\nexport { isRequestOptions };\nexport type { ApiRequestOptions };\n\n/**\n * Trigger.dev v3 API client\n */\nexport class ApiClient {\n  private readonly baseUrl: string;\n  private readonly defaultRequestOptions: ZodFetchOptions;\n\n  constructor(\n    baseUrl: string,\n    private readonly accessToken: string,\n    requestOptions: ApiRequestOptions = {}\n  ) {\n    this.baseUrl = baseUrl.replace(/\\/$/, \"\");\n    this.defaultRequestOptions = mergeRequestOptions(DEFAULT_ZOD_FETCH_OPTIONS, requestOptions);\n  }\n\n  async getRunResult(\n    runId: string,\n    requestOptions?: ZodFetchOptions\n  ): Promise<TaskRunExecutionResult | undefined> {\n    try {\n      return await zodfetch(\n        TaskRunExecutionResult,\n        `${this.baseUrl}/api/v1/runs/${runId}/result`,\n        {\n          method: \"GET\",\n          headers: this.#getHeaders(false),\n        },\n        mergeRequestOptions(this.defaultRequestOptions, requestOptions)\n      );\n    } catch (error) {\n      if (error instanceof ApiError) {\n        if (error.status === 404) {\n          return undefined;\n        }\n      }\n\n      throw error;\n    }\n  }\n\n  async getBatchResults(\n    batchId: string,\n    requestOptions?: ZodFetchOptions\n  ): Promise<BatchTaskRunExecutionResult | undefined> {\n    return await zodfetch(\n      BatchTaskRunExecutionResult,\n      `${this.baseUrl}/api/v1/batches/${batchId}/results`,\n      {\n        method: \"GET\",\n        headers: this.#getHeaders(false),\n      },\n      mergeRequestOptions(this.defaultRequestOptions, requestOptions)\n    );\n  }\n\n  triggerTask(\n    taskId: string,\n    body: TriggerTaskRequestBody,\n    options?: TriggerOptions,\n    requestOptions?: ZodFetchOptions\n  ) {\n    const encodedTaskId = encodeURIComponent(taskId);\n\n    return zodfetch(\n      TriggerTaskResponse,\n      `${this.baseUrl}/api/v1/tasks/${encodedTaskId}/trigger`,\n      {\n        method: \"POST\",\n        headers: this.#getHeaders(options?.spanParentAsLink ?? false),\n        body: JSON.stringify(body),\n      },\n      mergeRequestOptions(this.defaultRequestOptions, requestOptions)\n    );\n  }\n\n  batchTriggerTask(\n    taskId: string,\n    body: BatchTriggerTaskRequestBody,\n    options?: TriggerOptions,\n    requestOptions?: ZodFetchOptions\n  ) {\n    const encodedTaskId = encodeURIComponent(taskId);\n\n    return zodfetch(\n      BatchTriggerTaskResponse,\n      `${this.baseUrl}/api/v1/tasks/${encodedTaskId}/batch`,\n      {\n        method: \"POST\",\n        headers: this.#getHeaders(options?.spanParentAsLink ?? false),\n        body: JSON.stringify(body),\n      },\n      mergeRequestOptions(this.defaultRequestOptions, requestOptions)\n    );\n  }\n\n  createUploadPayloadUrl(filename: string, requestOptions?: ZodFetchOptions) {\n    return zodfetch(\n      CreateUploadPayloadUrlResponseBody,\n      `${this.baseUrl}/api/v1/packets/${filename}`,\n      {\n        method: \"PUT\",\n        headers: this.#getHeaders(false),\n      },\n      mergeRequestOptions(this.defaultRequestOptions, requestOptions)\n    );\n  }\n\n  getPayloadUrl(filename: string, requestOptions?: ZodFetchOptions) {\n    return zodfetch(\n      CreateUploadPayloadUrlResponseBody,\n      `${this.baseUrl}/api/v1/packets/${filename}`,\n      {\n        method: \"GET\",\n        headers: this.#getHeaders(false),\n      },\n      mergeRequestOptions(this.defaultRequestOptions, requestOptions)\n    );\n  }\n\n  retrieveRun(runId: string, requestOptions?: ZodFetchOptions) {\n    return zodfetch(\n      RetrieveRunResponse,\n      `${this.baseUrl}/api/v3/runs/${runId}`,\n      {\n        method: \"GET\",\n        headers: this.#getHeaders(false),\n      },\n      mergeRequestOptions(this.defaultRequestOptions, requestOptions)\n    );\n  }\n\n  listRuns(\n    query?: ListRunsQueryParams,\n    requestOptions?: ZodFetchOptions\n  ): CursorPagePromise<typeof ListRunResponseItem> {\n    const searchParams = createSearchQueryForListRuns(query);\n\n    return zodfetchCursorPage(\n      ListRunResponseItem,\n      `${this.baseUrl}/api/v1/runs`,\n      {\n        query: searchParams,\n        limit: query?.limit,\n        after: query?.after,\n        before: query?.before,\n      },\n      {\n        method: \"GET\",\n        headers: this.#getHeaders(false),\n      },\n      mergeRequestOptions(this.defaultRequestOptions, requestOptions)\n    );\n  }\n\n  listProjectRuns(\n    projectRef: string,\n    query?: ListProjectRunsQueryParams,\n    requestOptions?: ZodFetchOptions\n  ): CursorPagePromise<typeof ListRunResponseItem> {\n    const searchParams = createSearchQueryForListRuns(query);\n\n    if (query?.env) {\n      searchParams.append(\n        \"filter[env]\",\n        Array.isArray(query.env) ? query.env.join(\",\") : query.env\n      );\n    }\n\n    return zodfetchCursorPage(\n      ListRunResponseItem,\n      `${this.baseUrl}/api/v1/projects/${projectRef}/runs`,\n      {\n        query: searchParams,\n        limit: query?.limit,\n        after: query?.after,\n        before: query?.before,\n      },\n      {\n        method: \"GET\",\n        headers: this.#getHeaders(false),\n      },\n      mergeRequestOptions(this.defaultRequestOptions, requestOptions)\n    );\n  }\n\n  replayRun(runId: string, requestOptions?: ZodFetchOptions) {\n    return zodfetch(\n      ReplayRunResponse,\n      `${this.baseUrl}/api/v1/runs/${runId}/replay`,\n      {\n        method: \"POST\",\n        headers: this.#getHeaders(false),\n      },\n      mergeRequestOptions(this.defaultRequestOptions, requestOptions)\n    );\n  }\n\n  cancelRun(runId: string, requestOptions?: ZodFetchOptions) {\n    return zodfetch(\n      CanceledRunResponse,\n      `${this.baseUrl}/api/v2/runs/${runId}/cancel`,\n      {\n        method: \"POST\",\n        headers: this.#getHeaders(false),\n      },\n      mergeRequestOptions(this.defaultRequestOptions, requestOptions)\n    );\n  }\n\n  rescheduleRun(runId: string, body: RescheduleRunRequestBody, requestOptions?: ZodFetchOptions) {\n    return zodfetch(\n      RetrieveRunResponse,\n      `${this.baseUrl}/api/v1/runs/${runId}/reschedule`,\n      {\n        method: \"POST\",\n        headers: this.#getHeaders(false),\n        body: JSON.stringify(body),\n      },\n      mergeRequestOptions(this.defaultRequestOptions, requestOptions)\n    );\n  }\n\n  addTags(runId: string, body: AddTagsRequestBody, requestOptions?: ZodFetchOptions) {\n    return zodfetch(\n      z.object({ message: z.string() }),\n      `${this.baseUrl}/api/v1/runs/${runId}/tags`,\n      {\n        method: \"POST\",\n        headers: this.#getHeaders(false),\n        body: JSON.stringify(body),\n      },\n      mergeRequestOptions(this.defaultRequestOptions, requestOptions)\n    );\n  }\n\n  createSchedule(options: CreateScheduleOptions, requestOptions?: ZodFetchOptions) {\n    return zodfetch(\n      ScheduleObject,\n      `${this.baseUrl}/api/v1/schedules`,\n      {\n        method: \"POST\",\n        headers: this.#getHeaders(false),\n        body: JSON.stringify(options),\n      },\n      mergeRequestOptions(this.defaultRequestOptions, requestOptions)\n    );\n  }\n\n  listSchedules(options?: ListScheduleOptions, requestOptions?: ZodFetchOptions) {\n    const searchParams = new URLSearchParams();\n\n    if (options?.page) {\n      searchParams.append(\"page\", options.page.toString());\n    }\n\n    if (options?.perPage) {\n      searchParams.append(\"perPage\", options.perPage.toString());\n    }\n\n    return zodfetchOffsetLimitPage(\n      ScheduleObject,\n      `${this.baseUrl}/api/v1/schedules`,\n      {\n        page: options?.page,\n        limit: options?.perPage,\n      },\n      {\n        method: \"GET\",\n        headers: this.#getHeaders(false),\n      },\n      mergeRequestOptions(this.defaultRequestOptions, requestOptions)\n    );\n  }\n\n  retrieveSchedule(scheduleId: string, requestOptions?: ZodFetchOptions) {\n    return zodfetch(\n      ScheduleObject,\n      `${this.baseUrl}/api/v1/schedules/${scheduleId}`,\n      {\n        method: \"GET\",\n        headers: this.#getHeaders(false),\n      },\n      mergeRequestOptions(this.defaultRequestOptions, requestOptions)\n    );\n  }\n\n  updateSchedule(\n    scheduleId: string,\n    options: UpdateScheduleOptions,\n    requestOptions?: ZodFetchOptions\n  ) {\n    return zodfetch(\n      ScheduleObject,\n      `${this.baseUrl}/api/v1/schedules/${scheduleId}`,\n      {\n        method: \"PUT\",\n        headers: this.#getHeaders(false),\n        body: JSON.stringify(options),\n      },\n      mergeRequestOptions(this.defaultRequestOptions, requestOptions)\n    );\n  }\n\n  deactivateSchedule(scheduleId: string, requestOptions?: ZodFetchOptions) {\n    return zodfetch(\n      ScheduleObject,\n      `${this.baseUrl}/api/v1/schedules/${scheduleId}/deactivate`,\n      {\n        method: \"POST\",\n        headers: this.#getHeaders(false),\n      },\n      mergeRequestOptions(this.defaultRequestOptions, requestOptions)\n    );\n  }\n\n  activateSchedule(scheduleId: string, requestOptions?: ZodFetchOptions) {\n    return zodfetch(\n      ScheduleObject,\n      `${this.baseUrl}/api/v1/schedules/${scheduleId}/activate`,\n      {\n        method: \"POST\",\n        headers: this.#getHeaders(false),\n      },\n      mergeRequestOptions(this.defaultRequestOptions, requestOptions)\n    );\n  }\n\n  deleteSchedule(scheduleId: string, requestOptions?: ZodFetchOptions) {\n    return zodfetch(\n      DeletedScheduleObject,\n      `${this.baseUrl}/api/v1/schedules/${scheduleId}`,\n      {\n        method: \"DELETE\",\n        headers: this.#getHeaders(false),\n      },\n      mergeRequestOptions(this.defaultRequestOptions, requestOptions)\n    );\n  }\n\n  listEnvVars(projectRef: string, slug: string, requestOptions?: ZodFetchOptions) {\n    return zodfetch(\n      EnvironmentVariables,\n      `${this.baseUrl}/api/v1/projects/${projectRef}/envvars/${slug}`,\n      {\n        method: \"GET\",\n        headers: this.#getHeaders(false),\n      },\n      mergeRequestOptions(this.defaultRequestOptions, requestOptions)\n    );\n  }\n\n  importEnvVars(\n    projectRef: string,\n    slug: string,\n    body: ImportEnvironmentVariablesParams,\n    requestOptions?: ZodFetchOptions\n  ) {\n    return zodfetch(\n      EnvironmentVariableResponseBody,\n      `${this.baseUrl}/api/v1/projects/${projectRef}/envvars/${slug}/import`,\n      {\n        method: \"POST\",\n        headers: this.#getHeaders(false),\n        body: JSON.stringify(body),\n      },\n      mergeRequestOptions(this.defaultRequestOptions, requestOptions)\n    );\n  }\n\n  retrieveEnvVar(projectRef: string, slug: string, key: string, requestOptions?: ZodFetchOptions) {\n    return zodfetch(\n      EnvironmentVariableValue,\n      `${this.baseUrl}/api/v1/projects/${projectRef}/envvars/${slug}/${key}`,\n      {\n        method: \"GET\",\n        headers: this.#getHeaders(false),\n      },\n      mergeRequestOptions(this.defaultRequestOptions, requestOptions)\n    );\n  }\n\n  createEnvVar(\n    projectRef: string,\n    slug: string,\n    body: CreateEnvironmentVariableRequestBody,\n    requestOptions?: ZodFetchOptions\n  ) {\n    return zodfetch(\n      EnvironmentVariableResponseBody,\n      `${this.baseUrl}/api/v1/projects/${projectRef}/envvars/${slug}`,\n      {\n        method: \"POST\",\n        headers: this.#getHeaders(false),\n        body: JSON.stringify(body),\n      },\n      mergeRequestOptions(this.defaultRequestOptions, requestOptions)\n    );\n  }\n\n  updateEnvVar(\n    projectRef: string,\n    slug: string,\n    key: string,\n    body: UpdateEnvironmentVariableRequestBody,\n    requestOptions?: ZodFetchOptions\n  ) {\n    return zodfetch(\n      EnvironmentVariableResponseBody,\n      `${this.baseUrl}/api/v1/projects/${projectRef}/envvars/${slug}/${key}`,\n      {\n        method: \"PUT\",\n        headers: this.#getHeaders(false),\n        body: JSON.stringify(body),\n      },\n      mergeRequestOptions(this.defaultRequestOptions, requestOptions)\n    );\n  }\n\n  deleteEnvVar(projectRef: string, slug: string, key: string, requestOptions?: ZodFetchOptions) {\n    return zodfetch(\n      EnvironmentVariableResponseBody,\n      `${this.baseUrl}/api/v1/projects/${projectRef}/envvars/${slug}/${key}`,\n      {\n        method: \"DELETE\",\n        headers: this.#getHeaders(false),\n      },\n      mergeRequestOptions(this.defaultRequestOptions, requestOptions)\n    );\n  }\n\n  #getHeaders(spanParentAsLink: boolean) {\n    const headers: Record<string, string> = {\n      \"Content-Type\": \"application/json\",\n      Authorization: `Bearer ${this.accessToken}`,\n      \"trigger-version\": version,\n    };\n\n    // Only inject the context if we are inside a task\n    if (taskContext.isInsideTask) {\n      headers[\"x-trigger-worker\"] = \"true\";\n      propagation.inject(context.active(), headers);\n\n      if (spanParentAsLink) {\n        headers[\"x-trigger-span-parent-as-link\"] = \"1\";\n      }\n    }\n\n    return headers;\n  }\n}\n\nfunction createSearchQueryForListRuns(query?: ListRunsQueryParams): URLSearchParams {\n  const searchParams = new URLSearchParams();\n\n  if (query) {\n    if (query.status) {\n      searchParams.append(\n        \"filter[status]\",\n        Array.isArray(query.status) ? query.status.join(\",\") : query.status\n      );\n    }\n\n    if (query.taskIdentifier) {\n      searchParams.append(\n        \"filter[taskIdentifier]\",\n        Array.isArray(query.taskIdentifier) ? query.taskIdentifier.join(\",\") : query.taskIdentifier\n      );\n    }\n\n    if (query.version) {\n      searchParams.append(\n        \"filter[version]\",\n        Array.isArray(query.version) ? query.version.join(\",\") : query.version\n      );\n    }\n\n    if (query.bulkAction) {\n      searchParams.append(\"filter[bulkAction]\", query.bulkAction);\n    }\n\n    if (query.tag) {\n      searchParams.append(\n        \"filter[tag]\",\n        Array.isArray(query.tag) ? query.tag.join(\",\") : query.tag\n      );\n    }\n\n    if (query.schedule) {\n      searchParams.append(\"filter[schedule]\", query.schedule);\n    }\n\n    if (typeof query.isTest === \"boolean\") {\n      searchParams.append(\"filter[isTest]\", String(query.isTest));\n    }\n\n    if (query.from) {\n      searchParams.append(\n        \"filter[createdAt][from]\",\n        query.from instanceof Date ? query.from.getTime().toString() : query.from.toString()\n      );\n    }\n\n    if (query.to) {\n      searchParams.append(\n        \"filter[createdAt][to]\",\n        query.to instanceof Date ? query.to.getTime().toString() : query.to.toString()\n      );\n    }\n\n    if (query.period) {\n      searchParams.append(\"filter[createdAt][period]\", query.period);\n    }\n  }\n\n  return searchParams;\n}\n\nexport function mergeRequestOptions(\n  defaultOptions: ZodFetchOptions,\n  options?: ApiRequestOptions\n): ZodFetchOptions {\n  if (!options) {\n    return defaultOptions;\n  }\n\n  return {\n    ...defaultOptions,\n    ...options,\n    retry: {\n      ...defaultOptions.retry,\n      ...options.retry,\n    },\n  };\n}\n", "{\n  \"name\": \"@trigger.dev/core\",\n  \"version\": \"3.0.0-beta.56\",\n  \"description\": \"Core code used across the Trigger.dev SDK and platform\",\n  \"license\": \"MIT\",\n  \"main\": \"./dist/index.js\",\n  \"types\": \"./dist/index.d.ts\",\n  \"module\": \"./dist/index.mjs\",\n  \"publishConfig\": {\n    \"access\": \"public\"\n  },\n  \"files\": [\n    \"dist\"\n  ],\n  \"exports\": {\n    \".\": {\n      \"import\": {\n        \"types\": \"./dist/index.d.mts\",\n        \"default\": \"./dist/index.mjs\"\n      },\n      \"require\": \"./dist/index.js\",\n      \"types\": \"./dist/index.d.ts\"\n    },\n    \"./eventFilterMatches\": {\n      \"import\": {\n        \"types\": \"./dist/eventFilterMatches.d.mts\",\n        \"default\": \"./dist/eventFilterMatches.mjs\"\n      },\n      \"require\": \"./dist/eventFilterMatches.js\",\n      \"types\": \"./dist/eventFilterMatches.d.ts\"\n    },\n    \"./replacements\": {\n      \"import\": {\n        \"types\": \"./dist/replacements.d.mts\",\n        \"default\": \"./dist/replacements.mjs\"\n      },\n      \"require\": \"./dist/replacements.js\",\n      \"types\": \"./dist/replacements.d.ts\"\n    },\n    \"./requestFilterMatches\": {\n      \"import\": {\n        \"types\": \"./dist/requestFilterMatches.d.mts\",\n        \"default\": \"./dist/requestFilterMatches.mjs\"\n      },\n      \"require\": \"./dist/requestFilterMatches.js\",\n      \"types\": \"./dist/requestFilterMatches.d.ts\"\n    },\n    \"./retry\": {\n      \"import\": {\n        \"types\": \"./dist/retry.d.mts\",\n        \"default\": \"./dist/retry.mjs\"\n      },\n      \"require\": \"./dist/retry.js\",\n      \"types\": \"./dist/retry.d.ts\"\n    },\n    \"./utils\": {\n      \"import\": {\n        \"types\": \"./dist/utils.d.mts\",\n        \"default\": \"./dist/utils.mjs\"\n      },\n      \"require\": \"./dist/utils.js\",\n      \"types\": \"./dist/utils.d.ts\"\n    },\n    \"./schemas\": {\n      \"import\": {\n        \"types\": \"./dist/schemas/index.d.mts\",\n        \"default\": \"./dist/schemas/index.mjs\"\n      },\n      \"require\": \"./dist/schemas/index.js\",\n      \"types\": \"./dist/schemas/index.d.ts\"\n    },\n    \"./types\": {\n      \"import\": {\n        \"types\": \"./dist/types.d.mts\",\n        \"default\": \"./dist/types.mjs\"\n      },\n      \"require\": \"./dist/types.js\",\n      \"types\": \"./dist/types.d.ts\"\n    },\n    \"./versions\": {\n      \"import\": {\n        \"types\": \"./dist/versions.d.mts\",\n        \"default\": \"./dist/versions.mjs\"\n      },\n      \"require\": \"./dist/versions.js\",\n      \"types\": \"./dist/versions.d.ts\"\n    },\n    \"./v3\": {\n      \"import\": {\n        \"types\": \"./dist/v3/index.d.mts\",\n        \"default\": \"./dist/v3/index.mjs\"\n      },\n      \"require\": \"./dist/v3/index.js\",\n      \"types\": \"./dist/v3/index.d.ts\"\n    },\n    \"./v3/errors\": {\n      \"import\": {\n        \"types\": \"./dist/v3/errors.d.mts\",\n        \"default\": \"./dist/v3/errors.mjs\"\n      },\n      \"require\": \"./dist/v3/errors.js\",\n      \"types\": \"./dist/v3/errors.d.ts\"\n    },\n    \"./v3/logger-api\": {\n      \"import\": {\n        \"types\": \"./dist/v3/logger-api.d.mts\",\n        \"default\": \"./dist/v3/logger-api.mjs\"\n      },\n      \"require\": \"./dist/v3/logger-api.js\",\n      \"types\": \"./dist/v3/logger-api.d.ts\"\n    },\n    \"./v3/otel\": {\n      \"import\": {\n        \"types\": \"./dist/v3/otel/index.d.mts\",\n        \"default\": \"./dist/v3/otel/index.mjs\"\n      },\n      \"require\": \"./dist/v3/otel/index.js\",\n      \"types\": \"./dist/v3/otel/index.d.ts\"\n    },\n    \"./v3/semanticInternalAttributes\": {\n      \"import\": {\n        \"types\": \"./dist/v3/semanticInternalAttributes.d.mts\",\n        \"default\": \"./dist/v3/semanticInternalAttributes.mjs\"\n      },\n      \"require\": \"./dist/v3/semanticInternalAttributes.js\",\n      \"types\": \"./dist/v3/semanticInternalAttributes.d.ts\"\n    },\n    \"./v3/utils/durations\": {\n      \"import\": {\n        \"types\": \"./dist/v3/utils/durations.d.mts\",\n        \"default\": \"./dist/v3/utils/durations.mjs\"\n      },\n      \"require\": \"./dist/v3/utils/durations.js\",\n      \"types\": \"./dist/v3/utils/durations.d.ts\"\n    },\n    \"./v3/utils/flattenAttributes\": {\n      \"import\": {\n        \"types\": \"./dist/v3/utils/flattenAttributes.d.mts\",\n        \"default\": \"./dist/v3/utils/flattenAttributes.mjs\"\n      },\n      \"require\": \"./dist/v3/utils/flattenAttributes.js\",\n      \"types\": \"./dist/v3/utils/flattenAttributes.d.ts\"\n    },\n    \"./v3/utils/ioSerialization\": {\n      \"import\": {\n        \"types\": \"./dist/v3/utils/ioSerialization.d.mts\",\n        \"default\": \"./dist/v3/utils/ioSerialization.mjs\"\n      },\n      \"require\": \"./dist/v3/utils/ioSerialization.js\",\n      \"types\": \"./dist/v3/utils/ioSerialization.d.ts\"\n    },\n    \"./v3/utils/omit\": {\n      \"import\": {\n        \"types\": \"./dist/v3/utils/omit.d.mts\",\n        \"default\": \"./dist/v3/utils/omit.mjs\"\n      },\n      \"require\": \"./dist/v3/utils/omit.js\",\n      \"types\": \"./dist/v3/utils/omit.d.ts\"\n    },\n    \"./v3/utils/retries\": {\n      \"import\": {\n        \"types\": \"./dist/v3/utils/retries.d.mts\",\n        \"default\": \"./dist/v3/utils/retries.mjs\"\n      },\n      \"require\": \"./dist/v3/utils/retries.js\",\n      \"types\": \"./dist/v3/utils/retries.d.ts\"\n    },\n    \"./v3/utils/structuredLogger\": {\n      \"import\": {\n        \"types\": \"./dist/v3/utils/structuredLogger.d.mts\",\n        \"default\": \"./dist/v3/utils/structuredLogger.mjs\"\n      },\n      \"require\": \"./dist/v3/utils/structuredLogger.js\",\n      \"types\": \"./dist/v3/utils/structuredLogger.d.ts\"\n    },\n    \"./v3/zodfetch\": {\n      \"import\": {\n        \"types\": \"./dist/v3/zodfetch.d.mts\",\n        \"default\": \"./dist/v3/zodfetch.mjs\"\n      },\n      \"require\": \"./dist/v3/zodfetch.js\",\n      \"types\": \"./dist/v3/zodfetch.d.ts\"\n    },\n    \"./v3/zodMessageHandler\": {\n      \"import\": {\n        \"types\": \"./dist/v3/zodMessageHandler.d.mts\",\n        \"default\": \"./dist/v3/zodMessageHandler.mjs\"\n      },\n      \"require\": \"./dist/v3/zodMessageHandler.js\",\n      \"types\": \"./dist/v3/zodMessageHandler.d.ts\"\n    },\n    \"./v3/zodNamespace\": {\n      \"import\": {\n        \"types\": \"./dist/v3/zodNamespace.d.mts\",\n        \"default\": \"./dist/v3/zodNamespace.mjs\"\n      },\n      \"require\": \"./dist/v3/zodNamespace.js\",\n      \"types\": \"./dist/v3/zodNamespace.d.ts\"\n    },\n    \"./v3/zodSocket\": {\n      \"import\": {\n        \"types\": \"./dist/v3/zodSocket.d.mts\",\n        \"default\": \"./dist/v3/zodSocket.mjs\"\n      },\n      \"require\": \"./dist/v3/zodSocket.js\",\n      \"types\": \"./dist/v3/zodSocket.d.ts\"\n    },\n    \"./v3/zodIpc\": {\n      \"import\": {\n        \"types\": \"./dist/v3/zodIpc.d.mts\",\n        \"default\": \"./dist/v3/zodIpc.mjs\"\n      },\n      \"require\": \"./dist/v3/zodIpc.js\",\n      \"types\": \"./dist/v3/zodIpc.d.ts\"\n    },\n    \"./v3/utils/timers\": {\n      \"import\": {\n        \"types\": \"./dist/v3/utils/timers.d.mts\",\n        \"default\": \"./dist/v3/utils/timers.mjs\"\n      },\n      \"require\": \"./dist/v3/utils/timers.js\",\n      \"types\": \"./dist/v3/utils/timers.d.ts\"\n    },\n    \"./v3/dev\": {\n      \"import\": {\n        \"types\": \"./dist/v3/dev/index.d.mts\",\n        \"default\": \"./dist/v3/dev/index.mjs\"\n      },\n      \"require\": \"./dist/v3/dev/index.js\",\n      \"types\": \"./dist/v3/dev/index.d.ts\"\n    },\n    \"./v3/prod\": {\n      \"import\": {\n        \"types\": \"./dist/v3/prod/index.d.mts\",\n        \"default\": \"./dist/v3/prod/index.mjs\"\n      },\n      \"require\": \"./dist/v3/prod/index.js\",\n      \"types\": \"./dist/v3/prod/index.d.ts\"\n    },\n    \"./v3/workers\": {\n      \"import\": {\n        \"types\": \"./dist/v3/workers/index.d.mts\",\n        \"default\": \"./dist/v3/workers/index.mjs\"\n      },\n      \"require\": \"./dist/v3/workers/index.js\",\n      \"types\": \"./dist/v3/workers/index.d.ts\"\n    },\n    \"./v3/schemas\": {\n      \"import\": {\n        \"types\": \"./dist/v3/schemas/index.d.mts\",\n        \"default\": \"./dist/v3/schemas/index.mjs\"\n      },\n      \"require\": \"./dist/v3/schemas/index.js\",\n      \"types\": \"./dist/v3/schemas/index.d.ts\"\n    },\n    \"./package.json\": \"./package.json\"\n  },\n  \"typesVersions\": {\n    \"*\": {\n      \"v3\": [\n        \"./dist/v3/index.d.ts\"\n      ],\n      \"v3/otel\": [\n        \"./dist/v3/otel/index.d.ts\"\n      ]\n    }\n  },\n  \"sideEffects\": false,\n  \"scripts\": {\n    \"clean\": \"rimraf dist\",\n    \"build\": \"npm run clean && npm run build:tsup\",\n    \"build:tsup\": \"tsup --dts-resolve\",\n    \"typecheck\": \"tsc --noEmit\",\n    \"test\": \"jest\"\n  },\n  \"dependencies\": {\n    \"@google-cloud/precise-date\": \"^4.0.0\",\n    \"@opentelemetry/api\": \"^1.8.0\",\n    \"@opentelemetry/api-logs\": \"^0.48.0\",\n    \"@opentelemetry/exporter-logs-otlp-http\": \"^0.49.1\",\n    \"@opentelemetry/exporter-trace-otlp-http\": \"^0.49.1\",\n    \"@opentelemetry/instrumentation\": \"^0.49.1\",\n    \"@opentelemetry/resources\": \"^1.22.0\",\n    \"@opentelemetry/sdk-logs\": \"^0.49.1\",\n    \"@opentelemetry/sdk-node\": \"^0.49.1\",\n    \"@opentelemetry/sdk-trace-base\": \"^1.22.0\",\n    \"@opentelemetry/sdk-trace-node\": \"^1.22.0\",\n    \"@opentelemetry/semantic-conventions\": \"^1.22.0\",\n    \"humanize-duration\": \"^3.27.3\",\n    \"socket.io-client\": \"4.7.5\",\n    \"superjson\": \"^2.2.1\",\n    \"ulidx\": \"^2.2.1\",\n    \"zod\": \"3.22.3\",\n    \"zod-error\": \"1.5.0\",\n    \"zod-validation-error\": \"^1.5.0\"\n  },\n  \"devDependencies\": {\n    \"@trigger.dev/tsconfig\": \"workspace:*\",\n    \"@trigger.dev/tsup\": \"workspace:*\",\n    \"@types/humanize-duration\": \"^3.27.1\",\n    \"@types/jest\": \"^29.5.3\",\n    \"@types/node\": \"20.12.7\",\n    \"@types/readable-stream\": \"^4.0.14\",\n    \"jest\": \"^29.6.2\",\n    \"rimraf\": \"^3.0.2\",\n    \"socket.io\": \"4.7.4\",\n    \"ts-jest\": \"^29.1.1\",\n    \"tsup\": \"^8.0.1\",\n    \"typescript\": \"^5.3.0\"\n  },\n  \"engines\": {\n    \"node\": \">=18.0.0\"\n  }\n}", "import { z } from \"zod\";\n\nexport const CreateAuthorizationCodeResponseSchema = z.object({\n  url: z.string().url(),\n  authorizationCode: z.string(),\n});\n\nexport type CreateAuthorizationCodeResponse = z.infer<typeof CreateAuthorizationCodeResponseSchema>;\n\nexport const GetPersonalAccessTokenRequestSchema = z.object({\n  authorizationCode: z.string(),\n});\nexport type GetPersonalAccessTokenRequest = z.infer<typeof GetPersonalAccessTokenRequestSchema>;\n\nexport const GetPersonalAccessTokenResponseSchema = z.object({\n  token: z\n    .object({\n      token: z.string(),\n      obfuscatedToken: z.string(),\n    })\n    .nullable(),\n});\nexport type GetPersonalAccessTokenResponse = z.infer<typeof GetPersonalAccessTokenResponseSchema>;\n", "import { z } from \"zod\";\nimport { BackgroundWorkerMetadata, ImageDetailsMetadata } from \"./resources\";\nimport { QueueOptions } from \"./schemas\";\nimport { SerializedError } from \"../errors\";\n\nexport const WhoAmIResponseSchema = z.object({\n  userId: z.string(),\n  email: z.string().email(),\n  dashboardUrl: z.string(),\n});\n\nexport type WhoAmIResponse = z.infer<typeof WhoAmIResponseSchema>;\n\nexport const GetProjectResponseBody = z.object({\n  id: z.string(),\n  externalRef: z.string(),\n  name: z.string(),\n  slug: z.string(),\n  createdAt: z.coerce.date(),\n  organization: z.object({\n    id: z.string(),\n    title: z.string(),\n    slug: z.string(),\n    createdAt: z.coerce.date(),\n  }),\n});\n\nexport type GetProjectResponseBody = z.infer<typeof GetProjectResponseBody>;\n\nexport const GetProjectsResponseBody = z.array(GetProjectResponseBody);\n\nexport type GetProjectsResponseBody = z.infer<typeof GetProjectsResponseBody>;\n\nexport const GetProjectEnvResponse = z.object({\n  apiKey: z.string(),\n  name: z.string(),\n  apiUrl: z.string(),\n});\n\nexport type GetProjectEnvResponse = z.infer<typeof GetProjectEnvResponse>;\n\nexport const CreateBackgroundWorkerRequestBody = z.object({\n  localOnly: z.boolean(),\n  metadata: BackgroundWorkerMetadata,\n  supportsLazyAttempts: z.boolean().optional(),\n});\n\nexport type CreateBackgroundWorkerRequestBody = z.infer<typeof CreateBackgroundWorkerRequestBody>;\n\nexport const CreateBackgroundWorkerResponse = z.object({\n  id: z.string(),\n  version: z.string(),\n  contentHash: z.string(),\n});\n\nexport type CreateBackgroundWorkerResponse = z.infer<typeof CreateBackgroundWorkerResponse>;\n\n//an array of 1, 2, or 3 strings\nconst RunTag = z.string().max(64, \"Tags must be less than 64 characters\");\nexport const RunTags = z.union([RunTag, RunTag.array()]);\n\nexport type RunTags = z.infer<typeof RunTags>;\n\nexport const TriggerTaskRequestBody = z.object({\n  payload: z.any(),\n  context: z.any(),\n  options: z\n    .object({\n      dependentAttempt: z.string().optional(),\n      dependentBatch: z.string().optional(),\n      lockToVersion: z.string().optional(),\n      queue: QueueOptions.optional(),\n      concurrencyKey: z.string().optional(),\n      idempotencyKey: z.string().optional(),\n      test: z.boolean().optional(),\n      payloadType: z.string().optional(),\n      delay: z.string().or(z.coerce.date()).optional(),\n      ttl: z.string().or(z.number().nonnegative().int()).optional(),\n      tags: RunTags.optional(),\n      maxAttempts: z.number().int().optional(),\n    })\n    .optional(),\n});\n\nexport type TriggerTaskRequestBody = z.infer<typeof TriggerTaskRequestBody>;\n\nexport const TriggerTaskResponse = z.object({\n  id: z.string(),\n});\n\nexport type TriggerTaskResponse = z.infer<typeof TriggerTaskResponse>;\n\nexport const BatchTriggerTaskRequestBody = z.object({\n  items: TriggerTaskRequestBody.array(),\n  dependentAttempt: z.string().optional(),\n});\n\nexport type BatchTriggerTaskRequestBody = z.infer<typeof BatchTriggerTaskRequestBody>;\n\nexport const BatchTriggerTaskResponse = z.object({\n  batchId: z.string(),\n  runs: z.string().array(),\n});\n\nexport type BatchTriggerTaskResponse = z.infer<typeof BatchTriggerTaskResponse>;\n\nexport const GetBatchResponseBody = z.object({\n  id: z.string(),\n  items: z.array(\n    z.object({\n      id: z.string(),\n      taskRunId: z.string(),\n      status: z.enum([\"PENDING\", \"CANCELED\", \"COMPLETED\", \"FAILED\"]),\n    })\n  ),\n});\n\nexport type GetBatchResponseBody = z.infer<typeof GetBatchResponseBody>;\n\nexport const AddTagsRequestBody = z.object({\n  tags: RunTags,\n});\n\nexport type AddTagsRequestBody = z.infer<typeof AddTagsRequestBody>;\n\nexport const RescheduleRunRequestBody = z.object({\n  delay: z.string().or(z.coerce.date()),\n});\n\nexport type RescheduleRunRequestBody = z.infer<typeof RescheduleRunRequestBody>;\n\nexport const GetEnvironmentVariablesResponseBody = z.object({\n  variables: z.record(z.string()),\n});\n\nexport type GetEnvironmentVariablesResponseBody = z.infer<\n  typeof GetEnvironmentVariablesResponseBody\n>;\n\nexport const StartDeploymentIndexingRequestBody = z.object({\n  imageReference: z.string(),\n  selfHosted: z.boolean().optional(),\n});\n\nexport type StartDeploymentIndexingRequestBody = z.infer<typeof StartDeploymentIndexingRequestBody>;\n\nexport const StartDeploymentIndexingResponseBody = z.object({\n  id: z.string(),\n  contentHash: z.string(),\n});\n\nexport type StartDeploymentIndexingResponseBody = z.infer<\n  typeof StartDeploymentIndexingResponseBody\n>;\n\nexport const ExternalBuildData = z.object({\n  buildId: z.string(),\n  buildToken: z.string(),\n  projectId: z.string(),\n});\n\nexport type ExternalBuildData = z.infer<typeof ExternalBuildData>;\n\nexport const InitializeDeploymentResponseBody = z.object({\n  id: z.string(),\n  contentHash: z.string(),\n  shortCode: z.string(),\n  version: z.string(),\n  imageTag: z.string(),\n  externalBuildData: ExternalBuildData.optional().nullable(),\n  registryHost: z.string().optional(),\n});\n\nexport type InitializeDeploymentResponseBody = z.infer<typeof InitializeDeploymentResponseBody>;\n\nexport const InitializeDeploymentRequestBody = z.object({\n  contentHash: z.string(),\n  userId: z.string().optional(),\n});\n\nexport type InitializeDeploymentRequestBody = z.infer<typeof InitializeDeploymentRequestBody>;\n\nexport const DeploymentErrorData = z.object({\n  name: z.string(),\n  message: z.string(),\n  stack: z.string().optional(),\n  stderr: z.string().optional(),\n});\n\nexport const GetDeploymentResponseBody = z.object({\n  id: z.string(),\n  status: z.enum([\n    \"PENDING\",\n    \"BUILDING\",\n    \"DEPLOYING\",\n    \"DEPLOYED\",\n    \"FAILED\",\n    \"CANCELED\",\n    \"TIMED_OUT\",\n  ]),\n  contentHash: z.string(),\n  shortCode: z.string(),\n  version: z.string(),\n  imageReference: z.string().optional(),\n  errorData: DeploymentErrorData.optional().nullable(),\n  worker: z\n    .object({\n      id: z.string(),\n      version: z.string(),\n      tasks: z.array(\n        z.object({\n          id: z.string(),\n          slug: z.string(),\n          filePath: z.string(),\n          exportName: z.string(),\n        })\n      ),\n    })\n    .optional(),\n});\n\nexport type GetDeploymentResponseBody = z.infer<typeof GetDeploymentResponseBody>;\n\nexport const CreateUploadPayloadUrlResponseBody = z.object({\n  presignedUrl: z.string(),\n});\n\nexport type CreateUploadPayloadUrlResponseBody = z.infer<typeof CreateUploadPayloadUrlResponseBody>;\n\nexport const ReplayRunResponse = z.object({\n  id: z.string(),\n});\n\nexport type ReplayRunResponse = z.infer<typeof ReplayRunResponse>;\n\nexport const CanceledRunResponse = z.object({\n  id: z.string(),\n});\n\nexport type CanceledRunResponse = z.infer<typeof CanceledRunResponse>;\n\nexport const ScheduleType = z.union([z.literal(\"DECLARATIVE\"), z.literal(\"IMPERATIVE\")]);\n\nexport const ScheduledTaskPayload = z.object({\n  /** The schedule id associated with this run (you can have many schedules for the same task).\n    You can use this to remove the schedule, update it, etc */\n  scheduleId: z.string(),\n  /** The type of schedule – `\"DECLARATIVE\"` or `\"IMPERATIVE\"`.\n   *\n   * **DECLARATIVE** – defined inline on your `schedules.task` using the `cron` property. They can only be created, updated or deleted by modifying the `cron` property on your task.\n   *\n   * **IMPERATIVE** – created using the `schedules.create` functions or in the dashboard.\n   */\n  type: ScheduleType,\n  /** When the task was scheduled to run.\n   * Note this will be slightly different from `new Date()` because it takes a few ms to run the task.\n   * \n   * This date is UTC. To output it as a string with a timezone you would do this: \n   * ```ts\n   * const formatted = payload.timestamp.toLocaleString(\"en-US\", {\n        timeZone: payload.timezone,\n    });\n    ```  */\n  timestamp: z.date(),\n  /** When the task was last run (it has been).\n    This can be undefined if it's never been run. This date is UTC. */\n  lastTimestamp: z.date().optional(),\n  /** You can optionally provide an external id when creating the schedule.\n    Usually you would use a userId or some other unique identifier.\n    This defaults to undefined if you didn't provide one. */\n  externalId: z.string().optional(),\n  /** The IANA timezone the schedule is set to. The default is UTC.\n   * You can see the full list of supported timezones here: https://cloud.trigger.dev/timezones\n   */\n  timezone: z.string(),\n  /** The next 5 dates this task is scheduled to run */\n  upcoming: z.array(z.date()),\n});\n\nexport type ScheduledTaskPayload = z.infer<typeof ScheduledTaskPayload>;\n\nexport const CreateScheduleOptions = z.object({\n  /** The id of the task you want to attach to. */\n  task: z.string(),\n  /**  The schedule in CRON format.\n   * \n   * ```txt\n*    *    *    *    *    *\n┬    ┬    ┬    ┬    ┬\n│    │    │    │    |\n│    │    │    │    └ day of week (0 - 7, 1L - 7L) (0 or 7 is Sun)\n│    │    │    └───── month (1 - 12)\n│    │    └────────── day of month (1 - 31, L)\n│    └─────────────── hour (0 - 23)\n└──────────────────── minute (0 - 59)\n   * ```\n\n\"L\" means the last. In the \"day of week\" field, 1L means the last Monday of the month. In the day of month field, L means the last day of the month.\n\n   */\n  cron: z.string(),\n  /** You can only create one schedule with this key. If you use it twice, the second call will update the schedule.\n   *\n   * This is required to prevent you from creating duplicate schedules. */\n  deduplicationKey: z.string(),\n  /** Optionally, you can specify your own IDs (like a user ID) and then use it inside the run function of your task.\n   *\n   * This allows you to have per-user CRON tasks.\n   */\n  externalId: z.string().optional(),\n  /** Optionally, you can specify a timezone in the IANA format. If unset it will use UTC.\n   * If specified then the CRON will be evaluated in that timezone and will respect daylight savings.\n   *\n   * If you set the CRON to `0 0 * * *` and the timezone to `America/New_York` then the task will run at midnight in New York time, no matter whether it's daylight savings or not.\n   *\n   * You can see the full list of supported timezones here: https://cloud.trigger.dev/timezones\n   *\n   * @example \"America/New_York\", \"Europe/London\", \"Asia/Tokyo\", \"Africa/Cairo\"\n   *\n   */\n  timezone: z.string().optional(),\n});\n\nexport type CreateScheduleOptions = z.infer<typeof CreateScheduleOptions>;\n\nexport const UpdateScheduleOptions = CreateScheduleOptions.omit({ deduplicationKey: true });\n\nexport type UpdateScheduleOptions = z.infer<typeof UpdateScheduleOptions>;\n\nexport const ScheduleGenerator = z.object({\n  type: z.literal(\"CRON\"),\n  expression: z.string(),\n  description: z.string(),\n});\n\nexport type ScheduleGenerator = z.infer<typeof ScheduleGenerator>;\n\nexport const ScheduleObject = z.object({\n  id: z.string(),\n  type: ScheduleType,\n  task: z.string(),\n  active: z.boolean(),\n  deduplicationKey: z.string().nullish(),\n  externalId: z.string().nullish(),\n  generator: ScheduleGenerator,\n  timezone: z.string(),\n  nextRun: z.coerce.date().nullish(),\n  environments: z.array(\n    z.object({\n      id: z.string(),\n      type: z.string(),\n      userName: z.string().nullish(),\n    })\n  ),\n});\n\nexport type ScheduleObject = z.infer<typeof ScheduleObject>;\n\nexport const DeletedScheduleObject = z.object({\n  id: z.string(),\n});\n\nexport type DeletedScheduleObject = z.infer<typeof DeletedScheduleObject>;\n\nexport const ListSchedulesResult = z.object({\n  data: z.array(ScheduleObject),\n  pagination: z.object({\n    currentPage: z.number(),\n    totalPages: z.number(),\n    count: z.number(),\n  }),\n});\n\nexport type ListSchedulesResult = z.infer<typeof ListSchedulesResult>;\n\nexport const ListScheduleOptions = z.object({\n  page: z.number().optional(),\n  perPage: z.number().optional(),\n});\n\nexport type ListScheduleOptions = z.infer<typeof ListScheduleOptions>;\n\nexport const TimezonesResult = z.object({\n  timezones: z.array(z.string()),\n});\n\nexport type TimezonesResult = z.infer<typeof TimezonesResult>;\n\nexport const RunStatus = z.enum([\n  /// Task hasn't been deployed yet but is waiting to be executed\n  \"WAITING_FOR_DEPLOY\",\n  /// Task is waiting to be executed by a worker\n  \"QUEUED\",\n  /// Task is currently being executed by a worker\n  \"EXECUTING\",\n  /// Task has failed and is waiting to be retried\n  \"REATTEMPTING\",\n  /// Task has been paused by the system, and will be resumed by the system\n  \"FROZEN\",\n  /// Task has been completed successfully\n  \"COMPLETED\",\n  /// Task has been canceled by the user\n  \"CANCELED\",\n  /// Task has been completed with errors\n  \"FAILED\",\n  /// Task has crashed and won't be retried, most likely the worker ran out of resources, e.g. memory or storage\n  \"CRASHED\",\n  /// Task was interrupted during execution, mostly this happens in development environments\n  \"INTERRUPTED\",\n  /// Task has failed to complete, due to an error in the system\n  \"SYSTEM_FAILURE\",\n  /// Task has been scheduled to run at a specific time\n  \"DELAYED\",\n  /// Task has expired and won't be executed\n  \"EXPIRED\",\n]);\n\nexport type RunStatus = z.infer<typeof RunStatus>;\n\nexport const AttemptStatus = z.enum([\n  \"PENDING\",\n  \"EXECUTING\",\n  \"PAUSED\",\n  \"COMPLETED\",\n  \"FAILED\",\n  \"CANCELED\",\n]);\n\nexport type AttemptStatus = z.infer<typeof AttemptStatus>;\n\nexport const RunEnvironmentDetails = z.object({\n  id: z.string(),\n  name: z.string(),\n  user: z.string().optional(),\n});\n\nexport type RunEnvironmentDetails = z.infer<typeof RunEnvironmentDetails>;\n\nexport const RunScheduleDetails = z.object({\n  id: z.string(),\n  externalId: z.string().optional(),\n  deduplicationKey: z.string().optional(),\n  generator: ScheduleGenerator,\n});\n\nexport type RunScheduleDetails = z.infer<typeof RunScheduleDetails>;\n\nconst CommonRunFields = {\n  id: z.string(),\n  status: RunStatus,\n  taskIdentifier: z.string(),\n  idempotencyKey: z.string().optional(),\n  version: z.string().optional(),\n  isQueued: z.boolean(),\n  isExecuting: z.boolean(),\n  isCompleted: z.boolean(),\n  isSuccess: z.boolean(),\n  isFailed: z.boolean(),\n  isCancelled: z.boolean(),\n  isTest: z.boolean(),\n  createdAt: z.coerce.date(),\n  updatedAt: z.coerce.date(),\n  startedAt: z.coerce.date().optional(),\n  finishedAt: z.coerce.date().optional(),\n  delayedUntil: z.coerce.date().optional(),\n  ttl: z.string().optional(),\n  expiredAt: z.coerce.date().optional(),\n  tags: z.string().array(),\n  costInCents: z.number(),\n  baseCostInCents: z.number(),\n  durationMs: z.number(),\n};\n\nexport const RetrieveRunResponse = z.object({\n  ...CommonRunFields,\n  payload: z.any().optional(),\n  payloadPresignedUrl: z.string().optional(),\n  output: z.any().optional(),\n  outputPresignedUrl: z.string().optional(),\n  schedule: RunScheduleDetails.optional(),\n  attempts: z.array(\n    z\n      .object({\n        id: z.string(),\n        status: AttemptStatus,\n        createdAt: z.coerce.date(),\n        updatedAt: z.coerce.date(),\n        startedAt: z.coerce.date().optional(),\n        completedAt: z.coerce.date().optional(),\n        error: SerializedError.optional(),\n      })\n      .optional()\n  ),\n});\n\nexport type RetrieveRunResponse = z.infer<typeof RetrieveRunResponse>;\n\nexport const ListRunResponseItem = z.object({\n  ...CommonRunFields,\n  env: RunEnvironmentDetails,\n});\n\nexport type ListRunResponseItem = z.infer<typeof ListRunResponseItem>;\n\nexport const ListRunResponse = z.object({\n  data: z.array(ListRunResponseItem),\n  pagination: z.object({\n    next: z.string().optional(),\n    previous: z.string().optional(),\n  }),\n});\n\nexport type ListRunResponse = z.infer<typeof ListRunResponse>;\n\nexport const CreateEnvironmentVariableRequestBody = z.object({\n  name: z.string(),\n  value: z.string(),\n});\n\nexport type CreateEnvironmentVariableRequestBody = z.infer<\n  typeof CreateEnvironmentVariableRequestBody\n>;\n\nexport const UpdateEnvironmentVariableRequestBody = z.object({\n  value: z.string(),\n});\n\nexport type UpdateEnvironmentVariableRequestBody = z.infer<\n  typeof UpdateEnvironmentVariableRequestBody\n>;\n\nexport const ImportEnvironmentVariablesRequestBody = z.object({\n  variables: z.record(z.string()),\n  override: z.boolean().optional(),\n});\n\nexport type ImportEnvironmentVariablesRequestBody = z.infer<\n  typeof ImportEnvironmentVariablesRequestBody\n>;\n\nexport const EnvironmentVariableResponseBody = z.object({\n  success: z.boolean(),\n});\n\nexport type EnvironmentVariableResponseBody = z.infer<typeof EnvironmentVariableResponseBody>;\n\nexport const EnvironmentVariableValue = z.object({\n  value: z.string(),\n});\n\nexport type EnvironmentVariableValue = z.infer<typeof EnvironmentVariableValue>;\n\nexport const EnvironmentVariable = z.object({\n  name: z.string(),\n  value: z.string(),\n});\n\nexport const EnvironmentVariables = z.array(EnvironmentVariable);\n\nexport type EnvironmentVariables = z.infer<typeof EnvironmentVariables>;\n", "import { z } from \"zod\";\nimport { QueueOptions, RetryOptions, ScheduleMetadata } from \"./schemas\";\nimport { MachineConfig } from \"./common\";\n\nexport const TaskResource = z.object({\n  id: z.string(),\n  filePath: z.string(),\n  exportName: z.string(),\n  queue: QueueOptions.optional(),\n  retry: RetryOptions.optional(),\n  machine: MachineConfig.optional(),\n  triggerSource: z.string().optional(),\n  schedule: ScheduleMetadata.optional(),\n});\n\nexport type TaskResource = z.infer<typeof TaskResource>;\n\nexport const BackgroundWorkerMetadata = z.object({\n  packageVersion: z.string(),\n  contentHash: z.string(),\n  cliPackageVersion: z.string().optional(),\n  tasks: z.array(TaskResource),\n});\n\nexport type BackgroundWorkerMetadata = z.infer<typeof BackgroundWorkerMetadata>;\n\nexport const ImageDetailsMetadata = z.object({\n  contentHash: z.string(),\n  imageTag: z.string(),\n});\n\nexport type ImageDetailsMetadata = z.infer<typeof ImageDetailsMetadata>;\n", "import { z } from \"zod\";\nimport { RequireKeys } from \"../types\";\nimport { MachineConfig, MachinePreset, TaskRunExecution } from \"./common\";\n\n/*\n    WARNING: Never import anything from ./messages here. If it's needed in both, put it here instead.\n*/\nexport const EnvironmentType = z.enum([\"PRODUCTION\", \"STAGING\", \"DEVELOPMENT\", \"PREVIEW\"]);\nexport type EnvironmentType = z.infer<typeof EnvironmentType>;\n\nexport const TaskRunExecutionPayload = z.object({\n  execution: TaskRunExecution,\n  traceContext: z.record(z.unknown()),\n  environment: z.record(z.string()).optional(),\n});\n\nexport type TaskRunExecutionPayload = z.infer<typeof TaskRunExecutionPayload>;\n\n// **IMPORTANT NOTE**: If you change this schema, make sure it is backwards compatible with the previous version as this also used when a worker signals to the coordinator that a TaskRun is complete.\n// Strategies for not breaking backwards compatibility:\n// 1. Add new fields as optional\n// 2. If a field is required, add a default value\nexport const ProdTaskRunExecution = TaskRunExecution.extend({\n  worker: z.object({\n    id: z.string(),\n    contentHash: z.string(),\n    version: z.string(),\n  }),\n  machine: MachinePreset.default({ name: \"small-1x\", cpu: 1, memory: 1, centsPerMs: 0 }),\n});\n\nexport type ProdTaskRunExecution = z.infer<typeof ProdTaskRunExecution>;\n\nexport const ProdTaskRunExecutionPayload = z.object({\n  execution: ProdTaskRunExecution,\n  traceContext: z.record(z.unknown()),\n  environment: z.record(z.string()).optional(),\n});\n\nexport type ProdTaskRunExecutionPayload = z.infer<typeof ProdTaskRunExecutionPayload>;\n\nexport const FixedWindowRateLimit = z.object({\n  type: z.literal(\"fixed-window\"),\n  limit: z.number(),\n  window: z.union([\n    z.object({\n      seconds: z.number(),\n    }),\n    z.object({\n      minutes: z.number(),\n    }),\n    z.object({\n      hours: z.number(),\n    }),\n  ]),\n});\n\nexport const SlidingWindowRateLimit = z.object({\n  type: z.literal(\"sliding-window\"),\n  limit: z.number(),\n  window: z.union([\n    z.object({\n      seconds: z.number(),\n    }),\n    z.object({\n      minutes: z.number(),\n    }),\n    z.object({\n      hours: z.number(),\n    }),\n  ]),\n});\n\nexport const RateLimitOptions = z.discriminatedUnion(\"type\", [\n  FixedWindowRateLimit,\n  SlidingWindowRateLimit,\n]);\n\nexport type RateLimitOptions = z.infer<typeof RateLimitOptions>;\n\nexport const RetryOptions = z.object({\n  /** The number of attempts before giving up */\n  maxAttempts: z.number().int().optional(),\n  /** The exponential factor to use when calculating the next retry time.\n   *\n   * Each subsequent retry will be calculated as `previousTimeout * factor`\n   */\n  factor: z.number().optional(),\n  /** The minimum time to wait before retrying */\n  minTimeoutInMs: z.number().int().optional(),\n  /** The maximum time to wait before retrying */\n  maxTimeoutInMs: z.number().int().optional(),\n  /** Randomize the timeout between retries.\n   *\n   * This can be useful to prevent the thundering herd problem where all retries happen at the same time.\n   */\n  randomize: z.boolean().optional(),\n});\n\nexport type RetryOptions = z.infer<typeof RetryOptions>;\n\nexport const QueueOptions = z.object({\n  /** You can define a shared queue and then pass the name in to your task.\n   * \n   * @example\n   * \n   * ```ts\n   * const myQueue = queue({\n      name: \"my-queue\",\n      concurrencyLimit: 1,\n    });\n\n    export const task1 = task({\n      id: \"task-1\",\n      queue: {\n        name: \"my-queue\",\n      },\n      run: async (payload: { message: string }) => {\n        // ...\n      },\n    });\n\n    export const task2 = task({\n      id: \"task-2\",\n      queue: {\n        name: \"my-queue\",\n      },\n      run: async (payload: { message: string }) => {\n        // ...\n      },\n    });\n   * ```\n   */\n  name: z.string().optional(),\n  /** An optional property that specifies the maximum number of concurrent run executions.\n   *\n   * If this property is omitted, the task can potentially use up the full concurrency of an environment. */\n  concurrencyLimit: z.number().int().min(0).max(1000).optional(),\n  /** @deprecated This feature is coming soon */\n  rateLimit: RateLimitOptions.optional(),\n});\n\nexport type QueueOptions = z.infer<typeof QueueOptions>;\n\nexport const ScheduleMetadata = z.object({\n  cron: z.string(),\n  timezone: z.string(),\n});\n\nexport const TaskMetadata = z.object({\n  id: z.string(),\n  packageVersion: z.string(),\n  queue: QueueOptions.optional(),\n  retry: RetryOptions.optional(),\n  machine: MachineConfig.optional(),\n  triggerSource: z.string().optional(),\n  schedule: ScheduleMetadata.optional(),\n});\n\nexport type TaskMetadata = z.infer<typeof TaskMetadata>;\n\nexport const TaskFileMetadata = z.object({\n  filePath: z.string(),\n  exportName: z.string(),\n});\n\nexport type TaskFileMetadata = z.infer<typeof TaskFileMetadata>;\n\nexport const TaskMetadataWithFilePath = z.object({\n  id: z.string(),\n  packageVersion: z.string(),\n  queue: QueueOptions.optional(),\n  retry: RetryOptions.optional(),\n  machine: MachineConfig.optional(),\n  triggerSource: z.string().optional(),\n  schedule: ScheduleMetadata.optional(),\n  filePath: z.string(),\n  exportName: z.string(),\n});\n\nexport type TaskMetadataWithFilePath = z.infer<typeof TaskMetadataWithFilePath>;\n\nexport const PostStartCauses = z.enum([\"index\", \"create\", \"restore\"]);\nexport type PostStartCauses = z.infer<typeof PostStartCauses>;\n\nexport const PreStopCauses = z.enum([\"terminate\"]);\nexport type PreStopCauses = z.infer<typeof PreStopCauses>;\n\nconst RegexSchema = z.custom<RegExp>((val) => {\n  try {\n    // Check to see if val is a regex\n    return typeof (val as RegExp).test === \"function\";\n  } catch {\n    return false;\n  }\n});\n\nexport const Config = z.object({\n  project: z.string(),\n  triggerDirectories: z.string().array().optional(),\n  triggerUrl: z.string().optional(),\n  projectDir: z.string().optional(),\n  tsconfigPath: z.string().optional(),\n  retries: z\n    .object({\n      enabledInDev: z.boolean().default(true),\n      default: RetryOptions.optional(),\n    })\n    .optional(),\n  additionalPackages: z.string().array().optional(),\n  additionalFiles: z.string().array().optional(),\n  dependenciesToBundle: z.array(z.union([z.string(), RegexSchema])).optional(),\n  logLevel: z.string().optional(),\n  enableConsoleLogging: z.boolean().optional(),\n  postInstall: z.string().optional(),\n  extraCACerts: z.string().optional(),\n});\n\nexport type Config = z.infer<typeof Config>;\nexport type ResolvedConfig = RequireKeys<\n  Config,\n  \"triggerDirectories\" | \"triggerUrl\" | \"projectDir\" | \"tsconfigPath\"\n>;\n\nexport const WaitReason = z.enum([\"WAIT_FOR_DURATION\", \"WAIT_FOR_TASK\", \"WAIT_FOR_BATCH\"]);\n\nexport type WaitReason = z.infer<typeof WaitReason>;\n\nexport const TaskRunExecutionLazyAttemptPayload = z.object({\n  runId: z.string(),\n  attemptCount: z.number().optional(),\n  messageId: z.string(),\n  isTest: z.boolean(),\n  traceContext: z.record(z.unknown()),\n  environment: z.record(z.string()).optional(),\n});\n\nexport type TaskRunExecutionLazyAttemptPayload = z.infer<typeof TaskRunExecutionLazyAttemptPayload>;\n", "import { z } from \"zod\";\n\n// Defaults to 0.5\nexport const MachineCpu = z.union([\n  z.literal(0.25),\n  z.literal(0.5),\n  z.literal(1),\n  z.literal(2),\n  z.literal(4),\n]);\n\nexport type MachineCpu = z.infer<typeof MachineCpu>;\n\n// Defaults to 1\nexport const MachineMemory = z.union([\n  z.literal(0.25),\n  z.literal(0.5),\n  z.literal(1),\n  z.literal(2),\n  z.literal(4),\n  z.literal(8),\n]);\n\nexport type MachineMemory = z.infer<typeof MachineMemory>;\n\n// Default is small-1x\nexport const MachinePresetName = z.enum([\n  \"micro\",\n  \"small-1x\",\n  \"small-2x\",\n  \"medium-1x\",\n  \"medium-2x\",\n  \"large-1x\",\n  \"large-2x\",\n]);\n\nexport type MachinePresetName = z.infer<typeof MachinePresetName>;\n\nexport const MachineConfig = z.object({\n  cpu: MachineCpu.optional(),\n  memory: MachineMemory.optional(),\n  preset: MachinePresetName.optional(),\n});\n\nexport type MachineConfig = z.infer<typeof MachineConfig>;\n\nexport const MachinePreset = z.object({\n  name: MachinePresetName,\n  cpu: z.number(),\n  memory: z.number(),\n  centsPerMs: z.number(),\n});\n\nexport type MachinePreset = z.infer<typeof MachinePreset>;\n\nexport const TaskRunBuiltInError = z.object({\n  type: z.literal(\"BUILT_IN_ERROR\"),\n  name: z.string(),\n  message: z.string(),\n  stackTrace: z.string(),\n});\n\nexport type TaskRunBuiltInError = z.infer<typeof TaskRunBuiltInError>;\n\nexport const TaskRunCustomErrorObject = z.object({\n  type: z.literal(\"CUSTOM_ERROR\"),\n  raw: z.string(),\n});\n\nexport type TaskRunCustomErrorObject = z.infer<typeof TaskRunCustomErrorObject>;\n\nexport const TaskRunStringError = z.object({\n  type: z.literal(\"STRING_ERROR\"),\n  raw: z.string(),\n});\n\nexport type TaskRunStringError = z.infer<typeof TaskRunStringError>;\n\nexport const TaskRunErrorCodes = {\n  COULD_NOT_FIND_EXECUTOR: \"COULD_NOT_FIND_EXECUTOR\",\n  COULD_NOT_FIND_TASK: \"COULD_NOT_FIND_TASK\",\n  CONFIGURED_INCORRECTLY: \"CONFIGURED_INCORRECTLY\",\n  TASK_ALREADY_RUNNING: \"TASK_ALREADY_RUNNING\",\n  TASK_EXECUTION_FAILED: \"TASK_EXECUTION_FAILED\",\n  TASK_EXECUTION_ABORTED: \"TASK_EXECUTION_ABORTED\",\n  TASK_PROCESS_EXITED_WITH_NON_ZERO_CODE: \"TASK_PROCESS_EXITED_WITH_NON_ZERO_CODE\",\n  TASK_PROCESS_SIGKILL_TIMEOUT: \"TASK_PROCESS_SIGKILL_TIMEOUT\",\n  TASK_RUN_CANCELLED: \"TASK_RUN_CANCELLED\",\n  TASK_OUTPUT_ERROR: \"TASK_OUTPUT_ERROR\",\n  HANDLE_ERROR_ERROR: \"HANDLE_ERROR_ERROR\",\n  GRACEFUL_EXIT_TIMEOUT: \"GRACEFUL_EXIT_TIMEOUT\",\n  TASK_RUN_CRASHED: \"TASK_RUN_CRASHED\",\n} as const;\n\nexport const TaskRunInternalError = z.object({\n  type: z.literal(\"INTERNAL_ERROR\"),\n  code: z.enum([\n    \"COULD_NOT_FIND_EXECUTOR\",\n    \"COULD_NOT_FIND_TASK\",\n    \"CONFIGURED_INCORRECTLY\",\n    \"TASK_ALREADY_RUNNING\",\n    \"TASK_EXECUTION_FAILED\",\n    \"TASK_EXECUTION_ABORTED\",\n    \"TASK_PROCESS_EXITED_WITH_NON_ZERO_CODE\",\n    \"TASK_PROCESS_SIGKILL_TIMEOUT\",\n    \"TASK_RUN_CANCELLED\",\n    \"TASK_OUTPUT_ERROR\",\n    \"HANDLE_ERROR_ERROR\",\n    \"GRACEFUL_EXIT_TIMEOUT\",\n    \"TASK_RUN_HEARTBEAT_TIMEOUT\",\n    \"TASK_RUN_CRASHED\",\n  ]),\n  message: z.string().optional(),\n  stackTrace: z.string().optional(),\n});\n\nexport type TaskRunInternalError = z.infer<typeof TaskRunInternalError>;\n\nexport const TaskRunError = z.discriminatedUnion(\"type\", [\n  TaskRunBuiltInError,\n  TaskRunCustomErrorObject,\n  TaskRunStringError,\n  TaskRunInternalError,\n]);\n\nexport type TaskRunError = z.infer<typeof TaskRunError>;\n\nexport const TaskRun = z.object({\n  id: z.string(),\n  payload: z.string(),\n  payloadType: z.string(),\n  context: z.any(),\n  tags: z.array(z.string()),\n  isTest: z.boolean().default(false),\n  createdAt: z.coerce.date(),\n  startedAt: z.coerce.date().default(() => new Date()),\n  idempotencyKey: z.string().optional(),\n  maxAttempts: z.number().optional(),\n  durationMs: z.number().default(0),\n  costInCents: z.number().default(0),\n  baseCostInCents: z.number().default(0),\n  version: z.string().optional(),\n});\n\nexport type TaskRun = z.infer<typeof TaskRun>;\n\nexport const TaskRunExecutionTask = z.object({\n  id: z.string(),\n  filePath: z.string(),\n  exportName: z.string(),\n});\n\nexport type TaskRunExecutionTask = z.infer<typeof TaskRunExecutionTask>;\n\nexport const TaskRunExecutionAttempt = z.object({\n  id: z.string(),\n  number: z.number(),\n  startedAt: z.coerce.date(),\n  backgroundWorkerId: z.string(),\n  backgroundWorkerTaskId: z.string(),\n  status: z.string(),\n});\n\nexport type TaskRunExecutionAttempt = z.infer<typeof TaskRunExecutionAttempt>;\n\nexport const TaskRunExecutionEnvironment = z.object({\n  id: z.string(),\n  slug: z.string(),\n  type: z.enum([\"PRODUCTION\", \"STAGING\", \"DEVELOPMENT\", \"PREVIEW\"]),\n});\n\nexport type TaskRunExecutionEnvironment = z.infer<typeof TaskRunExecutionEnvironment>;\n\nexport const TaskRunExecutionOrganization = z.object({\n  id: z.string(),\n  slug: z.string(),\n  name: z.string(),\n});\n\nexport type TaskRunExecutionOrganization = z.infer<typeof TaskRunExecutionOrganization>;\n\nexport const TaskRunExecutionProject = z.object({\n  id: z.string(),\n  ref: z.string(),\n  slug: z.string(),\n  name: z.string(),\n});\n\nexport type TaskRunExecutionProject = z.infer<typeof TaskRunExecutionProject>;\n\nexport const TaskRunExecutionQueue = z.object({\n  id: z.string(),\n  name: z.string(),\n});\n\nexport type TaskRunExecutionQueue = z.infer<typeof TaskRunExecutionQueue>;\n\nexport const TaskRunExecutionBatch = z.object({\n  id: z.string(),\n});\n\nexport const TaskRunExecution = z.object({\n  task: TaskRunExecutionTask,\n  attempt: TaskRunExecutionAttempt,\n  run: TaskRun,\n  queue: TaskRunExecutionQueue,\n  environment: TaskRunExecutionEnvironment,\n  organization: TaskRunExecutionOrganization,\n  project: TaskRunExecutionProject,\n  batch: TaskRunExecutionBatch.optional(),\n  machine: MachinePreset.optional(),\n});\n\nexport type TaskRunExecution = z.infer<typeof TaskRunExecution>;\n\nexport const TaskRunContext = z.object({\n  task: TaskRunExecutionTask,\n  attempt: TaskRunExecutionAttempt.omit({\n    backgroundWorkerId: true,\n    backgroundWorkerTaskId: true,\n  }),\n  run: TaskRun.omit({ payload: true, payloadType: true }),\n  queue: TaskRunExecutionQueue,\n  environment: TaskRunExecutionEnvironment,\n  organization: TaskRunExecutionOrganization,\n  project: TaskRunExecutionProject,\n  batch: TaskRunExecutionBatch.optional(),\n  machine: MachinePreset.optional(),\n});\n\nexport type TaskRunContext = z.infer<typeof TaskRunContext>;\n\nexport const TaskRunExecutionRetry = z.object({\n  timestamp: z.number(),\n  delay: z.number(),\n  error: z.unknown().optional(),\n});\n\nexport type TaskRunExecutionRetry = z.infer<typeof TaskRunExecutionRetry>;\n\nexport const TaskRunExecutionUsage = z.object({\n  durationMs: z.number(),\n});\n\nexport type TaskRunExecutionUsage = z.infer<typeof TaskRunExecutionUsage>;\n\nexport const TaskRunFailedExecutionResult = z.object({\n  ok: z.literal(false),\n  id: z.string(),\n  error: TaskRunError,\n  retry: TaskRunExecutionRetry.optional(),\n  skippedRetrying: z.boolean().optional(),\n  usage: TaskRunExecutionUsage.optional(),\n});\n\nexport type TaskRunFailedExecutionResult = z.infer<typeof TaskRunFailedExecutionResult>;\n\nexport const TaskRunSuccessfulExecutionResult = z.object({\n  ok: z.literal(true),\n  id: z.string(),\n  output: z.string().optional(),\n  outputType: z.string(),\n  usage: TaskRunExecutionUsage.optional(),\n});\n\nexport type TaskRunSuccessfulExecutionResult = z.infer<typeof TaskRunSuccessfulExecutionResult>;\n\nexport const TaskRunExecutionResult = z.discriminatedUnion(\"ok\", [\n  TaskRunSuccessfulExecutionResult,\n  TaskRunFailedExecutionResult,\n]);\n\nexport type TaskRunExecutionResult = z.infer<typeof TaskRunExecutionResult>;\n\nexport const BatchTaskRunExecutionResult = z.object({\n  id: z.string(),\n  items: TaskRunExecutionResult.array(),\n});\n\nexport type BatchTaskRunExecutionResult = z.infer<typeof BatchTaskRunExecutionResult>;\n", "import { z } from \"zod\";\nimport { TaskRunError } from \"./schemas/common\";\n\nexport class AbortTaskRunError extends Error {\n  constructor(message: string) {\n    super(message);\n    this.name = \"AbortTaskRunError\";\n  }\n}\n\nexport function parseError(error: unknown): TaskRunError {\n  if (error instanceof Error) {\n    return {\n      type: \"BUILT_IN_ERROR\",\n      name: error.name,\n      message: error.message,\n      stackTrace: error.stack ?? \"\",\n    };\n  }\n\n  if (typeof error === \"string\") {\n    return {\n      type: \"STRING_ERROR\",\n      raw: error,\n    };\n  }\n\n  try {\n    return {\n      type: \"CUSTOM_ERROR\",\n      raw: JSON.stringify(error),\n    };\n  } catch (e) {\n    return {\n      type: \"CUSTOM_ERROR\",\n      raw: String(error),\n    };\n  }\n}\n\nexport function createErrorTaskError(error: TaskRunError): any {\n  switch (error.type) {\n    case \"BUILT_IN_ERROR\": {\n      const e = new Error(error.message);\n\n      e.name = error.name;\n      e.stack = error.stackTrace;\n\n      return e;\n    }\n    case \"STRING_ERROR\": {\n      return error.raw;\n    }\n    case \"CUSTOM_ERROR\": {\n      return JSON.parse(error.raw);\n    }\n    case \"INTERNAL_ERROR\": {\n      return new Error(`trigger.dev internal error (${error.code})`);\n    }\n  }\n}\n\nexport const SerializedError = z.object({\n  message: z.string(),\n  name: z.string().optional(),\n  stackTrace: z.string().optional(),\n});\n\nexport type SerializedError = z.infer<typeof SerializedError>;\n\nexport function createJsonErrorObject(error: TaskRunError): SerializedError {\n  switch (error.type) {\n    case \"BUILT_IN_ERROR\": {\n      return {\n        name: error.name,\n        message: error.message,\n        stackTrace: error.stackTrace,\n      };\n    }\n    case \"STRING_ERROR\": {\n      return {\n        message: error.raw,\n      };\n    }\n    case \"CUSTOM_ERROR\": {\n      return {\n        message: error.raw,\n      };\n    }\n    case \"INTERNAL_ERROR\": {\n      return {\n        message: `trigger.dev internal error (${error.code})`,\n      };\n    }\n  }\n}\n\n// Removes any null characters from the error message\nexport function sanitizeError(error: TaskRunError): TaskRunError {\n  switch (error.type) {\n    case \"BUILT_IN_ERROR\": {\n      return {\n        type: \"BUILT_IN_ERROR\",\n        message: error.message?.replace(/\\0/g, \"\"),\n        name: error.name?.replace(/\\0/g, \"\"),\n        stackTrace: error.stackTrace?.replace(/\\0/g, \"\"),\n      };\n    }\n    case \"STRING_ERROR\": {\n      return {\n        type: \"STRING_ERROR\",\n        raw: error.raw.replace(/\\0/g, \"\"),\n      };\n    }\n    case \"CUSTOM_ERROR\": {\n      return {\n        type: \"CUSTOM_ERROR\",\n        raw: error.raw.replace(/\\0/g, \"\"),\n      };\n    }\n    case \"INTERNAL_ERROR\": {\n      return {\n        type: \"INTERNAL_ERROR\",\n        code: error.code,\n        message: error.message?.replace(/\\0/g, \"\"),\n        stackTrace: error.stackTrace?.replace(/\\0/g, \"\"),\n      };\n    }\n  }\n}\n\nexport function correctErrorStackTrace(\n  stackTrace: string,\n  projectDir?: string,\n  options?: { removeFirstLine?: boolean; isDev?: boolean }\n) {\n  const [errorLine, ...traceLines] = stackTrace.split(\"\\n\");\n\n  return [\n    options?.removeFirstLine ? undefined : errorLine,\n    ...traceLines.map((line) => correctStackTraceLine(line, projectDir, options?.isDev)),\n  ]\n    .filter(Boolean)\n    .join(\"\\n\");\n}\n\nconst LINES_TO_IGNORE = [\n  /ConsoleInterceptor/,\n  /TriggerTracer/,\n  /TaskExecutor/,\n  /EXECUTE_TASK_RUN/,\n  /@trigger.dev\\/core/,\n  /packages\\/core\\/src\\/v3/,\n  /safeJsonProcess/,\n  /__entryPoint.ts/,\n  /ZodIpc/,\n  /startActiveSpan/,\n  /processTicksAndRejections/,\n];\n\nfunction correctStackTraceLine(line: string, projectDir?: string, isDev?: boolean) {\n  if (LINES_TO_IGNORE.some((regex) => regex.test(line))) {\n    return;\n  }\n\n  // Check to see if the path is inside the project directory\n  if (isDev && projectDir && !line.includes(projectDir)) {\n    return;\n  }\n\n  return line.trim();\n}\n\nexport function groupTaskMetadataIssuesByTask(tasks: any, issues: z.ZodIssue[]) {\n  return issues.reduce(\n    (acc, issue) => {\n      if (issue.path.length === 0) {\n        return acc;\n      }\n\n      const taskIndex = issue.path[1];\n\n      if (typeof taskIndex !== \"number\") {\n        return acc;\n      }\n\n      const task = tasks[taskIndex];\n\n      if (!task) {\n        return acc;\n      }\n\n      const restOfPath = issue.path.slice(2);\n\n      const taskId = task.id;\n      const taskName = task.exportName;\n      const filePath = task.filePath;\n\n      const key = taskIndex;\n\n      const existing = acc[key] ?? {\n        id: taskId,\n        exportName: taskName,\n        filePath,\n        issues: [] as Array<{ message: string; path?: string }>,\n      };\n\n      existing.issues.push({\n        message: issue.message,\n        path: restOfPath.length === 0 ? undefined : restOfPath.join(\".\"),\n      });\n\n      return {\n        ...acc,\n        [key]: existing,\n      };\n    },\n    {} as Record<\n      number,\n      {\n        id: any;\n        exportName: string;\n        filePath: string;\n        issues: Array<{ message: string; path?: string }>;\n      }\n    >\n  );\n}\n", "import { z } from \"zod\";\nimport {\n  MachinePreset,\n  TaskRunExecution,\n  TaskRunExecutionResult,\n  TaskRunFailedExecutionResult,\n} from \"./common\";\nimport {\n  EnvironmentType,\n  ProdTaskRunExecution,\n  ProdTaskRunExecutionPayload,\n  TaskMetadataWithFilePath,\n  TaskRunExecutionLazyAttemptPayload,\n  TaskRunExecutionPayload,\n  WaitReason,\n} from \"./schemas\";\nimport { TaskResource } from \"./resources\";\n\nexport const BackgroundWorkerServerMessages = z.discriminatedUnion(\"type\", [\n  z.object({\n    type: z.literal(\"EXECUTE_RUNS\"),\n    payloads: z.array(TaskRunExecutionPayload),\n  }),\n  z.object({\n    type: z.literal(\"CANCEL_ATTEMPT\"),\n    taskAttemptId: z.string(),\n    taskRunId: z.string(),\n  }),\n  z.object({\n    type: z.literal(\"SCHEDULE_ATTEMPT\"),\n    image: z.string(),\n    version: z.string(),\n    machine: MachinePreset,\n    nextAttemptNumber: z.number().optional(),\n    // identifiers\n    id: z.string().optional(), // TODO: Remove this completely in a future release\n    envId: z.string(),\n    envType: EnvironmentType,\n    orgId: z.string(),\n    projectId: z.string(),\n    runId: z.string(),\n  }),\n  z.object({\n    type: z.literal(\"EXECUTE_RUN_LAZY_ATTEMPT\"),\n    payload: TaskRunExecutionLazyAttemptPayload,\n  }),\n]);\n\nexport type BackgroundWorkerServerMessages = z.infer<typeof BackgroundWorkerServerMessages>;\n\nexport const serverWebsocketMessages = {\n  SERVER_READY: z.object({\n    version: z.literal(\"v1\").default(\"v1\"),\n    id: z.string(),\n  }),\n  BACKGROUND_WORKER_MESSAGE: z.object({\n    version: z.literal(\"v1\").default(\"v1\"),\n    backgroundWorkerId: z.string(),\n    data: BackgroundWorkerServerMessages,\n  }),\n};\n\nexport const BackgroundWorkerClientMessages = z.discriminatedUnion(\"type\", [\n  z.object({\n    version: z.literal(\"v1\").default(\"v1\"),\n    type: z.literal(\"TASK_RUN_COMPLETED\"),\n    completion: TaskRunExecutionResult,\n    execution: TaskRunExecution,\n  }),\n  z.object({\n    version: z.literal(\"v1\").default(\"v1\"),\n    type: z.literal(\"TASK_RUN_FAILED_TO_RUN\"),\n    completion: TaskRunFailedExecutionResult,\n  }),\n  z.object({\n    version: z.literal(\"v1\").default(\"v1\"),\n    type: z.literal(\"TASK_HEARTBEAT\"),\n    id: z.string(),\n  }),\n  z.object({\n    version: z.literal(\"v1\").default(\"v1\"),\n    type: z.literal(\"TASK_RUN_HEARTBEAT\"),\n    id: z.string(),\n  }),\n]);\n\nexport type BackgroundWorkerClientMessages = z.infer<typeof BackgroundWorkerClientMessages>;\n\nexport const BackgroundWorkerProperties = z.object({\n  id: z.string(),\n  version: z.string(),\n  contentHash: z.string(),\n});\n\nexport type BackgroundWorkerProperties = z.infer<typeof BackgroundWorkerProperties>;\n\nexport const clientWebsocketMessages = {\n  READY_FOR_TASKS: z.object({\n    version: z.literal(\"v1\").default(\"v1\"),\n    backgroundWorkerId: z.string(),\n    inProgressRuns: z.string().array().optional(),\n  }),\n  BACKGROUND_WORKER_DEPRECATED: z.object({\n    version: z.literal(\"v1\").default(\"v1\"),\n    backgroundWorkerId: z.string(),\n  }),\n  BACKGROUND_WORKER_MESSAGE: z.object({\n    version: z.literal(\"v1\").default(\"v1\"),\n    backgroundWorkerId: z.string(),\n    data: BackgroundWorkerClientMessages,\n  }),\n};\n\nexport const workerToChildMessages = {\n  EXECUTE_TASK_RUN: z.object({\n    version: z.literal(\"v1\").default(\"v1\"),\n    execution: TaskRunExecution,\n    traceContext: z.record(z.unknown()),\n    metadata: BackgroundWorkerProperties,\n  }),\n  TASK_RUN_COMPLETED_NOTIFICATION: z.discriminatedUnion(\"version\", [\n    z.object({\n      version: z.literal(\"v1\"),\n      completion: TaskRunExecutionResult,\n      execution: TaskRunExecution,\n    }),\n    z.object({\n      version: z.literal(\"v2\"),\n      completion: TaskRunExecutionResult,\n    }),\n  ]),\n  CLEANUP: z.object({\n    version: z.literal(\"v1\").default(\"v1\"),\n    flush: z.boolean().default(false),\n    kill: z.boolean().default(true),\n  }),\n};\n\nexport const UncaughtExceptionMessage = z.object({\n  version: z.literal(\"v1\").default(\"v1\"),\n  error: z.object({\n    name: z.string(),\n    message: z.string(),\n    stack: z.string().optional(),\n  }),\n  origin: z.enum([\"uncaughtException\", \"unhandledRejection\"]),\n});\n\nexport const TaskMetadataFailedToParseData = z.object({\n  version: z.literal(\"v1\").default(\"v1\"),\n  tasks: z.unknown(),\n  zodIssues: z.custom<z.ZodIssue[]>((v) => {\n    return Array.isArray(v) && v.every((issue) => typeof issue === \"object\" && \"message\" in issue);\n  }),\n});\n\nexport const childToWorkerMessages = {\n  TASK_RUN_COMPLETED: z.object({\n    version: z.literal(\"v1\").default(\"v1\"),\n    execution: TaskRunExecution,\n    result: TaskRunExecutionResult,\n  }),\n  TASKS_READY: z.object({\n    version: z.literal(\"v1\").default(\"v1\"),\n    tasks: TaskMetadataWithFilePath.array(),\n  }),\n  TASKS_FAILED_TO_PARSE: TaskMetadataFailedToParseData,\n  TASK_HEARTBEAT: z.object({\n    version: z.literal(\"v1\").default(\"v1\"),\n    id: z.string(),\n  }),\n  TASK_RUN_HEARTBEAT: z.object({\n    version: z.literal(\"v1\").default(\"v1\"),\n    id: z.string(),\n  }),\n  READY_TO_DISPOSE: z.undefined(),\n  WAIT_FOR_DURATION: z.object({\n    version: z.literal(\"v1\").default(\"v1\"),\n    ms: z.number(),\n  }),\n  WAIT_FOR_TASK: z.object({\n    version: z.literal(\"v1\").default(\"v1\"),\n    id: z.string(),\n  }),\n  WAIT_FOR_BATCH: z.object({\n    version: z.literal(\"v1\").default(\"v1\"),\n    id: z.string(),\n    runs: z.string().array(),\n  }),\n  UNCAUGHT_EXCEPTION: UncaughtExceptionMessage,\n};\n\nexport const ProdChildToWorkerMessages = {\n  TASK_RUN_COMPLETED: {\n    message: z.object({\n      version: z.literal(\"v1\").default(\"v1\"),\n      execution: TaskRunExecution,\n      result: TaskRunExecutionResult,\n    }),\n  },\n  TASKS_READY: {\n    message: z.object({\n      version: z.literal(\"v1\").default(\"v1\"),\n      tasks: TaskMetadataWithFilePath.array(),\n    }),\n  },\n  TASKS_FAILED_TO_PARSE: {\n    message: TaskMetadataFailedToParseData,\n  },\n  TASK_HEARTBEAT: {\n    message: z.object({\n      version: z.literal(\"v1\").default(\"v1\"),\n      id: z.string(),\n    }),\n  },\n  READY_TO_DISPOSE: {\n    message: z.undefined(),\n  },\n  WAIT_FOR_DURATION: {\n    message: z.object({\n      version: z.literal(\"v1\").default(\"v1\"),\n      ms: z.number(),\n      now: z.number(),\n      waitThresholdInMs: z.number(),\n    }),\n  },\n  WAIT_FOR_TASK: {\n    message: z.object({\n      version: z.literal(\"v1\").default(\"v1\"),\n      friendlyId: z.string(),\n    }),\n  },\n  WAIT_FOR_BATCH: {\n    message: z.object({\n      version: z.literal(\"v1\").default(\"v1\"),\n      batchFriendlyId: z.string(),\n      runFriendlyIds: z.string().array(),\n    }),\n  },\n  UNCAUGHT_EXCEPTION: {\n    message: UncaughtExceptionMessage,\n  },\n};\n\nexport const ProdWorkerToChildMessages = {\n  EXECUTE_TASK_RUN: {\n    message: z.object({\n      version: z.literal(\"v1\").default(\"v1\"),\n      execution: TaskRunExecution,\n      traceContext: z.record(z.unknown()),\n      metadata: BackgroundWorkerProperties,\n    }),\n  },\n  TASK_RUN_COMPLETED_NOTIFICATION: {\n    message: z.discriminatedUnion(\"version\", [\n      z.object({\n        version: z.literal(\"v1\"),\n        completion: TaskRunExecutionResult,\n        execution: TaskRunExecution,\n      }),\n      z.object({\n        version: z.literal(\"v2\"),\n        completion: TaskRunExecutionResult,\n      }),\n    ]),\n  },\n  CLEANUP: {\n    message: z.object({\n      version: z.literal(\"v1\").default(\"v1\"),\n      flush: z.boolean().default(false),\n      kill: z.boolean().default(true),\n    }),\n    callback: z.void(),\n  },\n  WAIT_COMPLETED_NOTIFICATION: {\n    message: z.object({\n      version: z.literal(\"v1\").default(\"v1\"),\n    }),\n  },\n};\n\nexport const ProviderToPlatformMessages = {\n  LOG: {\n    message: z.object({\n      version: z.literal(\"v1\").default(\"v1\"),\n      data: z.string(),\n    }),\n  },\n  LOG_WITH_ACK: {\n    message: z.object({\n      version: z.literal(\"v1\").default(\"v1\"),\n      data: z.string(),\n    }),\n    callback: z.object({\n      status: z.literal(\"ok\"),\n    }),\n  },\n  WORKER_CRASHED: {\n    message: z.object({\n      version: z.literal(\"v1\").default(\"v1\"),\n      runId: z.string(),\n      reason: z.string().optional(),\n      exitCode: z.number().optional(),\n      message: z.string().optional(),\n      logs: z.string().optional(),\n      overrideCompletion: z.boolean().optional(),\n    }),\n  },\n  INDEXING_FAILED: {\n    message: z.object({\n      version: z.literal(\"v1\").default(\"v1\"),\n      deploymentId: z.string(),\n      error: z.object({\n        name: z.string(),\n        message: z.string(),\n        stack: z.string().optional(),\n        stderr: z.string().optional(),\n      }),\n      overrideCompletion: z.boolean().optional(),\n    }),\n  },\n};\n\nexport const PlatformToProviderMessages = {\n  INDEX: {\n    message: z.object({\n      version: z.literal(\"v1\").default(\"v1\"),\n      imageTag: z.string(),\n      shortCode: z.string(),\n      apiKey: z.string(),\n      apiUrl: z.string(),\n      // identifiers\n      envId: z.string(),\n      envType: EnvironmentType,\n      orgId: z.string(),\n      projectId: z.string(),\n      deploymentId: z.string(),\n    }),\n    callback: z.discriminatedUnion(\"success\", [\n      z.object({\n        success: z.literal(false),\n        error: z.object({\n          name: z.string(),\n          message: z.string(),\n          stack: z.string().optional(),\n          stderr: z.string().optional(),\n        }),\n      }),\n      z.object({\n        success: z.literal(true),\n      }),\n    ]),\n  },\n  RESTORE: {\n    message: z.object({\n      version: z.literal(\"v1\").default(\"v1\"),\n      type: z.enum([\"DOCKER\", \"KUBERNETES\"]),\n      location: z.string(),\n      reason: z.string().optional(),\n      imageRef: z.string(),\n      attemptNumber: z.number().optional(),\n      machine: MachinePreset,\n      // identifiers\n      checkpointId: z.string(),\n      envId: z.string(),\n      envType: EnvironmentType,\n      orgId: z.string(),\n      projectId: z.string(),\n      runId: z.string(),\n    }),\n  },\n  PRE_PULL_DEPLOYMENT: {\n    message: z.object({\n      version: z.literal(\"v1\").default(\"v1\"),\n      imageRef: z.string(),\n      shortCode: z.string(),\n      // identifiers\n      envId: z.string(),\n      envType: EnvironmentType,\n      orgId: z.string(),\n      projectId: z.string(),\n      deploymentId: z.string(),\n    }),\n  },\n};\n\nconst CreateWorkerMessage = z.object({\n  projectRef: z.string(),\n  envId: z.string(),\n  deploymentId: z.string(),\n  metadata: z.object({\n    cliPackageVersion: z.string().optional(),\n    contentHash: z.string(),\n    packageVersion: z.string(),\n    tasks: TaskResource.array(),\n  }),\n});\n\nexport const CoordinatorToPlatformMessages = {\n  LOG: {\n    message: z.object({\n      version: z.literal(\"v1\").default(\"v1\"),\n      metadata: z.any(),\n      text: z.string(),\n    }),\n  },\n  CREATE_WORKER: {\n    message: z.discriminatedUnion(\"version\", [\n      CreateWorkerMessage.extend({\n        version: z.literal(\"v1\"),\n      }),\n      CreateWorkerMessage.extend({\n        version: z.literal(\"v2\"),\n        supportsLazyAttempts: z.boolean(),\n      }),\n    ]),\n    callback: z.discriminatedUnion(\"success\", [\n      z.object({\n        success: z.literal(false),\n      }),\n      z.object({\n        success: z.literal(true),\n      }),\n    ]),\n  },\n  CREATE_TASK_RUN_ATTEMPT: {\n    message: z.object({\n      version: z.literal(\"v1\").default(\"v1\"),\n      runId: z.string(),\n      envId: z.string(),\n    }),\n    callback: z.discriminatedUnion(\"success\", [\n      z.object({\n        success: z.literal(false),\n        reason: z.string().optional(),\n      }),\n      z.object({\n        success: z.literal(true),\n        executionPayload: ProdTaskRunExecutionPayload,\n      }),\n    ]),\n  },\n  // Deprecated: Only workers without lazy attempt support will use this\n  READY_FOR_EXECUTION: {\n    message: z.object({\n      version: z.literal(\"v1\").default(\"v1\"),\n      runId: z.string(),\n      totalCompletions: z.number(),\n    }),\n    callback: z.discriminatedUnion(\"success\", [\n      z.object({\n        success: z.literal(false),\n      }),\n      z.object({\n        success: z.literal(true),\n        payload: ProdTaskRunExecutionPayload,\n      }),\n    ]),\n  },\n  READY_FOR_LAZY_ATTEMPT: {\n    message: z.object({\n      version: z.literal(\"v1\").default(\"v1\"),\n      runId: z.string(),\n      envId: z.string(),\n      totalCompletions: z.number(),\n    }),\n    callback: z.discriminatedUnion(\"success\", [\n      z.object({\n        success: z.literal(false),\n        reason: z.string().optional(),\n      }),\n      z.object({\n        success: z.literal(true),\n        lazyPayload: TaskRunExecutionLazyAttemptPayload,\n      }),\n    ]),\n  },\n  READY_FOR_RESUME: {\n    message: z.object({\n      version: z.literal(\"v1\").default(\"v1\"),\n      attemptFriendlyId: z.string(),\n      type: WaitReason,\n    }),\n  },\n  TASK_RUN_COMPLETED: {\n    message: z.object({\n      version: z.enum([\"v1\", \"v2\"]).default(\"v1\"),\n      execution: ProdTaskRunExecution,\n      completion: TaskRunExecutionResult,\n      checkpoint: z\n        .object({\n          docker: z.boolean(),\n          location: z.string(),\n        })\n        .optional(),\n    }),\n  },\n  TASK_RUN_FAILED_TO_RUN: {\n    message: z.object({\n      version: z.literal(\"v1\").default(\"v1\"),\n      completion: TaskRunFailedExecutionResult,\n    }),\n  },\n  TASK_HEARTBEAT: {\n    message: z.object({\n      version: z.literal(\"v1\").default(\"v1\"),\n      attemptFriendlyId: z.string(),\n    }),\n  },\n  TASK_RUN_HEARTBEAT: {\n    message: z.object({\n      version: z.literal(\"v1\").default(\"v1\"),\n      runId: z.string(),\n    }),\n  },\n  CHECKPOINT_CREATED: {\n    message: z.object({\n      version: z.literal(\"v1\").default(\"v1\"),\n      attemptFriendlyId: z.string(),\n      docker: z.boolean(),\n      location: z.string(),\n      reason: z.discriminatedUnion(\"type\", [\n        z.object({\n          type: z.literal(\"WAIT_FOR_DURATION\"),\n          ms: z.number(),\n          now: z.number(),\n        }),\n        z.object({\n          type: z.literal(\"WAIT_FOR_BATCH\"),\n          batchFriendlyId: z.string(),\n          runFriendlyIds: z.string().array(),\n        }),\n        z.object({\n          type: z.literal(\"WAIT_FOR_TASK\"),\n          friendlyId: z.string(),\n        }),\n        z.object({\n          type: z.literal(\"RETRYING_AFTER_FAILURE\"),\n          attemptNumber: z.number(),\n        }),\n      ]),\n    }),\n    callback: z.object({\n      version: z.literal(\"v1\").default(\"v1\"),\n      keepRunAlive: z.boolean(),\n    }),\n  },\n  INDEXING_FAILED: {\n    message: z.object({\n      version: z.literal(\"v1\").default(\"v1\"),\n      deploymentId: z.string(),\n      error: z.object({\n        name: z.string(),\n        message: z.string(),\n        stack: z.string().optional(),\n        stderr: z.string().optional(),\n      }),\n    }),\n  },\n  RUN_CRASHED: {\n    message: z.object({\n      version: z.literal(\"v1\").default(\"v1\"),\n      runId: z.string(),\n      error: z.object({\n        name: z.string(),\n        message: z.string(),\n        stack: z.string().optional(),\n      }),\n    }),\n  },\n};\n\nexport const PlatformToCoordinatorMessages = {\n  RESUME_AFTER_DEPENDENCY: {\n    message: z.object({\n      version: z.literal(\"v1\").default(\"v1\"),\n      runId: z.string(),\n      attemptId: z.string(),\n      attemptFriendlyId: z.string(),\n      completions: TaskRunExecutionResult.array(),\n      executions: TaskRunExecution.array(),\n    }),\n  },\n  RESUME_AFTER_DURATION: {\n    message: z.object({\n      version: z.literal(\"v1\").default(\"v1\"),\n      attemptId: z.string(),\n      attemptFriendlyId: z.string(),\n    }),\n  },\n  REQUEST_ATTEMPT_CANCELLATION: {\n    message: z.object({\n      version: z.literal(\"v1\").default(\"v1\"),\n      attemptId: z.string(),\n      attemptFriendlyId: z.string(),\n    }),\n  },\n  REQUEST_RUN_CANCELLATION: {\n    message: z.object({\n      version: z.literal(\"v1\").default(\"v1\"),\n      runId: z.string(),\n      delayInMs: z.number().optional(),\n    }),\n  },\n  READY_FOR_RETRY: {\n    message: z.object({\n      version: z.literal(\"v1\").default(\"v1\"),\n      runId: z.string(),\n    }),\n  },\n  DYNAMIC_CONFIG: {\n    message: z.object({\n      version: z.literal(\"v1\").default(\"v1\"),\n      checkpointThresholdInMs: z.number(),\n    }),\n  },\n};\n\nexport const ClientToSharedQueueMessages = {\n  READY_FOR_TASKS: {\n    message: z.object({\n      version: z.literal(\"v1\").default(\"v1\"),\n      backgroundWorkerId: z.string(),\n    }),\n  },\n  BACKGROUND_WORKER_DEPRECATED: {\n    message: z.object({\n      version: z.literal(\"v1\").default(\"v1\"),\n      backgroundWorkerId: z.string(),\n    }),\n  },\n  BACKGROUND_WORKER_MESSAGE: {\n    message: z.object({\n      version: z.literal(\"v1\").default(\"v1\"),\n      backgroundWorkerId: z.string(),\n      data: BackgroundWorkerClientMessages,\n    }),\n  },\n};\n\nexport const SharedQueueToClientMessages = {\n  SERVER_READY: {\n    message: z.object({\n      version: z.literal(\"v1\").default(\"v1\"),\n      id: z.string(),\n    }),\n  },\n  BACKGROUND_WORKER_MESSAGE: {\n    message: z.object({\n      version: z.literal(\"v1\").default(\"v1\"),\n      backgroundWorkerId: z.string(),\n      data: BackgroundWorkerServerMessages,\n    }),\n  },\n};\n\nconst IndexTasksMessage = z.object({\n  version: z.literal(\"v1\"),\n  deploymentId: z.string(),\n  tasks: TaskResource.array(),\n  packageVersion: z.string(),\n});\n\nexport const ProdWorkerToCoordinatorMessages = {\n  TEST: {\n    message: z.object({\n      version: z.literal(\"v1\").default(\"v1\"),\n    }),\n    callback: z.void(),\n  },\n  INDEX_TASKS: {\n    message: z.discriminatedUnion(\"version\", [\n      IndexTasksMessage.extend({\n        version: z.literal(\"v1\"),\n      }),\n      IndexTasksMessage.extend({\n        version: z.literal(\"v2\"),\n        supportsLazyAttempts: z.boolean(),\n      }),\n    ]),\n    callback: z.discriminatedUnion(\"success\", [\n      z.object({\n        success: z.literal(false),\n      }),\n      z.object({\n        success: z.literal(true),\n      }),\n    ]),\n  },\n  // Deprecated: Only workers without lazy attempt support will use this\n  READY_FOR_EXECUTION: {\n    message: z.object({\n      version: z.literal(\"v1\").default(\"v1\"),\n      runId: z.string(),\n      totalCompletions: z.number(),\n    }),\n  },\n  READY_FOR_LAZY_ATTEMPT: {\n    message: z.object({\n      version: z.literal(\"v1\").default(\"v1\"),\n      runId: z.string(),\n      totalCompletions: z.number(),\n    }),\n  },\n  READY_FOR_RESUME: {\n    message: z.discriminatedUnion(\"version\", [\n      z.object({\n        version: z.literal(\"v1\"),\n        attemptFriendlyId: z.string(),\n        type: WaitReason,\n      }),\n      z.object({\n        version: z.literal(\"v2\"),\n        attemptFriendlyId: z.string(),\n        attemptNumber: z.number(),\n        type: WaitReason,\n      }),\n    ]),\n  },\n  READY_FOR_CHECKPOINT: {\n    message: z.object({\n      version: z.literal(\"v1\").default(\"v1\"),\n    }),\n  },\n  CANCEL_CHECKPOINT: {\n    message: z\n      .discriminatedUnion(\"version\", [\n        z.object({\n          version: z.literal(\"v1\"),\n        }),\n        z.object({\n          version: z.literal(\"v2\"),\n          reason: WaitReason.optional(),\n        }),\n      ])\n      .default({ version: \"v1\" }),\n    callback: z.object({\n      version: z.literal(\"v2\").default(\"v2\"),\n      checkpointCanceled: z.boolean(),\n      reason: WaitReason.optional(),\n    }),\n  },\n  TASK_HEARTBEAT: {\n    message: z.object({\n      version: z.literal(\"v1\").default(\"v1\"),\n      attemptFriendlyId: z.string(),\n    }),\n  },\n  TASK_RUN_HEARTBEAT: {\n    message: z.object({\n      version: z.literal(\"v1\").default(\"v1\"),\n      runId: z.string(),\n    }),\n  },\n  TASK_RUN_COMPLETED: {\n    message: z.object({\n      version: z.enum([\"v1\", \"v2\"]).default(\"v1\"),\n      execution: ProdTaskRunExecution,\n      completion: TaskRunExecutionResult,\n    }),\n    callback: z.object({\n      willCheckpointAndRestore: z.boolean(),\n      shouldExit: z.boolean(),\n    }),\n  },\n  TASK_RUN_FAILED_TO_RUN: {\n    message: z.object({\n      version: z.literal(\"v1\").default(\"v1\"),\n      completion: TaskRunFailedExecutionResult,\n    }),\n  },\n  WAIT_FOR_DURATION: {\n    message: z.object({\n      version: z.literal(\"v1\").default(\"v1\"),\n      ms: z.number(),\n      now: z.number(),\n      attemptFriendlyId: z.string(),\n    }),\n    callback: z.object({\n      willCheckpointAndRestore: z.boolean(),\n    }),\n  },\n  WAIT_FOR_TASK: {\n    message: z.object({\n      version: z.enum([\"v1\", \"v2\"]).default(\"v1\"),\n      friendlyId: z.string(),\n      // This is the attempt that is waiting\n      attemptFriendlyId: z.string(),\n    }),\n    callback: z.object({\n      willCheckpointAndRestore: z.boolean(),\n    }),\n  },\n  WAIT_FOR_BATCH: {\n    message: z.object({\n      version: z.enum([\"v1\", \"v2\"]).default(\"v1\"),\n      batchFriendlyId: z.string(),\n      runFriendlyIds: z.string().array(),\n      // This is the attempt that is waiting\n      attemptFriendlyId: z.string(),\n    }),\n    callback: z.object({\n      willCheckpointAndRestore: z.boolean(),\n    }),\n  },\n  INDEXING_FAILED: {\n    message: z.object({\n      version: z.literal(\"v1\").default(\"v1\"),\n      deploymentId: z.string(),\n      error: z.object({\n        name: z.string(),\n        message: z.string(),\n        stack: z.string().optional(),\n        stderr: z.string().optional(),\n      }),\n    }),\n  },\n  CREATE_TASK_RUN_ATTEMPT: {\n    message: z.object({\n      version: z.literal(\"v1\").default(\"v1\"),\n      runId: z.string(),\n    }),\n    callback: z.discriminatedUnion(\"success\", [\n      z.object({\n        success: z.literal(false),\n        reason: z.string().optional(),\n      }),\n      z.object({\n        success: z.literal(true),\n        executionPayload: ProdTaskRunExecutionPayload,\n      }),\n    ]),\n  },\n  UNRECOVERABLE_ERROR: {\n    message: z.object({\n      version: z.literal(\"v1\").default(\"v1\"),\n      error: z.object({\n        name: z.string(),\n        message: z.string(),\n        stack: z.string().optional(),\n      }),\n    }),\n  },\n  SET_STATE: {\n    message: z.object({\n      version: z.literal(\"v1\").default(\"v1\"),\n      attemptFriendlyId: z.string().optional(),\n      attemptNumber: z.string().optional(),\n    }),\n  },\n};\n\n// TODO: The coordinator can only safely use v1 worker messages, higher versions will need a new flag, e.g. SUPPORTS_VERSIONED_MESSAGES\nexport const CoordinatorToProdWorkerMessages = {\n  RESUME_AFTER_DEPENDENCY: {\n    message: z.object({\n      version: z.literal(\"v1\").default(\"v1\"),\n      attemptId: z.string(),\n      completions: TaskRunExecutionResult.array(),\n      executions: TaskRunExecution.array(),\n    }),\n  },\n  RESUME_AFTER_DURATION: {\n    message: z.object({\n      version: z.literal(\"v1\").default(\"v1\"),\n      attemptId: z.string(),\n    }),\n  },\n  // Deprecated: Only workers without lazy attempt support will use this\n  EXECUTE_TASK_RUN: {\n    message: z.object({\n      version: z.literal(\"v1\").default(\"v1\"),\n      executionPayload: ProdTaskRunExecutionPayload,\n    }),\n  },\n  EXECUTE_TASK_RUN_LAZY_ATTEMPT: {\n    message: z.object({\n      version: z.literal(\"v1\").default(\"v1\"),\n      lazyPayload: TaskRunExecutionLazyAttemptPayload,\n    }),\n  },\n  REQUEST_ATTEMPT_CANCELLATION: {\n    message: z.object({\n      version: z.literal(\"v1\").default(\"v1\"),\n      attemptId: z.string(),\n    }),\n  },\n  REQUEST_EXIT: {\n    message: z.discriminatedUnion(\"version\", [\n      z.object({\n        version: z.literal(\"v1\"),\n      }),\n      z.object({\n        version: z.literal(\"v2\"),\n        delayInMs: z.number().optional(),\n      }),\n    ]),\n  },\n  READY_FOR_RETRY: {\n    message: z.object({\n      version: z.literal(\"v1\").default(\"v1\"),\n      runId: z.string(),\n    }),\n  },\n};\n\nexport const ProdWorkerSocketData = z.object({\n  contentHash: z.string(),\n  projectRef: z.string(),\n  envId: z.string(),\n  runId: z.string(),\n  attemptFriendlyId: z.string().optional(),\n  attemptNumber: z.string().optional(),\n  podName: z.string(),\n  deploymentId: z.string(),\n  deploymentVersion: z.string(),\n});\n\nexport const CoordinatorSocketData = z.object({\n  supportsDynamicConfig: z.string().optional(),\n});\n", "import { z } from \"zod\";\n\nexport const PRIMARY_VARIANT = \"primary\";\n\nconst Variant = z.enum([PRIMARY_VARIANT]);\nexport type Variant = z.infer<typeof Variant>;\n\nconst AccessoryItem = z.object({\n  text: z.string(),\n  variant: z.string().optional(),\n  url: z.string().optional(),\n});\n\nconst Accessory = z.object({\n  items: z.array(AccessoryItem),\n  style: z.enum([\"codepath\"]).optional(),\n});\n\nexport type Accessory = z.infer<typeof Accessory>;\n\nexport const TaskEventStyle = z\n  .object({\n    icon: z.string().optional(),\n    variant: Variant.optional(),\n    accessory: Accessory.optional(),\n  })\n  .default({\n    icon: undefined,\n    variant: undefined,\n  });\n\nexport type TaskEventStyle = z.infer<typeof TaskEventStyle>;\n", "import { z } from \"zod\";\nimport { RetryOptions } from \"./schemas\";\nimport { EventFilter } from \"./eventFilter\";\nimport { Prettify } from \"../types\";\n\nexport const FetchRetryHeadersStrategy = z.object({\n  /** The `headers` strategy retries the request using info from the response headers. */\n  strategy: z.literal(\"headers\"),\n  /** The header to use to determine the maximum number of times to retry the request. */\n  limitHeader: z.string(),\n  /** The header to use to determine the number of remaining retries. */\n  remainingHeader: z.string(),\n  /** The header to use to determine the time when the number of remaining retries will be reset. */\n  resetHeader: z.string(),\n  /** The event filter to use to determine if the request should be retried. */\n  bodyFilter: EventFilter.optional(),\n\n  /** The format of the `resetHeader` value. */\n  resetFormat: z\n    .enum([\n      \"unix_timestamp\",\n      \"unix_timestamp_in_ms\",\n      \"iso_8601\",\n      \"iso_8601_duration_openai_variant\",\n    ])\n    .default(\"unix_timestamp\")\n    .optional(),\n});\n\nexport type FetchRetryHeadersStrategy = z.infer<typeof FetchRetryHeadersStrategy>;\n\nexport const FetchRetryBackoffStrategy = RetryOptions.extend({\n  /** The `backoff` strategy retries the request with an exponential backoff. */\n  strategy: z.literal(\"backoff\"),\n  /** The event filter to use to determine if the request should be retried. */\n  bodyFilter: EventFilter.optional(),\n});\n\n/** The `backoff` strategy retries the request with an exponential backoff. */\nexport type FetchRetryBackoffStrategy = z.infer<typeof FetchRetryBackoffStrategy>;\n\nexport const FetchRetryStrategy = z.discriminatedUnion(\"strategy\", [\n  FetchRetryHeadersStrategy,\n  FetchRetryBackoffStrategy,\n]);\n\nexport type FetchRetryStrategy = z.infer<typeof FetchRetryStrategy>;\n\nexport const FetchRetryByStatusOptions = z.record(z.string(), FetchRetryStrategy);\n\n/** An object where the key is a status code pattern and the value is a retrying strategy. Supported patterns are:\n  - Specific status codes: 429\n  - Ranges: 500-599\n  - Wildcards: 2xx, 3xx, 4xx, 5xx \n  */\nexport type FetchRetryByStatusOptions = Prettify<z.infer<typeof FetchRetryByStatusOptions>>;\n\nexport const FetchTimeoutOptions = z.object({\n  /** The maximum time to wait for the request to complete. */\n  durationInMs: z.number().optional(),\n  retry: RetryOptions.optional(),\n});\n\nexport type FetchTimeoutOptions = z.infer<typeof FetchTimeoutOptions>;\n\nexport const FetchRetryOptions = z.object({\n  /** The retrying strategy for specific status codes. */\n  byStatus: FetchRetryByStatusOptions.optional(),\n  /** The timeout options for the request. */\n  timeout: RetryOptions.optional(),\n  /**\n   * The retrying strategy for connection errors.\n   */\n  connectionError: RetryOptions.optional(),\n});\n\nexport type FetchRetryOptions = Prettify<z.infer<typeof FetchRetryOptions>>;\n", "import { z } from \"zod\";\n\nexport const stringPatternMatchers = [\n  z.object({\n    $endsWith: z.string(),\n  }),\n  z.object({\n    $startsWith: z.string(),\n  }),\n  z.object({\n    $ignoreCaseEquals: z.string(),\n  }),\n] as const;\n\nconst EventMatcher = z.union([\n  /** Match against a string */\n  z.array(z.string()),\n  /** Match against a number */\n  z.array(z.number()),\n  /** Match against a boolean */\n  z.array(z.boolean()),\n  z.array(\n    z.union([\n      ...stringPatternMatchers,\n      z.object({\n        $exists: z.boolean(),\n      }),\n      z.object({\n        $isNull: z.boolean(),\n      }),\n      z.object({\n        $anythingBut: z.union([z.string(), z.number(), z.boolean()]),\n      }),\n      z.object({\n        $anythingBut: z.union([z.array(z.string()), z.array(z.number()), z.array(z.boolean())]),\n      }),\n      z.object({\n        $gt: z.number(),\n      }),\n      z.object({\n        $lt: z.number(),\n      }),\n      z.object({\n        $gte: z.number(),\n      }),\n      z.object({\n        $lte: z.number(),\n      }),\n      z.object({\n        $between: z.tuple([z.number(), z.number()]),\n      }),\n      z.object({\n        $includes: z.union([z.string(), z.number(), z.boolean()]),\n      }),\n      z.object({\n        $not: z.union([z.string(), z.number(), z.boolean()]),\n      }),\n    ])\n  ),\n]);\n\ntype EventMatcher = z.infer<typeof EventMatcher>;\n\n/** A filter for matching against data */\nexport type EventFilter = { [key: string]: EventMatcher | EventFilter };\n\nexport const EventFilter: z.ZodType<EventFilter> = z.lazy(() =>\n  z.record(z.union([EventMatcher, EventFilter]))\n);\n", "import { z } from \"zod\";\n\nexport const ExceptionEventProperties = z.object({\n  type: z.string().optional(),\n  message: z.string().optional(),\n  stacktrace: z.string().optional(),\n});\n\nexport type ExceptionEventProperties = z.infer<typeof ExceptionEventProperties>;\n\nexport const ExceptionSpanEvent = z.object({\n  name: z.literal(\"exception\"),\n  time: z.coerce.date(),\n  properties: z.object({\n    exception: ExceptionEventProperties,\n  }),\n});\n\nexport type ExceptionSpanEvent = z.infer<typeof ExceptionSpanEvent>;\n\nexport const CancellationSpanEvent = z.object({\n  name: z.literal(\"cancellation\"),\n  time: z.coerce.date(),\n  properties: z.object({\n    reason: z.string(),\n  }),\n});\n\nexport type CancellationSpanEvent = z.infer<typeof CancellationSpanEvent>;\n\nexport const OtherSpanEvent = z.object({\n  name: z.string(),\n  time: z.coerce.date(),\n  properties: z.record(z.unknown()),\n});\n\nexport type OtherSpanEvent = z.infer<typeof OtherSpanEvent>;\n\nexport const SpanEvent = z.union([ExceptionSpanEvent, CancellationSpanEvent, OtherSpanEvent]);\n\nexport type SpanEvent = z.infer<typeof SpanEvent>;\n\nexport const SpanEvents = z.array(SpanEvent);\n\nexport type SpanEvents = z.infer<typeof SpanEvents>;\n\nexport function isExceptionSpanEvent(event: SpanEvent): event is ExceptionSpanEvent {\n  return event.name === \"exception\";\n}\n\nexport function isCancellationSpanEvent(event: SpanEvent): event is CancellationSpanEvent {\n  return event.name === \"cancellation\";\n}\n\nexport const SpanMessagingEvent = z.object({\n  system: z.string().optional(),\n  client_id: z.string().optional(),\n  operation: z.enum([\"publish\", \"create\", \"receive\", \"deliver\"]),\n  message: z.any(),\n  destination: z.string().optional(),\n});\n\nexport type SpanMessagingEvent = z.infer<typeof SpanMessagingEvent>;\n", "export const _globalThis = typeof globalThis === \"object\" ? globalThis : global;\n", "import { ApiClientConfiguration } from \"../apiClientManager/types\";\nimport { Clock } from \"../clock/clock\";\nimport type { RuntimeManager } from \"../runtime/manager\";\nimport { TaskCatalog } from \"../task-catalog/catalog\";\nimport { TaskContext } from \"../taskContext/types\";\nimport { UsageManager } from \"../usage/types\";\nimport { _globalThis } from \"./platform\";\n\nconst GLOBAL_TRIGGER_DOT_DEV_KEY = Symbol.for(`dev.trigger.ts.api`);\n\nconst _global = _globalThis as TriggerDotDevGlobal;\n\nexport function registerGlobal<Type extends keyof TriggerDotDevGlobalAPI>(\n  type: Type,\n  instance: TriggerDotDevGlobalAPI[Type],\n  allowOverride = false\n): boolean {\n  const api = (_global[GLOBAL_TRIGGER_DOT_DEV_KEY] = _global[GLOBAL_TRIGGER_DOT_DEV_KEY] ?? {});\n\n  if (!allowOverride && api[type]) {\n    // already registered an API of this type\n    const err = new Error(`trigger.dev: Attempted duplicate registration of API: ${type}`);\n    return false;\n  }\n\n  api[type] = instance;\n\n  return true;\n}\n\nexport function getGlobal<Type extends keyof TriggerDotDevGlobalAPI>(\n  type: Type\n): TriggerDotDevGlobalAPI[Type] | undefined {\n  return _global[GLOBAL_TRIGGER_DOT_DEV_KEY]?.[type];\n}\n\nexport function unregisterGlobal(type: keyof TriggerDotDevGlobalAPI) {\n  const api = _global[GLOBAL_TRIGGER_DOT_DEV_KEY];\n\n  if (api) {\n    delete api[type];\n  }\n}\n\ntype TriggerDotDevGlobal = {\n  [GLOBAL_TRIGGER_DOT_DEV_KEY]?: TriggerDotDevGlobalAPI;\n};\n\ntype TriggerDotDevGlobalAPI = {\n  runtime?: RuntimeManager;\n  logger?: any;\n  clock?: Clock;\n  usage?: UsageManager;\n  [\"task-catalog\"]?: TaskCatalog;\n  [\"task-context\"]?: TaskContext;\n  [\"api-client\"]?: ApiClientConfiguration;\n};\n", "export const SemanticInternalAttributes = {\n  ENVIRONMENT_ID: \"ctx.environment.id\",\n  ENVIRONMENT_TYPE: \"ctx.environment.type\",\n  ORGANIZATION_ID: \"ctx.organization.id\",\n  ORGANIZATION_SLUG: \"ctx.organization.slug\",\n  ORGANIZATION_NAME: \"ctx.organization.name\",\n  PROJECT_ID: \"ctx.project.id\",\n  PROJECT_REF: \"ctx.project.ref\",\n  PROJECT_NAME: \"ctx.project.title\",\n  PROJECT_DIR: \"project.dir\",\n  ATTEMPT_ID: \"ctx.attempt.id\",\n  ATTEMPT_NUMBER: \"ctx.attempt.number\",\n  RUN_ID: \"ctx.run.id\",\n  RUN_IS_TEST: \"ctx.run.isTest\",\n  BATCH_ID: \"ctx.batch.id\",\n  TASK_SLUG: \"ctx.task.id\",\n  TASK_PATH: \"ctx.task.filePath\",\n  TASK_EXPORT_NAME: \"ctx.task.exportName\",\n  QUEUE_NAME: \"ctx.queue.name\",\n  QUEUE_ID: \"ctx.queue.id\",\n  MACHINE_PRESET_NAME: \"ctx.machine.name\",\n  MACHINE_PRESET_CPU: \"ctx.machine.cpu\",\n  MACHINE_PRESET_MEMORY: \"ctx.machine.memory\",\n  MACHINE_PRESET_CENTS_PER_MS: \"ctx.machine.centsPerMs\",\n  SPAN_PARTIAL: \"$span.partial\",\n  SPAN_ID: \"$span.span_id\",\n  OUTPUT: \"$output\",\n  OUTPUT_TYPE: \"$mime_type_output\",\n  STYLE: \"$style\",\n  STYLE_ICON: \"$style.icon\",\n  STYLE_VARIANT: \"$style.variant\",\n  STYLE_ACCESSORY: \"$style.accessory\",\n  METADATA: \"$metadata\",\n  TRIGGER: \"$trigger\",\n  PAYLOAD: \"$payload\",\n  PAYLOAD_TYPE: \"$mime_type_payload\",\n  SHOW: \"$show\",\n  SHOW_ACTIONS: \"$show.actions\",\n  WORKER_ID: \"worker.id\",\n  WORKER_VERSION: \"worker.version\",\n  CLI_VERSION: \"cli.version\",\n  SDK_VERSION: \"sdk.version\",\n  SDK_LANGUAGE: \"sdk.language\",\n  RETRY_AT: \"retry.at\",\n  RETRY_DELAY: \"retry.delay\",\n  RETRY_COUNT: \"retry.count\",\n  LINK_TITLE: \"$link.title\",\n  IDEMPOTENCY_KEY: \"ctx.run.idempotencyKey\",\n  USAGE_DURATION_MS: \"$usage.durationMs\",\n  USAGE_COST_IN_CENTS: \"$usage.costInCents\",\n  RATE_LIMIT_LIMIT: \"response.rateLimit.limit\",\n  RATE_LIMIT_REMAINING: \"response.rateLimit.remaining\",\n  RATE_LIMIT_RESET: \"response.rateLimit.reset\",\n};\n", "import { Attributes } from \"@opentelemetry/api\";\nimport { BackgroundWorkerProperties, TaskRunContext } from \"../schemas\";\nimport { getGlobal, registerGlobal, unregisterGlobal } from \"../utils/globals\";\nimport { TaskContext } from \"./types\";\nimport { SemanticInternalAttributes } from \"../semanticInternalAttributes\";\n\nconst API_NAME = \"task-context\";\n\nexport class TaskContextAPI {\n  private static _instance?: TaskContextAPI;\n\n  private constructor() {}\n\n  public static getInstance(): TaskContextAPI {\n    if (!this._instance) {\n      this._instance = new TaskContextAPI();\n    }\n\n    return this._instance;\n  }\n\n  get isInsideTask(): boolean {\n    return this.#getTaskContext() !== undefined;\n  }\n\n  get ctx(): TaskRunContext | undefined {\n    return this.#getTaskContext()?.ctx;\n  }\n\n  get worker(): BackgroundWorkerProperties | undefined {\n    return this.#getTaskContext()?.worker;\n  }\n\n  get attributes(): Attributes {\n    if (this.ctx) {\n      return {\n        ...this.contextAttributes,\n        ...this.workerAttributes,\n      };\n    }\n\n    return {};\n  }\n\n  get workerAttributes(): Attributes {\n    if (this.worker) {\n      return {\n        [SemanticInternalAttributes.WORKER_ID]: this.worker.id,\n        [SemanticInternalAttributes.WORKER_VERSION]: this.worker.version,\n      };\n    }\n\n    return {};\n  }\n\n  get contextAttributes(): Attributes {\n    if (this.ctx) {\n      return {\n        [SemanticInternalAttributes.ATTEMPT_ID]: this.ctx.attempt.id,\n        [SemanticInternalAttributes.ATTEMPT_NUMBER]: this.ctx.attempt.number,\n        [SemanticInternalAttributes.TASK_SLUG]: this.ctx.task.id,\n        [SemanticInternalAttributes.TASK_PATH]: this.ctx.task.filePath,\n        [SemanticInternalAttributes.TASK_EXPORT_NAME]: this.ctx.task.exportName,\n        [SemanticInternalAttributes.QUEUE_NAME]: this.ctx.queue.name,\n        [SemanticInternalAttributes.QUEUE_ID]: this.ctx.queue.id,\n        [SemanticInternalAttributes.ENVIRONMENT_ID]: this.ctx.environment.id,\n        [SemanticInternalAttributes.ENVIRONMENT_TYPE]: this.ctx.environment.type,\n        [SemanticInternalAttributes.ORGANIZATION_ID]: this.ctx.organization.id,\n        [SemanticInternalAttributes.PROJECT_ID]: this.ctx.project.id,\n        [SemanticInternalAttributes.PROJECT_REF]: this.ctx.project.ref,\n        [SemanticInternalAttributes.PROJECT_NAME]: this.ctx.project.name,\n        [SemanticInternalAttributes.RUN_ID]: this.ctx.run.id,\n        [SemanticInternalAttributes.RUN_IS_TEST]: this.ctx.run.isTest,\n        [SemanticInternalAttributes.ORGANIZATION_SLUG]: this.ctx.organization.slug,\n        [SemanticInternalAttributes.ORGANIZATION_NAME]: this.ctx.organization.name,\n        [SemanticInternalAttributes.BATCH_ID]: this.ctx.batch?.id,\n        [SemanticInternalAttributes.IDEMPOTENCY_KEY]: this.ctx.run.idempotencyKey,\n        [SemanticInternalAttributes.MACHINE_PRESET_NAME]: this.ctx.machine?.name,\n        [SemanticInternalAttributes.MACHINE_PRESET_CPU]: this.ctx.machine?.cpu,\n        [SemanticInternalAttributes.MACHINE_PRESET_MEMORY]: this.ctx.machine?.memory,\n        [SemanticInternalAttributes.MACHINE_PRESET_CENTS_PER_MS]: this.ctx.machine?.centsPerMs,\n      };\n    }\n\n    return {};\n  }\n\n  public disable() {\n    unregisterGlobal(API_NAME);\n  }\n\n  public setGlobalTaskContext(taskContext: TaskContext): boolean {\n    return registerGlobal(API_NAME, taskContext);\n  }\n\n  #getTaskContext(): TaskContext | undefined {\n    return getGlobal(API_NAME);\n  }\n}\n", "// Split module-level variable definition into separate files to allow\n// tree-shaking on each api instance.\nimport { TaskContextAPI } from \"./taskContext\";\n/** Entrypoint for logger API */\nexport const taskContext = TaskContextAPI.getInstance();\n", "import { z } from \"zod\";\nimport { fromZodError } from \"zod-validation-error\";\nimport { RetryOptions } from \"../schemas\";\nimport { calculateNextRetryDelay } from \"../utils/retries\";\nimport { ApiConnectionError, ApiError } from \"./errors\";\n\nimport { Attributes, Span } from \"@opentelemetry/api\";\nimport { SemanticInternalAttributes } from \"../semanticInternalAttributes\";\nimport { TriggerTracer } from \"../tracer\";\nimport { accessoryAttributes } from \"../utils/styleAttributes\";\nimport {\n  CursorPage,\n  CursorPageParams,\n  CursorPageResponse,\n  OffsetLimitPage,\n  OffsetLimitPageParams,\n  OffsetLimitPageResponse,\n} from \"./pagination\";\n\nexport const defaultRetryOptions = {\n  maxAttempts: 3,\n  factor: 2,\n  minTimeoutInMs: 1000,\n  maxTimeoutInMs: 60000,\n  randomize: false,\n} satisfies RetryOptions;\n\nexport type ZodFetchOptions = {\n  retry?: RetryOptions;\n  tracer?: TriggerTracer;\n  name?: string;\n  attributes?: Attributes;\n  icon?: string;\n  onResponseBody?: (body: unknown, span: Span) => void;\n};\n\nexport type ApiRequestOptions = Pick<ZodFetchOptions, \"retry\">;\ntype KeysEnum<T> = { [P in keyof Required<T>]: true };\n\n// This is required so that we can determine if a given object matches the ApiRequestOptions\n// type at runtime. While this requires duplication, it is enforced by the TypeScript\n// compiler such that any missing / extraneous keys will cause an error.\nconst requestOptionsKeys: KeysEnum<ApiRequestOptions> = {\n  retry: true,\n};\n\nexport const isRequestOptions = (obj: unknown): obj is ApiRequestOptions => {\n  return (\n    typeof obj === \"object\" &&\n    obj !== null &&\n    !isEmptyObj(obj) &&\n    Object.keys(obj).every((k) => hasOwn(requestOptionsKeys, k))\n  );\n};\n\ninterface FetchCursorPageParams extends CursorPageParams {\n  query?: URLSearchParams;\n}\n\ninterface FetchOffsetLimitPageParams extends OffsetLimitPageParams {\n  query?: URLSearchParams;\n}\n\nexport function zodfetch<TResponseBodySchema extends z.ZodTypeAny>(\n  schema: TResponseBodySchema,\n  url: string,\n  requestInit?: RequestInit,\n  options?: ZodFetchOptions\n): ApiPromise<z.output<TResponseBodySchema>> {\n  return new ApiPromise(_doZodFetch(schema, url, requestInit, options));\n}\n\nexport function zodfetchCursorPage<TItemSchema extends z.ZodTypeAny>(\n  schema: TItemSchema,\n  url: string,\n  params: FetchCursorPageParams,\n  requestInit?: RequestInit,\n  options?: ZodFetchOptions\n) {\n  const query = new URLSearchParams(params.query);\n\n  if (params.limit) {\n    query.set(\"page[size]\", String(params.limit));\n  }\n\n  if (params.after) {\n    query.set(\"page[after]\", params.after);\n  }\n\n  if (params.before) {\n    query.set(\"page[before]\", params.before);\n  }\n\n  const cursorPageSchema = z.object({\n    data: z.array(schema),\n    pagination: z.object({\n      next: z.string().optional(),\n      previous: z.string().optional(),\n    }),\n  });\n\n  const $url = new URL(url);\n  $url.search = query.toString();\n\n  const fetchResult = _doZodFetch(cursorPageSchema, $url.href, requestInit, options);\n\n  return new CursorPagePromise(fetchResult, schema, url, params, requestInit, options);\n}\n\nexport function zodfetchOffsetLimitPage<TItemSchema extends z.ZodTypeAny>(\n  schema: TItemSchema,\n  url: string,\n  params: FetchOffsetLimitPageParams,\n  requestInit?: RequestInit,\n  options?: ZodFetchOptions\n) {\n  const query = new URLSearchParams(params.query);\n\n  if (params.limit) {\n    query.set(\"perPage\", String(params.limit));\n  }\n\n  if (params.page) {\n    query.set(\"page\", String(params.page));\n  }\n\n  const offsetLimitPageSchema = z.object({\n    data: z.array(schema),\n    pagination: z.object({\n      currentPage: z.coerce.number(),\n      totalPages: z.coerce.number(),\n      count: z.coerce.number(),\n    }),\n  });\n\n  const $url = new URL(url);\n  $url.search = query.toString();\n\n  const fetchResult = _doZodFetch(offsetLimitPageSchema, $url.href, requestInit, options);\n\n  return new OffsetLimitPagePromise(fetchResult, schema, url, params, requestInit, options);\n}\n\ntype ZodFetchResult<T> = {\n  data: T;\n  response: Response;\n};\n\ntype PromiseOrValue<T> = T | Promise<T>;\n\nasync function traceZodFetch<T>(\n  params: {\n    url: string;\n    requestInit?: RequestInit;\n    options?: ZodFetchOptions;\n  },\n  callback: (span?: Span) => Promise<T>\n): Promise<T> {\n  if (!params.options?.tracer) {\n    return callback();\n  }\n\n  const url = new URL(params.url);\n  const method = params.requestInit?.method ?? \"GET\";\n  const name = params.options.name ?? `${method} ${url.pathname}`;\n\n  return await params.options.tracer.startActiveSpan(\n    name,\n    async (span) => {\n      return await callback(span);\n    },\n    {\n      attributes: {\n        [SemanticInternalAttributes.STYLE_ICON]: params.options?.icon ?? \"api\",\n        ...params.options.attributes,\n      },\n    }\n  );\n}\n\nasync function _doZodFetch<TResponseBodySchema extends z.ZodTypeAny>(\n  schema: TResponseBodySchema,\n  url: string,\n  requestInit?: PromiseOrValue<RequestInit>,\n  options?: ZodFetchOptions\n): Promise<ZodFetchResult<z.output<TResponseBodySchema>>> {\n  const $requestInit = await requestInit;\n\n  return traceZodFetch({ url, requestInit: $requestInit, options }, async (span) => {\n    const result = await _doZodFetchWithRetries(schema, url, $requestInit, options);\n\n    if (options?.onResponseBody && span) {\n      options.onResponseBody(result.data, span);\n    }\n\n    return result;\n  });\n}\n\nasync function _doZodFetchWithRetries<TResponseBodySchema extends z.ZodTypeAny>(\n  schema: TResponseBodySchema,\n  url: string,\n  requestInit?: RequestInit,\n  options?: ZodFetchOptions,\n  attempt = 1\n): Promise<ZodFetchResult<z.output<TResponseBodySchema>>> {\n  try {\n    const response = await fetch(url, requestInitWithCache(requestInit));\n\n    const responseHeaders = createResponseHeaders(response.headers);\n\n    if (!response.ok) {\n      const retryResult = shouldRetry(response, attempt, options?.retry);\n\n      if (retryResult.retry) {\n        await waitForRetry(url, attempt + 1, retryResult.delay, options, requestInit, response);\n\n        return await _doZodFetchWithRetries(schema, url, requestInit, options, attempt + 1);\n      } else {\n        const errText = await response.text().catch((e) => castToError(e).message);\n        const errJSON = safeJsonParse(errText);\n        const errMessage = errJSON ? undefined : errText;\n\n        throw ApiError.generate(response.status, errJSON, errMessage, responseHeaders);\n      }\n    }\n\n    const jsonBody = await response.json();\n    const parsedResult = schema.safeParse(jsonBody);\n\n    if (parsedResult.success) {\n      return { data: parsedResult.data, response };\n    }\n\n    throw fromZodError(parsedResult.error);\n  } catch (error) {\n    if (error instanceof ApiError) {\n      throw error;\n    }\n\n    if (options?.retry) {\n      const retry = { ...defaultRetryOptions, ...options.retry };\n\n      const delay = calculateNextRetryDelay(retry, attempt);\n\n      if (delay) {\n        await waitForRetry(url, attempt + 1, delay, options, requestInit);\n\n        return await _doZodFetchWithRetries(schema, url, requestInit, options, attempt + 1);\n      }\n    }\n\n    throw new ApiConnectionError({ cause: castToError(error) });\n  }\n}\n\nfunction castToError(err: any): Error {\n  if (err instanceof Error) return err;\n  return new Error(err);\n}\n\ntype ShouldRetryResult =\n  | {\n      retry: false;\n    }\n  | {\n      retry: true;\n      delay: number;\n    };\n\nfunction shouldRetry(\n  response: Response,\n  attempt: number,\n  retryOptions?: RetryOptions\n): ShouldRetryResult {\n  function shouldRetryForOptions(): ShouldRetryResult {\n    const retry = { ...defaultRetryOptions, ...retryOptions };\n\n    const delay = calculateNextRetryDelay(retry, attempt);\n\n    if (delay) {\n      return { retry: true, delay };\n    } else {\n      return { retry: false };\n    }\n  }\n\n  // Note this is not a standard header.\n  const shouldRetryHeader = response.headers.get(\"x-should-retry\");\n\n  // If the server explicitly says whether or not to retry, obey.\n  if (shouldRetryHeader === \"true\") return shouldRetryForOptions();\n  if (shouldRetryHeader === \"false\") return { retry: false };\n\n  // Retry on request timeouts.\n  if (response.status === 408) return shouldRetryForOptions();\n\n  // Retry on lock timeouts.\n  if (response.status === 409) return shouldRetryForOptions();\n\n  // Retry on rate limits.\n  if (response.status === 429) {\n    if (\n      attempt >= (typeof retryOptions?.maxAttempts === \"number\" ? retryOptions?.maxAttempts : 3)\n    ) {\n      return { retry: false };\n    }\n\n    // x-ratelimit-reset is the unix timestamp in milliseconds when the rate limit will reset.\n    const resetAtUnixEpochMs = response.headers.get(\"x-ratelimit-reset\");\n\n    if (resetAtUnixEpochMs) {\n      const resetAtUnixEpoch = parseInt(resetAtUnixEpochMs, 10);\n      const delay = resetAtUnixEpoch - Date.now() + Math.floor(Math.random() * 1000);\n\n      if (delay > 0) {\n        return { retry: true, delay };\n      }\n    }\n\n    return shouldRetryForOptions();\n  }\n\n  // Retry internal errors.\n  if (response.status >= 500) return shouldRetryForOptions();\n\n  return { retry: false };\n}\n\nfunction safeJsonParse(text: string): any {\n  try {\n    return JSON.parse(text);\n  } catch (e) {\n    return undefined;\n  }\n}\n\nfunction createResponseHeaders(headers: Response[\"headers\"]): Record<string, string> {\n  return new Proxy(\n    Object.fromEntries(\n      // @ts-ignore\n      headers.entries()\n    ),\n    {\n      get(target, name) {\n        const key = name.toString();\n        return target[key.toLowerCase()] || target[key];\n      },\n    }\n  );\n}\n\nfunction requestInitWithCache(requestInit?: RequestInit): RequestInit {\n  try {\n    const withCache: RequestInit = {\n      ...requestInit,\n      cache: \"no-cache\",\n    };\n\n    const _ = new Request(\"http://localhost\", withCache);\n\n    return withCache;\n  } catch (error) {\n    return requestInit ?? {};\n  }\n}\n\n/**\n * A subclass of `Promise` providing additional helper methods\n * for interacting with the SDK.\n */\nexport class ApiPromise<T> extends Promise<T> {\n  constructor(private responsePromise: Promise<ZodFetchResult<T>>) {\n    super((resolve) => {\n      // this is maybe a bit weird but this has to be a no-op to not implicitly\n      // parse the response body; instead .then, .catch, .finally are overridden\n      // to parse the response\n      resolve(null as any);\n    });\n  }\n\n  /**\n   * Gets the raw `Response` instance instead of parsing the response\n   * data.\n   *\n   * If you want to parse the response body but still get the `Response`\n   * instance, you can use {@link withResponse()}.\n   */\n  asResponse(): Promise<Response> {\n    return this.responsePromise.then((p) => p.response);\n  }\n\n  /**\n   * Gets the parsed response data and the raw `Response` instance.\n   *\n   * If you just want to get the raw `Response` instance without parsing it,\n   * you can use {@link asResponse()}.\n   */\n  async withResponse(): Promise<{ data: T; response: Response }> {\n    const [data, response] = await Promise.all([this.parse(), this.asResponse()]);\n    return { data, response };\n  }\n\n  private parse(): Promise<T> {\n    return this.responsePromise.then((result) => result.data);\n  }\n\n  override then<TResult1 = T, TResult2 = never>(\n    onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,\n    onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null\n  ): Promise<TResult1 | TResult2> {\n    return this.parse().then(onfulfilled, onrejected);\n  }\n\n  override catch<TResult = never>(\n    onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null\n  ): Promise<T | TResult> {\n    return this.parse().catch(onrejected);\n  }\n\n  override finally(onfinally?: (() => void) | undefined | null): Promise<T> {\n    return this.parse().finally(onfinally);\n  }\n}\n\nexport class CursorPagePromise<TItemSchema extends z.ZodTypeAny>\n  extends ApiPromise<CursorPage<z.output<TItemSchema>>>\n  implements AsyncIterable<z.output<TItemSchema>>\n{\n  constructor(\n    result: Promise<ZodFetchResult<CursorPageResponse<z.output<TItemSchema>>>>,\n    private schema: TItemSchema,\n    private url: string,\n    private params: FetchCursorPageParams,\n    private requestInit?: RequestInit,\n    private options?: ZodFetchOptions\n  ) {\n    super(\n      result.then((result) => ({\n        data: new CursorPage(result.data.data, result.data.pagination, this.#fetchPage.bind(this)),\n        response: result.response,\n      }))\n    );\n  }\n\n  #fetchPage(params: Omit<CursorPageParams, \"limit\">): Promise<CursorPage<z.output<TItemSchema>>> {\n    return zodfetchCursorPage(\n      this.schema,\n      this.url,\n      { ...this.params, ...params },\n      this.requestInit,\n      this.options\n    );\n  }\n\n  /**\n   * Allow auto-paginating iteration on an unawaited list call, eg:\n   *\n   *    for await (const item of client.items.list()) {\n   *      console.log(item)\n   *    }\n   */\n  async *[Symbol.asyncIterator]() {\n    const page = await this;\n    for await (const item of page) {\n      yield item;\n    }\n  }\n}\n\nexport class OffsetLimitPagePromise<TItemSchema extends z.ZodTypeAny>\n  extends ApiPromise<OffsetLimitPage<z.output<TItemSchema>>>\n  implements AsyncIterable<z.output<TItemSchema>>\n{\n  constructor(\n    result: Promise<ZodFetchResult<OffsetLimitPageResponse<z.output<TItemSchema>>>>,\n    private schema: TItemSchema,\n    private url: string,\n    private params: FetchOffsetLimitPageParams,\n    private requestInit?: RequestInit,\n    private options?: ZodFetchOptions\n  ) {\n    super(\n      result.then((result) => ({\n        data: new OffsetLimitPage(\n          result.data.data,\n          result.data.pagination,\n          this.#fetchPage.bind(this)\n        ),\n        response: result.response,\n      }))\n    );\n  }\n\n  #fetchPage(\n    params: Omit<FetchOffsetLimitPageParams, \"limit\">\n  ): Promise<OffsetLimitPage<z.output<TItemSchema>>> {\n    return zodfetchOffsetLimitPage(\n      this.schema,\n      this.url,\n      { ...this.params, ...params },\n      this.requestInit,\n      this.options\n    );\n  }\n\n  /**\n   * Allow auto-paginating iteration on an unawaited list call, eg:\n   *\n   *    for await (const item of client.items.list()) {\n   *      console.log(item)\n   *    }\n   */\n  async *[Symbol.asyncIterator]() {\n    const page = await this;\n    for await (const item of page) {\n      yield item;\n    }\n  }\n}\n\nasync function waitForRetry(\n  url: string,\n  attempt: number,\n  delay: number,\n  options?: ZodFetchOptions,\n  requestInit?: RequestInit,\n  response?: Response\n): Promise<void> {\n  if (options?.tracer) {\n    const method = requestInit?.method ?? \"GET\";\n\n    return options.tracer.startActiveSpan(\n      response ? `wait after ${response.status}` : `wait after error`,\n      async (span) => {\n        await new Promise((resolve) => setTimeout(resolve, delay));\n      },\n      {\n        attributes: {\n          [SemanticInternalAttributes.STYLE_ICON]: \"wait\",\n          ...accessoryAttributes({\n            items: [\n              {\n                text: `retrying ${options?.name ?? method.toUpperCase()} in ${delay}ms`,\n                variant: \"normal\",\n              },\n            ],\n            style: \"codepath\",\n          }),\n        },\n      }\n    );\n  }\n\n  await new Promise((resolve) => setTimeout(resolve, delay));\n}\n\n// https://stackoverflow.com/a/34491287\nexport function isEmptyObj(obj: Object | null | undefined): boolean {\n  if (!obj) return true;\n  for (const _k in obj) return false;\n  return true;\n}\n\n// https://eslint.org/docs/latest/rules/no-prototype-builtins\nexport function hasOwn(obj: Object, key: string): boolean {\n  return Object.prototype.hasOwnProperty.call(obj, key);\n}\n", "import { RetryOptions } from \"./schemas\";\n\nconst DEFAULT_RETRY_OPTIONS = {\n  limit: 5,\n  factor: 1.8,\n  minTimeoutInMs: 1000,\n  maxTimeoutInMs: 60000,\n  randomize: true,\n} satisfies RetryOptions;\n\nexport function calculateRetryAt(retryOptions: RetryOptions, attempts: number): Date | undefined {\n  const options = {\n    ...DEFAULT_RETRY_OPTIONS,\n    ...retryOptions,\n  };\n\n  const retryCount = attempts + 1;\n\n  if (retryCount >= options.limit) {\n    return;\n  }\n\n  const random = options.randomize ? Math.random() + 1 : 1;\n\n  let timeoutInMs = Math.round(\n    random *\n      Math.max(options.minTimeoutInMs, 1) *\n      Math.pow(options.factor, Math.max(attempts - 1, 0))\n  );\n\n  timeoutInMs = Math.min(timeoutInMs, options.maxTimeoutInMs);\n\n  return new Date(Date.now() + timeoutInMs);\n}\n\nexport function calculateResetAt(\n  resets: string | undefined | null,\n  format:\n    | \"unix_timestamp\"\n    | \"iso_8601\"\n    | \"iso_8601_duration_openai_variant\"\n    | \"unix_timestamp_in_ms\",\n  now: Date = new Date()\n): Date | undefined {\n  if (!resets) return;\n\n  switch (format) {\n    case \"iso_8601_duration_openai_variant\": {\n      return calculateISO8601DurationOpenAIVariantResetAt(resets, now);\n    }\n    case \"iso_8601\": {\n      return calculateISO8601ResetAt(resets, now);\n    }\n    case \"unix_timestamp\": {\n      return calculateUnixTimestampResetAt(resets, now);\n    }\n    case \"unix_timestamp_in_ms\": {\n      return calculateUnixTimestampInMsResetAt(resets, now);\n    }\n  }\n}\n\nfunction calculateUnixTimestampResetAt(resets: string, now: Date = new Date()): Date | undefined {\n  // Check if the input is null or undefined\n  if (!resets) return undefined;\n\n  // Convert the string to a number\n  const resetAt = parseInt(resets, 10);\n\n  // If the string doesn't match the expected format, return undefined\n  if (isNaN(resetAt)) return undefined;\n\n  // Return the date\n  return new Date(resetAt * 1000);\n}\n\nfunction calculateUnixTimestampInMsResetAt(\n  resets: string,\n  now: Date = new Date()\n): Date | undefined {\n  // Check if the input is null or undefined\n  if (!resets) return undefined;\n\n  // Convert the string to a number\n  const resetAt = parseInt(resets, 10);\n\n  // If the string doesn't match the expected format, return undefined\n  if (isNaN(resetAt)) return undefined;\n\n  // Return the date\n  return new Date(resetAt);\n}\n\nfunction calculateISO8601ResetAt(resets: string, now: Date = new Date()): Date | undefined {\n  // Check if the input is null or undefined\n  if (!resets) return undefined;\n\n  // Parse the date\n  const resetAt = new Date(resets);\n\n  // If the string doesn't match the expected format, return undefined\n  if (isNaN(resetAt.getTime())) return undefined;\n\n  return resetAt;\n}\n\nfunction calculateISO8601DurationOpenAIVariantResetAt(\n  resets: string,\n  now: Date = new Date()\n): Date | undefined {\n  // Check if the input is null or undefined\n  if (!resets) return undefined;\n\n  // Regular expression to match the duration string pattern\n  const pattern = /^(?:(\\d+)d)?(?:(\\d+)h)?(?:(\\d+)m)?(?:(\\d+(?:\\.\\d+)?)s)?(?:(\\d+)ms)?$/;\n  const match = resets.match(pattern);\n\n  // If the string doesn't match the expected format, return undefined\n  if (!match) return undefined;\n\n  // Extract days, hours, minutes, seconds, and milliseconds from the string\n  const days = parseInt(match[1], 10) || 0;\n  const hours = parseInt(match[2], 10) || 0;\n  const minutes = parseInt(match[3], 10) || 0;\n  const seconds = parseFloat(match[4]) || 0;\n  const milliseconds = parseInt(match[5], 10) || 0;\n\n  // Calculate the future date based on the current date plus the extracted time\n  const resetAt = new Date(now);\n  resetAt.setDate(resetAt.getDate() + days);\n  resetAt.setHours(resetAt.getHours() + hours);\n  resetAt.setMinutes(resetAt.getMinutes() + minutes);\n  resetAt.setSeconds(resetAt.getSeconds() + Math.floor(seconds));\n  resetAt.setMilliseconds(\n    resetAt.getMilliseconds() + (seconds - Math.floor(seconds)) * 1000 + milliseconds\n  );\n\n  return resetAt;\n}\n", "import { calculateResetAt as calculateResetAtInternal } from \"../../retry\";\nimport { FetchRetryOptions, type RetryOptions } from \"../schemas\";\n\nexport const defaultRetryOptions = {\n  maxAttempts: 3,\n  factor: 2,\n  minTimeoutInMs: 1000,\n  maxTimeoutInMs: 60000,\n  randomize: true,\n} satisfies RetryOptions;\n\nexport const defaultFetchRetryOptions = {\n  byStatus: {\n    \"429,408,409,5xx\": {\n      strategy: \"backoff\",\n      ...defaultRetryOptions,\n    },\n  },\n  connectionError: defaultRetryOptions,\n  timeout: defaultRetryOptions,\n} satisfies FetchRetryOptions;\n\n/**\n *\n * @param options\n * @param attempt - The current attempt number. If the first attempt has failed, this will be 1.\n * @returns\n */\nexport function calculateNextRetryDelay(options: RetryOptions, attempt: number) {\n  const opts = { ...defaultRetryOptions, ...options };\n\n  if (attempt >= opts.maxAttempts) {\n    return;\n  }\n\n  const { factor, minTimeoutInMs, maxTimeoutInMs, randomize } = opts;\n\n  const random = randomize ? Math.random() + 1 : 1;\n\n  const timeout = Math.min(maxTimeoutInMs, random * minTimeoutInMs * Math.pow(factor, attempt - 1));\n\n  // Round to the nearest integer\n  return Math.round(timeout);\n}\n\nexport function calculateResetAt(\n  resets: string | undefined | null,\n  format:\n    | \"unix_timestamp\"\n    | \"iso_8601\"\n    | \"iso_8601_duration_openai_variant\"\n    | \"unix_timestamp_in_ms\",\n  now: number = Date.now()\n): number | undefined {\n  const resetAt = calculateResetAtInternal(resets, format, new Date(now));\n\n  return resetAt?.getTime();\n}\n", "export type APIHeaders = Record<string, string | null | undefined>;\n\nexport class ApiError extends Error {\n  readonly status: number | undefined;\n  readonly headers: APIHeaders | undefined;\n  readonly error: Object | undefined;\n\n  readonly code: string | null | undefined;\n  readonly param: string | null | undefined;\n  readonly type: string | undefined;\n\n  constructor(\n    status: number | undefined,\n    error: Object | undefined,\n    message: string | undefined,\n    headers: APIHeaders | undefined\n  ) {\n    super(`${ApiError.makeMessage(status, error, message)}`);\n    this.name = \"TriggerApiError\";\n    this.status = status;\n    this.headers = headers;\n\n    const data = error as Record<string, any>;\n    this.error = data;\n    this.code = data?.[\"code\"];\n    this.param = data?.[\"param\"];\n    this.type = data?.[\"type\"];\n  }\n\n  private static makeMessage(status: number | undefined, error: any, message: string | undefined) {\n    const msg = error?.message\n      ? typeof error.message === \"string\"\n        ? error.message\n        : JSON.stringify(error.message)\n      : error\n      ? JSON.stringify(error)\n      : message;\n\n    if (status && msg) {\n      return `${status} ${msg}`;\n    }\n    if (status) {\n      return `${status} status code (no body)`;\n    }\n    if (msg) {\n      return msg;\n    }\n    return \"(no status code or body)\";\n  }\n\n  static generate(\n    status: number | undefined,\n    errorResponse: Object | undefined,\n    message: string | undefined,\n    headers: APIHeaders | undefined\n  ) {\n    if (!status) {\n      return new ApiConnectionError({ cause: castToError(errorResponse) });\n    }\n\n    const error = (errorResponse as Record<string, any>)?.[\"error\"];\n\n    if (status === 400) {\n      return new BadRequestError(status, error, message, headers);\n    }\n\n    if (status === 401) {\n      return new AuthenticationError(status, error, message, headers);\n    }\n\n    if (status === 403) {\n      return new PermissionDeniedError(status, error, message, headers);\n    }\n\n    if (status === 404) {\n      return new NotFoundError(status, error, message, headers);\n    }\n\n    if (status === 409) {\n      return new ConflictError(status, error, message, headers);\n    }\n\n    if (status === 422) {\n      return new UnprocessableEntityError(status, error, message, headers);\n    }\n\n    if (status === 429) {\n      return new RateLimitError(status, error, message, headers);\n    }\n\n    if (status >= 500) {\n      return new InternalServerError(status, error, message, headers);\n    }\n\n    return new ApiError(status, error, message, headers);\n  }\n}\n\nexport class ApiConnectionError extends ApiError {\n  override readonly status: undefined = undefined;\n\n  constructor({ message, cause }: { message?: string; cause?: Error | undefined }) {\n    super(undefined, undefined, message || \"Connection error.\", undefined);\n    // in some environments the 'cause' property is already declared\n    // @ts-ignore\n    if (cause) this.cause = cause;\n  }\n}\n\nexport class BadRequestError extends ApiError {\n  override readonly status: 400 = 400;\n}\n\nexport class AuthenticationError extends ApiError {\n  override readonly status: 401 = 401;\n}\n\nexport class PermissionDeniedError extends ApiError {\n  override readonly status: 403 = 403;\n}\n\nexport class NotFoundError extends ApiError {\n  override readonly status: 404 = 404;\n}\n\nexport class ConflictError extends ApiError {\n  override readonly status: 409 = 409;\n}\n\nexport class UnprocessableEntityError extends ApiError {\n  override readonly status: 422 = 422;\n}\n\nexport class RateLimitError extends ApiError {\n  override readonly status: 429 = 429;\n\n  get millisecondsUntilReset(): number | undefined {\n    // x-ratelimit-reset is the unix timestamp in milliseconds when the rate limit will reset.\n    const resetAtUnixEpochMs = (this.headers ?? {})[\"x-ratelimit-reset\"];\n\n    if (typeof resetAtUnixEpochMs === \"string\") {\n      const resetAtUnixEpoch = parseInt(resetAtUnixEpochMs, 10);\n\n      if (isNaN(resetAtUnixEpoch)) {\n        return;\n      }\n\n      // Add between 0 and 2000ms to the reset time to add jitter\n      return Math.max(resetAtUnixEpoch - Date.now() + Math.floor(Math.random() * 2000), 0);\n    }\n  }\n}\n\nexport class InternalServerError extends ApiError {}\n\nfunction castToError(err: any): Error {\n  if (err instanceof Error) return err;\n  return new Error(err);\n}\n", "import { Attributes } from \"@opentelemetry/api\";\n\nexport const NULL_SENTINEL = \"$@null((\";\n\nexport function flattenAttributes(\n  obj: Record<string, unknown> | Array<unknown> | string | boolean | number | null | undefined,\n  prefix?: string\n): Attributes {\n  const result: Attributes = {};\n\n  // Check if obj is null or undefined\n  if (obj === undefined) {\n    return result;\n  }\n\n  if (obj === null) {\n    result[prefix || \"\"] = NULL_SENTINEL;\n    return result;\n  }\n\n  if (typeof obj === \"string\") {\n    result[prefix || \"\"] = obj;\n    return result;\n  }\n\n  if (typeof obj === \"number\") {\n    result[prefix || \"\"] = obj;\n    return result;\n  }\n\n  if (typeof obj === \"boolean\") {\n    result[prefix || \"\"] = obj;\n    return result;\n  }\n\n  for (const [key, value] of Object.entries(obj)) {\n    const newPrefix = `${prefix ? `${prefix}.` : \"\"}${Array.isArray(obj) ? `[${key}]` : key}`;\n    if (Array.isArray(value)) {\n      for (let i = 0; i < value.length; i++) {\n        if (typeof value[i] === \"object\" && value[i] !== null) {\n          // update null check here as well\n          Object.assign(result, flattenAttributes(value[i], `${newPrefix}.[${i}]`));\n        } else {\n          if (value[i] === null) {\n            result[`${newPrefix}.[${i}]`] = NULL_SENTINEL;\n          } else {\n            result[`${newPrefix}.[${i}]`] = value[i];\n          }\n        }\n      }\n    } else if (isRecord(value)) {\n      // update null check here\n      Object.assign(result, flattenAttributes(value, newPrefix));\n    } else {\n      if (typeof value === \"number\" || typeof value === \"string\" || typeof value === \"boolean\") {\n        result[newPrefix] = value;\n      } else if (value === null) {\n        result[newPrefix] = NULL_SENTINEL;\n      }\n    }\n  }\n\n  return result;\n}\n\nfunction isRecord(value: unknown): value is Record<string, unknown> {\n  return value !== null && typeof value === \"object\" && !Array.isArray(value);\n}\n\nexport function unflattenAttributes(\n  obj: Attributes\n): Record<string, unknown> | string | number | boolean | null | undefined {\n  if (typeof obj !== \"object\" || obj === null || Array.isArray(obj)) {\n    return obj;\n  }\n\n  if (\n    typeof obj === \"object\" &&\n    obj !== null &&\n    Object.keys(obj).length === 1 &&\n    Object.keys(obj)[0] === \"\"\n  ) {\n    return rehydrateNull(obj[\"\"]) as any;\n  }\n\n  if (Object.keys(obj).length === 0) {\n    return;\n  }\n\n  const result: Record<string, unknown> = {};\n\n  for (const [key, value] of Object.entries(obj)) {\n    const parts = key.split(\".\").reduce((acc, part) => {\n      if (part.includes(\"[\")) {\n        // Handling nested array indices\n        const subparts = part.split(/\\[|\\]/).filter((p) => p !== \"\");\n        acc.push(...subparts);\n      } else {\n        acc.push(part);\n      }\n      return acc;\n    }, [] as string[]);\n\n    let current: any = result;\n    for (let i = 0; i < parts.length - 1; i++) {\n      const part = parts[i];\n      const nextPart = parts[i + 1];\n      const isArray = /^\\d+$/.test(nextPart);\n      if (isArray && !Array.isArray(current[part])) {\n        current[part] = [];\n      } else if (!isArray && current[part] === undefined) {\n        current[part] = {};\n      }\n      current = current[part];\n    }\n    const lastPart = parts[parts.length - 1];\n    current[lastPart] = rehydrateNull(value);\n  }\n\n  // Convert the result to an array if all top-level keys are numeric indices\n  if (Object.keys(result).every((k) => /^\\d+$/.test(k))) {\n    const maxIndex = Math.max(...Object.keys(result).map((k) => parseInt(k)));\n    const arrayResult = Array(maxIndex + 1);\n    for (const key in result) {\n      arrayResult[parseInt(key)] = result[key];\n    }\n    return arrayResult as any;\n  }\n\n  return result;\n}\n\nexport function primitiveValueOrflattenedAttributes(\n  obj: Record<string, unknown> | Array<unknown> | string | boolean | number | undefined,\n  prefix: string | undefined\n): Attributes | string | number | boolean | undefined {\n  if (\n    typeof obj === \"string\" ||\n    typeof obj === \"number\" ||\n    typeof obj === \"boolean\" ||\n    obj === null ||\n    obj === undefined\n  ) {\n    return obj;\n  }\n\n  const attributes = flattenAttributes(obj, prefix);\n\n  if (\n    prefix !== undefined &&\n    typeof attributes[prefix] !== \"undefined\" &&\n    attributes[prefix] !== null\n  ) {\n    return attributes[prefix] as unknown as Attributes;\n  }\n\n  return attributes;\n}\n\nfunction rehydrateNull(value: any): any {\n  if (value === NULL_SENTINEL) {\n    return null;\n  }\n\n  return value;\n}\n", "import { Attributes } from \"@opentelemetry/api\";\nimport { Accessory } from \"../schemas\";\nimport { flattenAttributes } from \"./flattenAttributes\";\nimport { SemanticInternalAttributes } from \"../semanticInternalAttributes\";\n\nexport function accessoryAttributes(accessory: Accessory): Attributes {\n  return flattenAttributes(accessory, SemanticInternalAttributes.STYLE_ACCESSORY);\n}\n", "export interface CursorPageParams {\n  limit?: number;\n  after?: string;\n  before?: string;\n}\n\nexport interface OffsetLimitPageParams {\n  limit?: number;\n  page?: number;\n}\n\nexport interface PageResponse<Item> {\n  data: Array<Item>;\n}\n\nexport interface CursorPageResponse<Item> extends PageResponse<Item> {\n  pagination: {\n    next?: string;\n    previous?: string;\n  };\n}\n\nexport interface OffsetLimitPageResponse<Item> extends PageResponse<Item> {\n  pagination: {\n    currentPage: number;\n    totalPages: number;\n    count: number;\n  };\n}\n\nexport interface Page<Item> {\n  getPaginatedItems(): Item[];\n  hasNextPage(): boolean;\n  hasPreviousPage(): boolean;\n}\n\nexport class CursorPage<Item> implements CursorPageResponse<Item>, Page<Item>, AsyncIterable<Item> {\n  data: Array<Item>;\n  pagination: { next?: string; previous?: string };\n\n  constructor(\n    data: Array<Item>,\n    pagination: { next?: string; previous?: string },\n    private pageFetcher: (params: Omit<CursorPageParams, \"limit\">) => Promise<CursorPage<Item>>\n  ) {\n    this.data = data;\n    this.pagination = pagination;\n  }\n\n  getPaginatedItems(): Item[] {\n    return this.data ?? [];\n  }\n\n  hasNextPage(): boolean {\n    return !!this.pagination.next;\n  }\n\n  hasPreviousPage(): boolean {\n    return !!this.pagination.previous;\n  }\n\n  getNextPage(): Promise<CursorPage<Item>> {\n    if (!this.pagination.next) {\n      throw new Error(\"No next page available\");\n    }\n\n    return this.pageFetcher({ after: this.pagination.next });\n  }\n\n  getPreviousPage(): Promise<CursorPage<Item>> {\n    if (!this.pagination.previous) {\n      throw new Error(\"No previous page available\");\n    }\n\n    return this.pageFetcher({ before: this.pagination.previous });\n  }\n\n  async *iterPages() {\n    // eslint-disable-next-line @typescript-eslint/no-this-alias\n    let page: CursorPage<Item> = this;\n    yield page;\n    while (page.hasNextPage()) {\n      page = await page.getNextPage();\n      yield page;\n    }\n  }\n\n  async *[Symbol.asyncIterator]() {\n    for await (const page of this.iterPages()) {\n      for (const item of page.getPaginatedItems()) {\n        yield item;\n      }\n    }\n  }\n}\n\nexport class OffsetLimitPage<Item>\n  implements OffsetLimitPageResponse<Item>, Page<Item>, AsyncIterable<Item>\n{\n  data: Array<Item>;\n  pagination: { currentPage: number; totalPages: number; count: number };\n\n  constructor(\n    data: Array<Item>,\n    pagination: { currentPage: number; totalPages: number; count: number },\n    private pageFetcher: (\n      params: Omit<OffsetLimitPageParams, \"limit\">\n    ) => Promise<OffsetLimitPage<Item>>\n  ) {\n    this.data = data;\n    this.pagination = pagination;\n  }\n\n  getPaginatedItems(): Item[] {\n    return this.data ?? [];\n  }\n\n  hasNextPage(): boolean {\n    return this.pagination.currentPage < this.pagination.totalPages;\n  }\n\n  hasPreviousPage(): boolean {\n    return this.pagination.currentPage > 1;\n  }\n\n  getNextPage(): Promise<OffsetLimitPage<Item>> {\n    if (!this.hasNextPage()) {\n      throw new Error(\"No next page available\");\n    }\n\n    return this.pageFetcher({\n      page: this.pagination.currentPage + 1,\n    });\n  }\n\n  getPreviousPage(): Promise<OffsetLimitPage<Item>> {\n    if (!this.hasPreviousPage()) {\n      throw new Error(\"No previous page available\");\n    }\n\n    return this.pageFetcher({\n      page: this.pagination.currentPage - 1,\n    });\n  }\n\n  async *iterPages() {\n    // eslint-disable-next-line @typescript-eslint/no-this-alias\n    let page: OffsetLimitPage<Item> = this;\n    yield page;\n    while (page.hasNextPage()) {\n      page = await page.getNextPage();\n      yield page;\n    }\n  }\n\n  async *[Symbol.asyncIterator]() {\n    for await (const page of this.iterPages()) {\n      for (const item of page.getPaginatedItems()) {\n        yield item;\n      }\n    }\n  }\n}\n", "import { PreciseDate } from \"@google-cloud/precise-date\";\nimport { Clock } from \"./clock\";\n\nexport class SimpleClock implements Clock {\n  preciseNow(): [number, number] {\n    const now = new PreciseDate();\n    const nowStruct = now.toStruct();\n\n    return [nowStruct.seconds, nowStruct.nanos];\n  }\n\n  reset() {\n    // do nothing\n  }\n}\n", "const API_NAME = \"clock\";\n\nimport { getGlobal, registerGlobal } from \"../utils/globals\";\nimport type { Clock, ClockTime } from \"./clock\";\nimport { SimpleClock } from \"./simpleClock\";\n\nconst SIMPLE_CLOCK = new SimpleClock();\n\nexport class ClockAPI {\n  private static _instance?: ClockAPI;\n\n  private constructor() {}\n\n  public static getInstance(): ClockAPI {\n    if (!this._instance) {\n      this._instance = new ClockAPI();\n    }\n\n    return this._instance;\n  }\n\n  public setGlobalClock(clock: Clock): boolean {\n    return registerGlobal(API_NAME, clock);\n  }\n\n  public preciseNow(): ClockTime {\n    return this.#getClock().preciseNow();\n  }\n\n  public reset(): void {\n    this.#getClock().reset();\n  }\n\n  #getClock(): Clock {\n    return getGlobal(API_NAME) ?? SIMPLE_CLOCK;\n  }\n}\n", "// Split module-level variable definition into separate files to allow\n// tree-shaking on each api instance.\nimport { ClockAPI } from \"./clock\";\n/** Entrypoint for clock API */\nexport const clock = ClockAPI.getInstance();\n", "import { AttributeValue, Attributes } from \"@opentelemetry/api\";\n\nexport const OTEL_SPAN_ATTRIBUTE_COUNT_LIMIT = 256;\nexport const OTEL_LOG_ATTRIBUTE_COUNT_LIMIT = 256;\nexport const OTEL_SPAN_ATTRIBUTE_VALUE_LENGTH_LIMIT = 1028;\nexport const OTEL_LOG_ATTRIBUTE_VALUE_LENGTH_LIMIT = 1028;\nexport const OTEL_SPAN_EVENT_COUNT_LIMIT = 10;\nexport const OTEL_LINK_COUNT_LIMIT = 2;\nexport const OTEL_ATTRIBUTE_PER_LINK_COUNT_LIMIT = 10;\nexport const OTEL_ATTRIBUTE_PER_EVENT_COUNT_LIMIT = 10;\nexport const OFFLOAD_IO_PACKET_LENGTH_LIMIT = 128 * 1024;\n\nexport function imposeAttributeLimits(attributes: Attributes): Attributes {\n  const newAttributes: Attributes = {};\n\n  for (const [key, value] of Object.entries(attributes)) {\n    if (calculateAttributeValueLength(value) > OTEL_SPAN_ATTRIBUTE_VALUE_LENGTH_LIMIT) {\n      continue;\n    }\n\n    if (Object.keys(newAttributes).length >= OTEL_SPAN_ATTRIBUTE_COUNT_LIMIT) {\n      break;\n    }\n\n    newAttributes[key] = value;\n  }\n\n  return newAttributes;\n}\n\nfunction calculateAttributeValueLength(value: AttributeValue | undefined | null): number {\n  if (value === undefined || value === null) {\n    return 0;\n  }\n\n  if (typeof value === \"string\") {\n    return value.length;\n  }\n\n  if (typeof value === \"number\") {\n    return 8;\n  }\n\n  if (typeof value === \"boolean\") {\n    return 4;\n  }\n\n  if (Array.isArray(value)) {\n    return value.reduce((acc: number, v) => acc + calculateAttributeValueLength(v), 0);\n  }\n\n  return 0;\n}\n", "import { Attributes, Span, SpanOptions } from \"@opentelemetry/api\";\nimport { Logger, SeverityNumber } from \"@opentelemetry/api-logs\";\nimport { iconStringForSeverity } from \"../icons\";\nimport { SemanticInternalAttributes } from \"../semanticInternalAttributes\";\nimport { TriggerTracer } from \"../tracer\";\nimport { flattenAttributes } from \"../utils/flattenAttributes\";\nimport { ClockTime } from \"../clock/clock\";\nimport { clock } from \"../clock-api\";\n\nexport type LogLevel = \"none\" | \"error\" | \"warn\" | \"info\" | \"debug\" | \"log\";\n\nexport const logLevels: Array<LogLevel> = [\"none\", \"error\", \"warn\", \"info\", \"debug\"];\n\nexport type TaskLoggerConfig = {\n  logger: Logger;\n  tracer: TriggerTracer;\n  level: LogLevel;\n};\n\nexport interface TaskLogger {\n  debug(message: string, properties?: Record<string, unknown>): void;\n  log(message: string, properties?: Record<string, unknown>): void;\n  info(message: string, properties?: Record<string, unknown>): void;\n  warn(message: string, properties?: Record<string, unknown>): void;\n  error(message: string, properties?: Record<string, unknown>): void;\n  trace<T>(name: string, fn: (span: Span) => Promise<T>, options?: SpanOptions): Promise<T>;\n}\n\nexport class OtelTaskLogger implements TaskLogger {\n  private readonly _level: number;\n\n  constructor(private readonly _config: TaskLoggerConfig) {\n    this._level = logLevels.indexOf(_config.level);\n  }\n\n  debug(message: string, properties?: Record<string, unknown>) {\n    if (this._level < 4) return; // [\"none\", \"error\", \"warn\", \"info\", \"debug\"];\n\n    this.#emitLog(message, this.#getTimestampInHrTime(), \"debug\", SeverityNumber.DEBUG, properties);\n  }\n\n  log(message: string, properties?: Record<string, unknown>) {\n    if (this._level < 3) return; // [\"none\", \"error\", \"warn\", \"info\", \"debug\"];\n\n    this.#emitLog(message, this.#getTimestampInHrTime(), \"log\", SeverityNumber.INFO, properties);\n  }\n\n  info(message: string, properties?: Record<string, unknown>) {\n    if (this._level < 3) return; // [\"none\", \"error\", \"warn\", \"info\", \"debug\"];\n\n    this.#emitLog(message, this.#getTimestampInHrTime(), \"info\", SeverityNumber.INFO, properties);\n  }\n\n  warn(message: string, properties?: Record<string, unknown>) {\n    if (this._level < 2) return; // [\"none\", \"error\", \"warn\", \"info\", \"debug\"];\n\n    this.#emitLog(message, this.#getTimestampInHrTime(), \"warn\", SeverityNumber.WARN, properties);\n  }\n\n  error(message: string, properties?: Record<string, unknown>) {\n    if (this._level < 1) return; // [\"none\", \"error\", \"warn\", \"info\", \"debug\"];\n\n    this.#emitLog(message, this.#getTimestampInHrTime(), \"error\", SeverityNumber.ERROR, properties);\n  }\n\n  #emitLog(\n    message: string,\n    timestamp: ClockTime,\n    severityText: string,\n    severityNumber: SeverityNumber,\n    properties?: Record<string, unknown>\n  ) {\n    let attributes: Attributes = { ...flattenAttributes(safeJsonProcess(properties)) };\n\n    const icon = iconStringForSeverity(severityNumber);\n    if (icon !== undefined) {\n      attributes[SemanticInternalAttributes.STYLE_ICON] = icon;\n    }\n\n    this._config.logger.emit({\n      severityNumber,\n      severityText,\n      body: message,\n      attributes,\n      timestamp,\n    });\n  }\n\n  trace<T>(name: string, fn: (span: Span) => Promise<T>, options?: SpanOptions): Promise<T> {\n    return this._config.tracer.startActiveSpan(name, fn, options);\n  }\n\n  #getTimestampInHrTime(): ClockTime {\n    return clock.preciseNow();\n  }\n}\n\nexport class NoopTaskLogger implements TaskLogger {\n  debug() {}\n  log() {}\n  info() {}\n  warn() {}\n  error() {}\n  trace<T>(name: string, fn: (span: Span) => Promise<T>): Promise<T> {\n    return fn({} as Span);\n  }\n}\n\nfunction safeJsonProcess(value?: Record<string, unknown>): Record<string, unknown> | undefined {\n  try {\n    return JSON.parse(JSON.stringify(value, jsonErrorReplacer));\n  } catch {\n    return value;\n  }\n}\n\nfunction jsonErrorReplacer(key: string, value: unknown) {\n  if (value instanceof Error) {\n    return {\n      name: value.name,\n      message: value.message,\n      stack: value.stack,\n    };\n  }\n\n  return value;\n}\n", "import { NoopTaskLogger, TaskLogger } from \"./taskLogger\";\nimport { getGlobal, registerGlobal, unregisterGlobal } from \"../utils/globals\";\nimport { Span } from \"@opentelemetry/api\";\n\nconst API_NAME = \"logger\";\n\nconst NOOP_TASK_LOGGER = new NoopTaskLogger();\n\nexport class LoggerAPI implements TaskLogger {\n  private static _instance?: LoggerAPI;\n\n  private constructor() {}\n\n  public static getInstance(): LoggerAPI {\n    if (!this._instance) {\n      this._instance = new LoggerAPI();\n    }\n\n    return this._instance;\n  }\n\n  public disable() {\n    unregisterGlobal(API_NAME);\n  }\n\n  public setGlobalTaskLogger(taskLogger: TaskLogger): boolean {\n    return registerGlobal(API_NAME, taskLogger);\n  }\n\n  public debug(message: string, metadata?: Record<string, unknown>) {\n    this.#getTaskLogger().debug(message, metadata);\n  }\n\n  public log(message: string, metadata?: Record<string, unknown>) {\n    this.#getTaskLogger().log(message, metadata);\n  }\n\n  public info(message: string, metadata?: Record<string, unknown>) {\n    this.#getTaskLogger().info(message, metadata);\n  }\n\n  public warn(message: string, metadata?: Record<string, unknown>) {\n    this.#getTaskLogger().warn(message, metadata);\n  }\n\n  public error(message: string, metadata?: Record<string, unknown>) {\n    this.#getTaskLogger().error(message, metadata);\n  }\n\n  public trace<T>(name: string, fn: (span: Span) => Promise<T>): Promise<T> {\n    return this.#getTaskLogger().trace(name, fn);\n  }\n\n  #getTaskLogger(): TaskLogger {\n    return getGlobal(API_NAME) ?? NOOP_TASK_LOGGER;\n  }\n}\n", "// Split module-level variable definition into separate files to allow\n// tree-shaking on each api instance.\nimport { LoggerAPI } from \"./logger\";\n/** Entrypoint for logger API */\nexport const logger = LoggerAPI.getInstance();\n", "import { BatchTaskRunExecutionResult, TaskRunContext, TaskRunExecutionResult } from \"../schemas\";\nimport { RuntimeManager } from \"./manager\";\n\nexport class NoopRuntimeManager implements RuntimeManager {\n  disable(): void {\n    // do nothing\n  }\n\n  waitForDuration(ms: number): Promise<void> {\n    return Promise.resolve();\n  }\n\n  waitUntil(date: Date): Promise<void> {\n    return Promise.resolve();\n  }\n\n  waitForTask(params: { id: string; ctx: TaskRunContext }): Promise<TaskRunExecutionResult> {\n    return Promise.resolve({\n      ok: false,\n      id: params.id,\n      error: { type: \"INTERNAL_ERROR\", code: \"CONFIGURED_INCORRECTLY\" },\n    });\n  }\n\n  waitForBatch(params: {\n    id: string;\n    runs: string[];\n    ctx: TaskRunContext;\n  }): Promise<BatchTaskRunExecutionResult> {\n    return Promise.resolve({\n      id: params.id,\n      items: [],\n    });\n  }\n}\n", "import { UsageManager, UsageMeasurement, UsageSample } from \"./types\";\n\nexport class NoopUsageManager implements UsageManager {\n  disable(): void {\n    // Noop\n  }\n\n  start(): UsageMeasurement {\n    return {\n      sample: () => ({ cpuTime: 0, wallTime: 0 }),\n    };\n  }\n\n  stop(measurement: UsageMeasurement): UsageSample {\n    return measurement.sample();\n  }\n\n  pauseAsync<T>(cb: () => Promise<T>): Promise<T> {\n    return cb();\n  }\n\n  sample(): UsageSample | undefined {\n    return undefined;\n  }\n}\n", "const API_NAME = \"usage\";\n\nimport { getGlobal, registerGlobal, unregisterGlobal } from \"../utils/globals\";\nimport type { UsageManager, UsageMeasurement, UsageSample } from \"./types\";\nimport { NoopUsageManager } from \"./noopUsageManager\";\n\nconst NOOP_USAGE_MANAGER = new NoopUsageManager();\n\nexport class UsageAPI implements UsageManager {\n  private static _instance?: UsageAPI;\n\n  private constructor() {}\n\n  public static getInstance(): UsageAPI {\n    if (!this._instance) {\n      this._instance = new UsageAPI();\n    }\n\n    return this._instance;\n  }\n\n  public setGlobalUsageManager(manager: UsageManager): boolean {\n    return registerGlobal(API_NAME, manager);\n  }\n\n  public disable() {\n    this.#getUsageManager().disable();\n    unregisterGlobal(API_NAME);\n  }\n\n  public start(): UsageMeasurement {\n    return this.#getUsageManager().start();\n  }\n\n  public stop(measurement: UsageMeasurement): UsageSample {\n    return this.#getUsageManager().stop(measurement);\n  }\n\n  public pauseAsync<T>(cb: () => Promise<T>): Promise<T> {\n    return this.#getUsageManager().pauseAsync(cb);\n  }\n\n  public sample(): UsageSample | undefined {\n    return this.#getUsageManager().sample();\n  }\n\n  #getUsageManager(): UsageManager {\n    return getGlobal(API_NAME) ?? NOOP_USAGE_MANAGER;\n  }\n}\n", "// Split module-level variable definition into separate files to allow\n// tree-shaking on each api instance.\nimport { UsageAPI } from \"./usage/api\";\n/** Entrypoint for usage API */\nexport const usage = UsageAPI.getInstance();\n", "const API_NAME = \"runtime\";\n\nimport { BatchTaskRunExecutionResult, TaskRunContext, TaskRunExecutionResult } from \"../schemas\";\nimport { getGlobal, registerGlobal, unregisterGlobal } from \"../utils/globals\";\nimport { type RuntimeManager } from \"./manager\";\nimport { NoopRuntimeManager } from \"./noopRuntimeManager\";\nimport { usage } from \"../usage-api\";\n\nconst NOOP_RUNTIME_MANAGER = new NoopRuntimeManager();\n\nexport class RuntimeAPI {\n  private static _instance?: RuntimeAPI;\n\n  private constructor() {}\n\n  public static getInstance(): RuntimeAPI {\n    if (!this._instance) {\n      this._instance = new RuntimeAPI();\n    }\n\n    return this._instance;\n  }\n\n  public waitForDuration(ms: number): Promise<void> {\n    return usage.pauseAsync(() => this.#getRuntimeManager().waitForDuration(ms));\n  }\n\n  public waitUntil(date: Date): Promise<void> {\n    return usage.pauseAsync(() => this.#getRuntimeManager().waitUntil(date));\n  }\n\n  public waitForTask(params: { id: string; ctx: TaskRunContext }): Promise<TaskRunExecutionResult> {\n    return usage.pauseAsync(() => this.#getRuntimeManager().waitForTask(params));\n  }\n\n  public waitForBatch(params: {\n    id: string;\n    runs: string[];\n    ctx: TaskRunContext;\n  }): Promise<BatchTaskRunExecutionResult> {\n    return usage.pauseAsync(() => this.#getRuntimeManager().waitForBatch(params));\n  }\n\n  public setGlobalRuntimeManager(runtimeManager: RuntimeManager): boolean {\n    return registerGlobal(API_NAME, runtimeManager);\n  }\n\n  public disable() {\n    this.#getRuntimeManager().disable();\n    unregisterGlobal(API_NAME);\n  }\n\n  #getRuntimeManager(): RuntimeManager {\n    return getGlobal(API_NAME) ?? NOOP_RUNTIME_MANAGER;\n  }\n}\n", "// Split module-level variable definition into separate files to allow\n// tree-shaking on each api instance.\nimport { RuntimeAPI } from \"./runtime\";\n/** Entrypoint for runtime API */\nexport const runtime = RuntimeAPI.getInstance();\n", "export function getEnvVar(name: string): string | undefined {\n  // This could run in a non-Node.js environment (Bun, Deno, CF Worker, etc.), so don't just assume process.env is a thing\n  if (typeof process !== \"undefined\" && typeof process.env === \"object\" && process.env !== null) {\n    return process.env[name];\n  }\n}\n", "import { ApiClient } from \"../apiClient\";\nimport { getGlobal, registerGlobal, unregisterGlobal } from \"../utils/globals\";\nimport { getEnvVar } from \"../utils/getEnv\";\nimport { ApiClientConfiguration } from \"./types\";\n\nconst API_NAME = \"api-client\";\n\nexport class APIClientManagerAPI {\n  private static _instance?: APIClientManagerAPI;\n\n  private constructor() {}\n\n  public static getInstance(): APIClientManagerAPI {\n    if (!this._instance) {\n      this._instance = new APIClientManagerAPI();\n    }\n\n    return this._instance;\n  }\n\n  public disable() {\n    unregisterGlobal(API_NAME);\n  }\n\n  public setGlobalAPIClientConfiguration(config: ApiClientConfiguration): boolean {\n    return registerGlobal(API_NAME, config);\n  }\n\n  get baseURL(): string | undefined {\n    const store = this.#getConfig();\n    return store?.baseURL ?? getEnvVar(\"TRIGGER_API_URL\") ?? \"https://api.trigger.dev\";\n  }\n\n  get accessToken(): string | undefined {\n    const store = this.#getConfig();\n    return store?.secretKey ?? getEnvVar(\"TRIGGER_SECRET_KEY\") ?? getEnvVar(\"TRIGGER_ACCESS_TOKEN\");\n  }\n\n  get client(): ApiClient | undefined {\n    if (!this.baseURL || !this.accessToken) {\n      return undefined;\n    }\n\n    return new ApiClient(this.baseURL, this.accessToken);\n  }\n\n  #getConfig(): ApiClientConfiguration | undefined {\n    return getGlobal(API_NAME);\n  }\n}\n", "// Split module-level variable definition into separate files to allow\n// tree-shaking on each api instance.\nimport { APIClientManagerAPI } from \"./apiClientManager\";\n/** Entrypoint for logger API */\nexport const apiClientManager = APIClientManagerAPI.getInstance();\n\nexport type { ApiClientConfiguration } from \"./apiClientManager/types\";\n", "import { TaskFileMetadata, TaskMetadataWithFilePath } from \"../schemas\";\nimport { TaskMetadataWithFunctions } from \"../types\";\nimport { TaskCatalog } from \"./catalog\";\n\nexport class NoopTaskCatalog implements TaskCatalog {\n  registerTaskMetadata(task: TaskMetadataWithFunctions): void {\n    // noop\n  }\n\n  registerTaskFileMetadata(id: string, metadata: TaskFileMetadata): void {\n    // noop\n  }\n\n  updateTaskMetadata(id: string, updates: Partial<TaskMetadataWithFunctions>): void {\n    // noop\n  }\n\n  getAllTaskMetadata(): Array<TaskMetadataWithFilePath> {\n    return [];\n  }\n\n  getTaskMetadata(id: string): TaskMetadataWithFilePath | undefined {\n    return undefined;\n  }\n\n  getTask(id: string): TaskMetadataWithFunctions | undefined {\n    return undefined;\n  }\n\n  taskExists(id: string): boolean {\n    return false;\n  }\n\n  disable() {\n    // noop\n  }\n}\n", "const API_NAME = \"task-catalog\";\n\nimport { TaskFileMetadata, TaskMetadataWithFilePath } from \"../schemas\";\nimport { TaskMetadataWithFunctions } from \"../types\";\nimport { getGlobal, registerGlobal, unregisterGlobal } from \"../utils/globals\";\nimport { type TaskCatalog } from \"./catalog\";\nimport { NoopTaskCatalog } from \"./noopTaskCatalog\";\n\nconst NOOP_TASK_CATALOG = new NoopTaskCatalog();\n\nexport class TaskCatalogAPI {\n  private static _instance?: TaskCatalogAPI;\n\n  private constructor() {}\n\n  public static getInstance(): TaskCatalogAPI {\n    if (!this._instance) {\n      this._instance = new TaskCatalogAPI();\n    }\n\n    return this._instance;\n  }\n\n  public setGlobalTaskCatalog(taskCatalog: TaskCatalog): boolean {\n    return registerGlobal(API_NAME, taskCatalog);\n  }\n\n  public disable() {\n    unregisterGlobal(API_NAME);\n  }\n\n  public registerTaskMetadata(task: TaskMetadataWithFunctions): void {\n    this.#getCatalog().registerTaskMetadata(task);\n  }\n\n  public updateTaskMetadata(id: string, updates: Partial<TaskMetadataWithFunctions>): void {\n    this.#getCatalog().updateTaskMetadata(id, updates);\n  }\n\n  public registerTaskFileMetadata(id: string, metadata: TaskFileMetadata): void {\n    this.#getCatalog().registerTaskFileMetadata(id, metadata);\n  }\n\n  public getAllTaskMetadata(): Array<TaskMetadataWithFilePath> {\n    return this.#getCatalog().getAllTaskMetadata();\n  }\n\n  public getTaskMetadata(id: string): TaskMetadataWithFilePath | undefined {\n    return this.#getCatalog().getTaskMetadata(id);\n  }\n\n  public getTask(id: string): TaskMetadataWithFunctions | undefined {\n    return this.#getCatalog().getTask(id);\n  }\n\n  public taskExists(id: string): boolean {\n    return this.#getCatalog().taskExists(id);\n  }\n\n  #getCatalog(): TaskCatalog {\n    return getGlobal(API_NAME) ?? NOOP_TASK_CATALOG;\n  }\n}\n", "// Split module-level variable definition into separate files to allow\n// tree-shaking on each api instance.\nimport { TaskCatalogAPI } from \"./task-catalog\";\n/** Entrypoint for runtime API */\nexport const taskCatalog = TaskCatalogAPI.getInstance();\n", "import humanizeDuration, { Unit } from \"humanize-duration\";\n\nfunction dateDifference(date1: Date, date2: Date) {\n  return Math.abs(date1.getTime() - date2.getTime());\n}\n\ntype DurationOptions = {\n  style?: \"long\" | \"short\";\n  maxDecimalPoints?: number;\n  units?: Unit[];\n};\n\nexport function formatDuration(\n  start?: Date | null,\n  end?: Date | null,\n  options?: DurationOptions\n): string {\n  if (!start || !end) {\n    return \"–\";\n  }\n\n  return formatDurationMilliseconds(dateDifference(start, end), options);\n}\n\nexport function nanosecondsToMilliseconds(nanoseconds: number): number {\n  return nanoseconds / 1_000_000;\n}\n\nexport function millisecondsToNanoseconds(milliseconds: number): number {\n  return milliseconds * 1_000_000;\n}\n\nexport function formatDurationNanoseconds(nanoseconds: number, options?: DurationOptions): string {\n  return formatDurationMilliseconds(nanosecondsToMilliseconds(nanoseconds), options);\n}\n\nconst aboveOneSecondUnits = [\"d\", \"h\", \"m\", \"s\"] as Unit[];\nconst belowOneSecondUnits = [\"ms\"] as Unit[];\n\nexport function formatDurationMilliseconds(\n  milliseconds: number,\n  options?: DurationOptions\n): string {\n  let duration = humanizeDuration(milliseconds, {\n    units: options?.units\n      ? options.units\n      : milliseconds < 1000\n      ? belowOneSecondUnits\n      : aboveOneSecondUnits,\n    maxDecimalPoints: options?.maxDecimalPoints ?? 1,\n    largest: 2,\n  });\n\n  if (!options) {\n    return duration;\n  }\n\n  switch (options.style) {\n    case \"short\":\n      duration = duration.replace(\" milliseconds\", \"ms\");\n      duration = duration.replace(\" millisecond\", \"ms\");\n      duration = duration.replace(\" seconds\", \"s\");\n      duration = duration.replace(\" second\", \"s\");\n      duration = duration.replace(\" minutes\", \"m\");\n      duration = duration.replace(\" minute\", \"m\");\n      duration = duration.replace(\" hours\", \"h\");\n      duration = duration.replace(\" hour\", \"h\");\n      duration = duration.replace(\" days\", \"d\");\n      duration = duration.replace(\" day\", \"d\");\n      duration = duration.replace(\" weeks\", \"w\");\n      duration = duration.replace(\" week\", \"w\");\n      duration = duration.replace(\" months\", \"mo\");\n      duration = duration.replace(\" month\", \"mo\");\n      duration = duration.replace(\" years\", \"y\");\n      duration = duration.replace(\" year\", \"y\");\n  }\n\n  return duration;\n}\n\nexport function formatDurationInDays(milliseconds: number): string {\n  let duration = humanizeDuration(milliseconds, {\n    maxDecimalPoints: 0,\n    largest: 2,\n    units: [\"d\"],\n  });\n\n  return duration;\n}\n", "import {\n  Context,\n  SpanOptions,\n  SpanStatusCode,\n  context,\n  propagation,\n  trace,\n  type Span,\n  type Tracer,\n} from \"@opentelemetry/api\";\nimport { Logger, logs } from \"@opentelemetry/api-logs\";\nimport { SemanticInternalAttributes } from \"./semanticInternalAttributes\";\nimport { clock } from \"./clock-api\";\nimport { usage } from \"./usage-api\";\nimport { taskContext } from \"./task-context-api\";\n\nexport type TriggerTracerConfig =\n  | {\n      name: string;\n      version: string;\n    }\n  | {\n      tracer: Tracer;\n      logger: Logger;\n    };\n\nexport class TriggerTracer {\n  constructor(private readonly _config: TriggerTracerConfig) {}\n\n  private _tracer: Tracer | undefined;\n  private get tracer(): Tracer {\n    if (!this._tracer) {\n      if (\"tracer\" in this._config) return this._config.tracer;\n\n      this._tracer = trace.getTracer(this._config.name, this._config.version);\n    }\n\n    return this._tracer;\n  }\n\n  private _logger: Logger | undefined;\n  private get logger(): Logger {\n    if (!this._logger) {\n      if (\"logger\" in this._config) return this._config.logger;\n\n      this._logger = logs.getLogger(this._config.name, this._config.version);\n    }\n\n    return this._logger;\n  }\n\n  extractContext(traceContext?: Record<string, unknown>) {\n    return propagation.extract(context.active(), traceContext ?? {});\n  }\n\n  startActiveSpan<T>(\n    name: string,\n    fn: (span: Span) => Promise<T>,\n    options?: SpanOptions,\n    ctx?: Context\n  ): Promise<T> {\n    const parentContext = ctx ?? context.active();\n\n    const attributes = options?.attributes ?? {};\n\n    return this.tracer.startActiveSpan(\n      name,\n      {\n        ...options,\n        attributes,\n        startTime: clock.preciseNow(),\n      },\n      parentContext,\n      async (span) => {\n        if (taskContext.ctx) {\n          this.tracer\n            .startSpan(\n              name,\n              {\n                ...options,\n                attributes: {\n                  ...attributes,\n                  [SemanticInternalAttributes.SPAN_PARTIAL]: true,\n                  [SemanticInternalAttributes.SPAN_ID]: span.spanContext().spanId,\n                },\n              },\n              parentContext\n            )\n            .end();\n        }\n\n        const usageMeasurement = usage.start();\n\n        try {\n          return await fn(span);\n        } catch (e) {\n          if (typeof e === \"string\" || e instanceof Error) {\n            span.recordException(e);\n          }\n\n          span.setStatus({ code: SpanStatusCode.ERROR });\n\n          throw e;\n        } finally {\n          if (taskContext.ctx) {\n            const usageSample = usage.stop(usageMeasurement);\n            const machine = taskContext.ctx.machine;\n\n            span.setAttributes({\n              [SemanticInternalAttributes.USAGE_DURATION_MS]: usageSample.cpuTime,\n              [SemanticInternalAttributes.USAGE_COST_IN_CENTS]: machine?.centsPerMs\n                ? usageSample.cpuTime * machine.centsPerMs\n                : 0,\n            });\n          }\n\n          span.end(clock.preciseNow());\n        }\n      }\n    );\n  }\n\n  startSpan(name: string, options?: SpanOptions, ctx?: Context) {\n    const parentContext = ctx ?? context.active();\n\n    const attributes = options?.attributes ?? {};\n\n    const span = this.tracer.startSpan(name, options, ctx);\n\n    this.tracer\n      .startSpan(\n        name,\n        {\n          ...options,\n          attributes: {\n            ...attributes,\n            [SemanticInternalAttributes.SPAN_PARTIAL]: true,\n            [SemanticInternalAttributes.SPAN_ID]: span.spanContext().spanId,\n          },\n        },\n        parentContext\n      )\n      .end();\n\n    return span;\n  }\n}\n", "import { EventFilter } from \"./schemas/eventFilter\";\n\n// EventFilter is a recursive type, where the keys are strings and the values are an array of strings, numbers, booleans, or objects.\n// If the values of the array are strings, numbers, or booleans, than we are matching against the value of the payload.\n// If the values of the array are objects, then we are doing content filtering\n// An example would be [{ $endsWith: \".png\" }, { $startsWith: \"images/\" } ]\nexport function eventFilterMatches(payload: any, filter: EventFilter): boolean {\n  if (payload === undefined || payload === null) {\n    if (Object.entries(filter).length === 0) {\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  for (const [patternKey, patternValue] of Object.entries(filter)) {\n    const payloadValue = payload[patternKey];\n\n    if (Array.isArray(patternValue)) {\n      if (patternValue.length === 0) {\n        continue;\n      }\n\n      // Check to see if all the items in the array are a string\n      if ((patternValue as unknown[]).every((item) => typeof item === \"string\")) {\n        if ((patternValue as string[]).includes(payloadValue)) {\n          continue;\n        }\n\n        return false;\n      }\n\n      // Check to see if all the items in the array are a number\n      if ((patternValue as unknown[]).every((item) => typeof item === \"number\")) {\n        if ((patternValue as number[]).includes(payloadValue)) {\n          continue;\n        }\n\n        return false;\n      }\n\n      // Check to see if all the items in the array are a boolean\n      if ((patternValue as unknown[]).every((item) => typeof item === \"boolean\")) {\n        if ((patternValue as boolean[]).includes(payloadValue)) {\n          continue;\n        }\n\n        return false;\n      }\n\n      // Now we know that all the items in the array are objects\n      const objectArray = patternValue as Exclude<\n        typeof patternValue,\n        number[] | string[] | boolean[]\n      >;\n\n      if (!contentFiltersMatches(payloadValue, objectArray)) {\n        return false;\n      }\n\n      continue;\n    } else if (typeof patternValue === \"object\") {\n      if (Array.isArray(payloadValue)) {\n        if (!payloadValue.some((item) => eventFilterMatches(item, patternValue))) {\n          return false;\n        }\n      } else {\n        if (!eventFilterMatches(payloadValue, patternValue)) {\n          return false;\n        }\n      }\n    }\n  }\n  return true;\n}\n\ntype ContentFilters = Exclude<EventFilter[string], EventFilter | string[] | number[] | boolean[]>;\n\nfunction contentFiltersMatches(actualValue: any, contentFilters: ContentFilters): boolean {\n  for (const contentFilter of contentFilters) {\n    if (typeof contentFilter === \"object\") {\n      const [key, value] = Object.entries(contentFilter)[0];\n\n      if (!contentFilterMatches(actualValue, contentFilter)) {\n        return false;\n      }\n    }\n  }\n\n  return true;\n}\n\nfunction contentFilterMatches(actualValue: any, contentFilter: ContentFilters[number]): boolean {\n  if (\"$endsWith\" in contentFilter) {\n    if (typeof actualValue !== \"string\") {\n      return false;\n    }\n\n    return actualValue.endsWith(contentFilter.$endsWith);\n  }\n\n  if (\"$startsWith\" in contentFilter) {\n    if (typeof actualValue !== \"string\") {\n      return false;\n    }\n\n    return actualValue.startsWith(contentFilter.$startsWith);\n  }\n\n  if (\"$anythingBut\" in contentFilter) {\n    if (Array.isArray(contentFilter.$anythingBut)) {\n      if ((contentFilter.$anythingBut as any[]).includes(actualValue)) {\n        return false;\n      }\n    }\n\n    if (contentFilter.$anythingBut === actualValue) {\n      return false;\n    }\n\n    return true;\n  }\n\n  if (\"$exists\" in contentFilter) {\n    if (contentFilter.$exists) {\n      return actualValue !== undefined;\n    }\n\n    return actualValue === undefined;\n  }\n\n  if (\"$gt\" in contentFilter) {\n    if (typeof actualValue !== \"number\") {\n      return false;\n    }\n\n    return actualValue > contentFilter.$gt;\n  }\n\n  if (\"$lt\" in contentFilter) {\n    if (typeof actualValue !== \"number\") {\n      return false;\n    }\n\n    return actualValue < contentFilter.$lt;\n  }\n\n  if (\"$gte\" in contentFilter) {\n    if (typeof actualValue !== \"number\") {\n      return false;\n    }\n\n    return actualValue >= contentFilter.$gte;\n  }\n\n  if (\"$lte\" in contentFilter) {\n    if (typeof actualValue !== \"number\") {\n      return false;\n    }\n\n    return actualValue <= contentFilter.$lte;\n  }\n\n  if (\"$between\" in contentFilter) {\n    if (typeof actualValue !== \"number\") {\n      return false;\n    }\n\n    return actualValue >= contentFilter.$between[0] && actualValue <= contentFilter.$between[1];\n  }\n\n  if (\"$includes\" in contentFilter) {\n    if (Array.isArray(actualValue)) {\n      return actualValue.includes(contentFilter.$includes);\n    }\n\n    return false;\n  }\n\n  // Use localCompare\n  if (\"$ignoreCaseEquals\" in contentFilter) {\n    if (typeof actualValue !== \"string\") {\n      return false;\n    }\n\n    return (\n      actualValue.localeCompare(contentFilter.$ignoreCaseEquals, undefined, {\n        sensitivity: \"accent\",\n      }) === 0\n    );\n  }\n\n  if (\"$isNull\" in contentFilter) {\n    if (contentFilter.$isNull) {\n      return actualValue === null;\n    }\n\n    return actualValue !== null;\n  }\n\n  if (\"$not\" in contentFilter) {\n    if (Array.isArray(actualValue)) {\n      return !actualValue.includes(contentFilter.$not);\n    } else if (typeof actualValue === 'number' || typeof actualValue === 'boolean' || typeof actualValue === 'string') {\n      return actualValue !== contentFilter.$not;\n    }\n\n    return false;\n  }\n\n  return true;\n}\n", "export function omit<T extends Record<string, any>, K extends keyof T>(\n  obj: T,\n  ...keys: K[]\n): Omit<T, K> {\n  const result: Record<string, any> = {};\n\n  for (const key in obj) {\n    if (!keys.includes(key as unknown as K)) {\n      result[key] = obj[key];\n    }\n  }\n\n  return result as Omit<T, K>;\n}\n", "import { dependencies } from \"../../../package.json\"\n\nexport function detectDependencyVersion(dependency: string): string | undefined {\n  return (dependencies as Record<string, string>)[dependency]\n}", "import { Attributes, Span } from \"@opentelemetry/api\";\nimport { OFFLOAD_IO_PACKET_LENGTH_LIMIT, imposeAttributeLimits } from \"../limits\";\nimport { SemanticInternalAttributes } from \"../semanticInternalAttributes\";\nimport { TriggerTracer } from \"../tracer\";\nimport { flattenAttributes } from \"./flattenAttributes\";\nimport { apiClientManager } from \"../apiClientManager-api\";\n\nexport type IOPacket = {\n  data?: string | undefined;\n  dataType: string;\n};\n\nexport async function parsePacket(value: IOPacket): Promise<any> {\n  if (!value.data) {\n    return undefined;\n  }\n\n  switch (value.dataType) {\n    case \"application/json\":\n      return JSON.parse(value.data);\n    case \"application/super+json\":\n      const { parse } = await loadSuperJSON();\n\n      return parse(value.data);\n    case \"text/plain\":\n      return value.data;\n    case \"application/store\":\n      throw new Error(\n        `Cannot parse an application/store packet (${value.data}). Needs to be imported first.`\n      );\n    default:\n      return value.data;\n  }\n}\n\nexport async function stringifyIO(value: any): Promise<IOPacket> {\n  if (value === undefined) {\n    return { dataType: \"application/json\" };\n  }\n\n  if (typeof value === \"string\") {\n    return { data: value, dataType: \"text/plain\" };\n  }\n\n  try {\n    const { stringify } = await loadSuperJSON();\n    const data = stringify(value);\n\n    return { data, dataType: \"application/super+json\" };\n  } catch {\n    return { data: value, dataType: \"application/json\" };\n  }\n}\n\nexport async function conditionallyExportPacket(\n  packet: IOPacket,\n  pathPrefix: string,\n  tracer?: TriggerTracer\n): Promise<IOPacket> {\n  if (apiClientManager.client) {\n    const { needsOffloading, size } = packetRequiresOffloading(packet);\n\n    if (needsOffloading) {\n      if (!tracer) {\n        return await exportPacket(packet, pathPrefix);\n      } else {\n        const result = await tracer.startActiveSpan(\n          \"store.uploadOutput\",\n          async (span) => {\n            return await exportPacket(packet, pathPrefix);\n          },\n          {\n            attributes: {\n              byteLength: size,\n              [SemanticInternalAttributes.STYLE_ICON]: \"cloud-upload\",\n            },\n          }\n        );\n\n        return result ?? packet;\n      }\n    }\n  }\n\n  return packet;\n}\n\nexport function packetRequiresOffloading(\n  packet: IOPacket,\n  lengthLimit?: number\n): {\n  needsOffloading: boolean;\n  size: number;\n} {\n  if (!packet.data) {\n    return {\n      needsOffloading: false,\n      size: 0,\n    };\n  }\n\n  const byteSize = Buffer.byteLength(packet.data, \"utf8\");\n\n  return {\n    needsOffloading: byteSize >= (lengthLimit ?? OFFLOAD_IO_PACKET_LENGTH_LIMIT),\n    size: byteSize,\n  };\n}\n\nasync function exportPacket(packet: IOPacket, pathPrefix: string): Promise<IOPacket> {\n  // Offload the output\n  const filename = `${pathPrefix}.${getPacketExtension(packet.dataType)}`;\n\n  const presignedResponse = await apiClientManager.client!.createUploadPayloadUrl(filename);\n\n  const uploadResponse = await fetch(presignedResponse.presignedUrl, {\n    method: \"PUT\",\n    headers: {\n      \"Content-Type\": packet.dataType,\n    },\n    body: packet.data,\n  });\n\n  if (!uploadResponse.ok) {\n    throw new Error(\n      `Failed to upload output to ${presignedResponse.presignedUrl}: ${uploadResponse.statusText}`\n    );\n  }\n\n  return {\n    data: filename,\n    dataType: \"application/store\",\n  };\n}\n\nexport async function conditionallyImportPacket(\n  packet: IOPacket,\n  tracer?: TriggerTracer\n): Promise<IOPacket> {\n  if (packet.dataType !== \"application/store\") {\n    return packet;\n  }\n\n  if (!tracer) {\n    return await importPacket(packet);\n  } else {\n    const result = await tracer.startActiveSpan(\n      \"store.downloadPayload\",\n      async (span) => {\n        return await importPacket(packet, span);\n      },\n      {\n        attributes: {\n          [SemanticInternalAttributes.STYLE_ICON]: \"cloud-download\",\n        },\n      }\n    );\n\n    return result ?? packet;\n  }\n}\n\nasync function importPacket(packet: IOPacket, span?: Span): Promise<IOPacket> {\n  if (!packet.data) {\n    return packet;\n  }\n\n  if (!apiClientManager.client) {\n    return packet;\n  }\n\n  const presignedResponse = await apiClientManager.client.getPayloadUrl(packet.data);\n\n  const response = await fetch(presignedResponse.presignedUrl);\n\n  if (!response.ok) {\n    throw new Error(\n      `Failed to import packet ${presignedResponse.presignedUrl}: ${response.statusText}`\n    );\n  }\n\n  const data = await response.text();\n\n  span?.setAttribute(\"size\", Buffer.byteLength(data, \"utf8\"));\n\n  return {\n    data,\n    dataType: response.headers.get(\"content-type\") ?? \"application/json\",\n  };\n}\n\nexport async function createPacketAttributes(\n  packet: IOPacket,\n  dataKey: string,\n  dataTypeKey: string\n): Promise<Attributes | undefined> {\n  if (!packet.data) {\n    return;\n  }\n\n  switch (packet.dataType) {\n    case \"application/json\":\n      return {\n        ...flattenAttributes(packet, dataKey),\n        [dataTypeKey]: packet.dataType,\n      };\n    case \"application/super+json\":\n      const { parse } = await loadSuperJSON();\n\n      if (typeof packet.data === \"undefined\" || packet.data === null) {\n        return;\n      }\n\n      try {\n        const parsed = parse(packet.data) as any;\n        const jsonified = JSON.parse(JSON.stringify(parsed, safeReplacer));\n\n        const result = {\n          ...flattenAttributes(jsonified, dataKey),\n          [dataTypeKey]: \"application/json\",\n        };\n\n        return result;\n      } catch (e) {\n        return;\n      }\n\n    case \"application/store\":\n      return {\n        [dataKey]: packet.data,\n        [dataTypeKey]: packet.dataType,\n      };\n    case \"text/plain\":\n      return {\n        [dataKey]: packet.data,\n        [dataTypeKey]: packet.dataType,\n      };\n    default:\n      return;\n  }\n}\n\nexport async function createPacketAttributesAsJson(\n  data: any,\n  dataType: string\n): Promise<Attributes> {\n  if (\n    typeof data === \"string\" ||\n    typeof data === \"number\" ||\n    typeof data === \"boolean\" ||\n    data === null ||\n    data === undefined\n  ) {\n    return data;\n  }\n\n  switch (dataType) {\n    case \"application/json\":\n      return imposeAttributeLimits(flattenAttributes(data, undefined));\n    case \"application/super+json\":\n      const { deserialize } = await loadSuperJSON();\n\n      const deserialized = deserialize(data) as any;\n      const jsonify = safeJsonParse(JSON.stringify(deserialized, safeReplacer));\n\n      return imposeAttributeLimits(flattenAttributes(jsonify, undefined));\n    case \"application/store\":\n      return data;\n    default:\n      return {};\n  }\n}\n\nexport async function prettyPrintPacket(rawData: any, dataType?: string): Promise<string> {\n  if (rawData === undefined) {\n    return \"\";\n  }\n\n  if (dataType === \"application/super+json\") {\n    if (typeof rawData === \"string\") {\n      rawData = safeJsonParse(rawData);\n    }\n    const { deserialize } = await loadSuperJSON();\n\n    return await prettyPrintPacket(deserialize(rawData), \"application/json\");\n  }\n\n  if (dataType === \"application/json\") {\n    if (typeof rawData === \"string\") {\n      rawData = safeJsonParse(rawData);\n    }\n    return JSON.stringify(rawData, safeReplacer, 2);\n  }\n\n  if (typeof rawData === \"string\") {\n    return rawData;\n  }\n\n  return JSON.stringify(rawData, safeReplacer, 2);\n}\n\nfunction safeReplacer(key: string, value: any) {\n  // If it is a BigInt\n  if (typeof value === \"bigint\") {\n    return value.toString(); // Convert to string\n  }\n\n  // if it is a Regex\n  if (value instanceof RegExp) {\n    return value.toString(); // Convert to string\n  }\n\n  // if it is a Set\n  if (value instanceof Set) {\n    return Array.from(value); // Convert to array\n  }\n\n  // if it is a Map, convert it to an object\n  if (value instanceof Map) {\n    const obj: Record<string, any> = {};\n    value.forEach((v, k) => {\n      obj[k] = v;\n    });\n    return obj;\n  }\n\n  return value; // Otherwise return the value as is\n}\n\nfunction getPacketExtension(outputType: string): string {\n  switch (outputType) {\n    case \"application/json\":\n      return \"json\";\n    case \"application/super+json\":\n      return \"json\";\n    case \"text/plain\":\n      return \"txt\";\n    default:\n      return \"txt\";\n  }\n}\n\nasync function loadSuperJSON(): Promise<typeof import(\"superjson\")> {\n  return await import(\"superjson\");\n}\n\nfunction safeJsonParse(value: string): any {\n  try {\n    return JSON.parse(value);\n  } catch {\n    return;\n  }\n}\n\nexport async function replaceSuperJsonPayload(original: string, newPayload: string) {\n  const superjson = await loadSuperJSON();\n  const originalObject = superjson.parse(original);\n  const { meta } = superjson.serialize(originalObject);\n\n  const newSuperJson = {\n    json: JSON.parse(newPayload) as any,\n    meta,\n  };\n\n  return superjson.deserialize(newSuperJson);\n}\n", "import { SpanKind } from \"@opentelemetry/api\";\nimport { ConsoleInterceptor } from \"../consoleInterceptor\";\nimport { parseError, sanitizeError } from \"../errors\";\nimport { TracingSDK, recordSpanException } from \"../otel\";\nimport {\n  BackgroundWorkerProperties,\n  Config,\n  TaskRunContext,\n  TaskRunErrorCodes,\n  TaskRunExecution,\n  TaskRunExecutionResult,\n  TaskRunExecutionRetry,\n} from \"../schemas\";\nimport { SemanticInternalAttributes } from \"../semanticInternalAttributes\";\nimport { taskContext } from \"../task-context-api\";\nimport { TriggerTracer } from \"../tracer\";\nimport { HandleErrorFunction, ProjectConfig, TaskMetadataWithFunctions } from \"../types\";\nimport {\n  conditionallyExportPacket,\n  conditionallyImportPacket,\n  createPacketAttributes,\n  parsePacket,\n  stringifyIO,\n} from \"../utils/ioSerialization\";\nimport { calculateNextRetryDelay } from \"../utils/retries\";\nimport { accessoryAttributes } from \"../utils/styleAttributes\";\nimport { UsageMeasurement } from \"../usage/types\";\nimport { ApiError, RateLimitError } from \"../apiClient/errors\";\n\nexport type TaskExecutorOptions = {\n  tracingSDK: TracingSDK;\n  tracer: TriggerTracer;\n  consoleInterceptor: ConsoleInterceptor;\n  projectConfig: Config;\n  importedConfig: ProjectConfig | undefined;\n  handleErrorFn: HandleErrorFunction | undefined;\n};\n\nexport class TaskExecutor {\n  private _tracingSDK: TracingSDK;\n  private _tracer: TriggerTracer;\n  private _consoleInterceptor: ConsoleInterceptor;\n  private _config: Config;\n  private _importedConfig: ProjectConfig | undefined;\n  private _handleErrorFn: HandleErrorFunction | undefined;\n\n  constructor(\n    public task: TaskMetadataWithFunctions,\n    options: TaskExecutorOptions\n  ) {\n    this._tracingSDK = options.tracingSDK;\n    this._tracer = options.tracer;\n    this._consoleInterceptor = options.consoleInterceptor;\n    this._config = options.projectConfig;\n    this._importedConfig = options.importedConfig;\n    this._handleErrorFn = options.handleErrorFn;\n  }\n\n  async execute(\n    execution: TaskRunExecution,\n    worker: BackgroundWorkerProperties,\n    traceContext: Record<string, unknown>,\n    usage: UsageMeasurement\n  ): Promise<{ result: TaskRunExecutionResult }> {\n    const ctx = TaskRunContext.parse(execution);\n    const attemptMessage = `Attempt ${execution.attempt.number}`;\n\n    const originalPacket = {\n      data: execution.run.payload,\n      dataType: execution.run.payloadType,\n    };\n\n    taskContext.setGlobalTaskContext({\n      ctx,\n      worker,\n    });\n\n    this._tracingSDK.asyncResourceDetector.resolveWithAttributes({\n      ...taskContext.attributes,\n      [SemanticInternalAttributes.SDK_VERSION]: this.task.packageVersion,\n      [SemanticInternalAttributes.SDK_LANGUAGE]: \"typescript\",\n    });\n\n    const result = await this._tracer.startActiveSpan(\n      attemptMessage,\n      async (span) => {\n        return await this._consoleInterceptor.intercept(console, async () => {\n          let parsedPayload: any;\n          let initOutput: any;\n\n          try {\n            const payloadPacket = await conditionallyImportPacket(originalPacket, this._tracer);\n\n            parsedPayload = await parsePacket(payloadPacket);\n\n            if (execution.attempt.number === 1) {\n              await this.#callOnStartFunctions(parsedPayload, ctx);\n            }\n\n            initOutput = await this.#callInitFunctions(parsedPayload, ctx);\n\n            const output = await this.#callRun(parsedPayload, ctx, initOutput);\n\n            await this.#callOnSuccessFunctions(parsedPayload, output, ctx, initOutput);\n\n            try {\n              const stringifiedOutput = await stringifyIO(output);\n\n              const finalOutput = await conditionallyExportPacket(\n                stringifiedOutput,\n                `${execution.attempt.id}/output`,\n                this._tracer\n              );\n\n              const attributes = await createPacketAttributes(\n                finalOutput,\n                SemanticInternalAttributes.OUTPUT,\n                SemanticInternalAttributes.OUTPUT_TYPE\n              );\n\n              if (attributes) {\n                span.setAttributes(attributes);\n              }\n\n              return {\n                ok: true,\n                id: execution.run.id,\n                output: finalOutput.data,\n                outputType: finalOutput.dataType,\n              } satisfies TaskRunExecutionResult;\n            } catch (stringifyError) {\n              recordSpanException(span, stringifyError);\n\n              return {\n                ok: false,\n                id: execution.run.id,\n                error: {\n                  type: \"INTERNAL_ERROR\",\n                  code: TaskRunErrorCodes.TASK_OUTPUT_ERROR,\n                  message:\n                    stringifyError instanceof Error\n                      ? stringifyError.message\n                      : typeof stringifyError === \"string\"\n                      ? stringifyError\n                      : undefined,\n                },\n              } satisfies TaskRunExecutionResult;\n            }\n          } catch (runError) {\n            try {\n              const handleErrorResult = await this.#handleError(\n                execution,\n                runError,\n                parsedPayload,\n                ctx\n              );\n\n              recordSpanException(span, handleErrorResult.error ?? runError);\n\n              if (handleErrorResult.status !== \"retry\") {\n                await this.#callOnFailureFunctions(\n                  parsedPayload,\n                  handleErrorResult.error ?? runError,\n                  ctx,\n                  initOutput\n                );\n              }\n\n              return {\n                id: execution.run.id,\n                ok: false,\n                error: sanitizeError(\n                  handleErrorResult.error\n                    ? parseError(handleErrorResult.error)\n                    : parseError(runError)\n                ),\n                retry: handleErrorResult.status === \"retry\" ? handleErrorResult.retry : undefined,\n                skippedRetrying: handleErrorResult.status === \"skipped\",\n              } satisfies TaskRunExecutionResult;\n            } catch (handleErrorError) {\n              recordSpanException(span, handleErrorError);\n\n              return {\n                ok: false,\n                id: execution.run.id,\n                error: {\n                  type: \"INTERNAL_ERROR\",\n                  code: TaskRunErrorCodes.HANDLE_ERROR_ERROR,\n                  message:\n                    handleErrorError instanceof Error\n                      ? handleErrorError.message\n                      : typeof handleErrorError === \"string\"\n                      ? handleErrorError\n                      : undefined,\n                },\n              } satisfies TaskRunExecutionResult;\n            }\n          } finally {\n            await this.#callTaskCleanup(parsedPayload, ctx, initOutput);\n          }\n        });\n      },\n      {\n        kind: SpanKind.CONSUMER,\n        attributes: {\n          [SemanticInternalAttributes.STYLE_ICON]: \"attempt\",\n          ...accessoryAttributes({\n            items: [\n              {\n                text: ctx.task.filePath,\n              },\n              {\n                text: `${ctx.task.exportName}.run()`,\n              },\n            ],\n            style: \"codepath\",\n          }),\n        },\n      },\n      this._tracer.extractContext(traceContext)\n    );\n\n    return { result };\n  }\n\n  async #callRun(payload: unknown, ctx: TaskRunContext, init: unknown) {\n    const runFn = this.task.fns.run;\n    const middlewareFn = this.task.fns.middleware;\n\n    if (!runFn) {\n      throw new Error(\"Task does not have a run function\");\n    }\n\n    if (!middlewareFn) {\n      return runFn(payload, { ctx, init });\n    }\n\n    return middlewareFn(payload, { ctx, next: async () => runFn(payload, { ctx, init }) });\n  }\n\n  async #callInitFunctions(payload: unknown, ctx: TaskRunContext) {\n    await this.#callConfigInit(payload, ctx);\n\n    const initFn = this.task.fns.init;\n\n    if (!initFn) {\n      return {};\n    }\n\n    return this._tracer.startActiveSpan(\n      \"init\",\n      async (span) => {\n        return await initFn(payload, { ctx });\n      },\n      {\n        attributes: {\n          [SemanticInternalAttributes.STYLE_ICON]: \"function\",\n        },\n      }\n    );\n  }\n\n  async #callConfigInit(payload: unknown, ctx: TaskRunContext) {\n    const initFn = this._importedConfig?.init;\n\n    if (!initFn) {\n      return {};\n    }\n\n    return this._tracer.startActiveSpan(\n      \"config.init\",\n      async (span) => {\n        return await initFn(payload, { ctx });\n      },\n      {\n        attributes: {\n          [SemanticInternalAttributes.STYLE_ICON]: \"function\",\n        },\n      }\n    );\n  }\n\n  async #callOnSuccessFunctions(\n    payload: unknown,\n    output: any,\n    ctx: TaskRunContext,\n    initOutput: any\n  ) {\n    await this.#callOnSuccessFunction(\n      this.task.fns.onSuccess,\n      \"task.onSuccess\",\n      payload,\n      output,\n      ctx,\n      initOutput\n    );\n\n    await this.#callOnSuccessFunction(\n      this._importedConfig?.onSuccess,\n      \"config.onSuccess\",\n      payload,\n      output,\n      ctx,\n      initOutput\n    );\n  }\n\n  async #callOnSuccessFunction(\n    onSuccessFn: TaskMetadataWithFunctions[\"fns\"][\"onSuccess\"],\n    name: string,\n    payload: unknown,\n    output: any,\n    ctx: TaskRunContext,\n    initOutput: any\n  ) {\n    if (!onSuccessFn) {\n      return;\n    }\n\n    try {\n      await this._tracer.startActiveSpan(\n        name,\n        async (span) => {\n          return await onSuccessFn(payload, output, { ctx, init: initOutput });\n        },\n        {\n          attributes: {\n            [SemanticInternalAttributes.STYLE_ICON]: \"function\",\n          },\n        }\n      );\n    } catch {\n      // Ignore errors from onSuccess functions\n    }\n  }\n\n  async #callOnFailureFunctions(\n    payload: unknown,\n    error: unknown,\n    ctx: TaskRunContext,\n    initOutput: any\n  ) {\n    await this.#callOnFailureFunction(\n      this.task.fns.onFailure,\n      \"task.onFailure\",\n      payload,\n      error,\n      ctx,\n      initOutput\n    );\n\n    await this.#callOnFailureFunction(\n      this._importedConfig?.onFailure,\n      \"config.onFailure\",\n      payload,\n      error,\n      ctx,\n      initOutput\n    );\n  }\n\n  async #callOnFailureFunction(\n    onFailureFn: TaskMetadataWithFunctions[\"fns\"][\"onFailure\"],\n    name: string,\n    payload: unknown,\n    error: unknown,\n    ctx: TaskRunContext,\n    initOutput: any\n  ) {\n    if (!onFailureFn) {\n      return;\n    }\n\n    try {\n      return await this._tracer.startActiveSpan(\n        name,\n        async (span) => {\n          return await onFailureFn(payload, error, { ctx, init: initOutput });\n        },\n        {\n          attributes: {\n            [SemanticInternalAttributes.STYLE_ICON]: \"function\",\n          },\n        }\n      );\n    } catch (e) {\n      // Ignore errors from onFailure functions\n    }\n  }\n\n  async #callOnStartFunctions(payload: unknown, ctx: TaskRunContext) {\n    await this.#callOnStartFunction(\n      this._importedConfig?.onStart,\n      \"config.onStart\",\n      payload,\n      ctx,\n      {}\n    );\n\n    await this.#callOnStartFunction(this.task.fns.onStart, \"task.onStart\", payload, ctx, {});\n  }\n\n  async #callOnStartFunction(\n    onStartFn: TaskMetadataWithFunctions[\"fns\"][\"onStart\"],\n    name: string,\n    payload: unknown,\n    ctx: TaskRunContext,\n    initOutput: any\n  ) {\n    if (!onStartFn) {\n      return;\n    }\n\n    try {\n      await this._tracer.startActiveSpan(\n        name,\n        async (span) => {\n          return await onStartFn(payload, { ctx });\n        },\n        {\n          attributes: {\n            [SemanticInternalAttributes.STYLE_ICON]: \"function\",\n          },\n        }\n      );\n    } catch {\n      // Ignore errors from onStart functions\n    }\n  }\n\n  async #callTaskCleanup(payload: unknown, ctx: TaskRunContext, init: unknown) {\n    const cleanupFn = this.task.fns.cleanup;\n\n    if (!cleanupFn) {\n      return;\n    }\n\n    return this._tracer.startActiveSpan(\"cleanup\", async (span) => {\n      return await cleanupFn(payload, { ctx, init });\n    });\n  }\n\n  async #handleError(\n    execution: TaskRunExecution,\n    error: unknown,\n    payload: any,\n    ctx: TaskRunContext\n  ): Promise<\n    | { status: \"retry\"; retry: TaskRunExecutionRetry; error?: unknown }\n    | { status: \"skipped\"; error?: unknown } // skipped is different than noop, it means that the task was skipped from retrying, instead of just not retrying\n    | { status: \"noop\"; error?: unknown }\n  > {\n    const retriesConfig = this._importedConfig?.retries ?? this._config.retries;\n\n    const retry = this.task.retry ?? retriesConfig?.default;\n\n    if (!retry) {\n      return { status: \"noop\" };\n    }\n\n    if (error instanceof Error && error.name === \"AbortTaskRunError\") {\n      return { status: \"skipped\" };\n    }\n\n    if (execution.run.maxAttempts) {\n      retry.maxAttempts = Math.max(execution.run.maxAttempts, 1);\n    }\n\n    let delay = calculateNextRetryDelay(retry, execution.attempt.number);\n\n    if (\n      delay &&\n      error instanceof Error &&\n      error.name === \"TriggerApiError\" &&\n      (error as ApiError).status === 429\n    ) {\n      const rateLimitError = error as RateLimitError;\n\n      delay = rateLimitError.millisecondsUntilReset;\n    }\n\n    if (\n      execution.environment.type === \"DEVELOPMENT\" &&\n      typeof retriesConfig?.enabledInDev === \"boolean\" &&\n      !retriesConfig.enabledInDev\n    ) {\n      return { status: \"skipped\" };\n    }\n\n    return this._tracer.startActiveSpan(\n      \"handleError()\",\n      async (span) => {\n        const handleErrorResult = this.task.fns.handleError\n          ? await this.task.fns.handleError(payload, error, {\n              ctx,\n              retry,\n              retryDelayInMs: delay,\n              retryAt: delay ? new Date(Date.now() + delay) : undefined,\n            })\n          : this._importedConfig\n          ? await this._handleErrorFn?.(payload, error, {\n              ctx,\n              retry,\n              retryDelayInMs: delay,\n              retryAt: delay ? new Date(Date.now() + delay) : undefined,\n            })\n          : undefined;\n\n        // If handleErrorResult\n        if (!handleErrorResult) {\n          return typeof delay === \"undefined\"\n            ? { status: \"noop\" }\n            : { status: \"retry\", retry: { timestamp: Date.now() + delay, delay } };\n        }\n\n        if (handleErrorResult.skipRetrying) {\n          return { status: \"skipped\", error: handleErrorResult.error };\n        }\n\n        if (typeof handleErrorResult.retryAt !== \"undefined\") {\n          return {\n            status: \"retry\",\n            retry: {\n              timestamp: handleErrorResult.retryAt.getTime(),\n              delay: handleErrorResult.retryAt.getTime() - Date.now(),\n            },\n            error: handleErrorResult.error,\n          };\n        }\n\n        if (typeof handleErrorResult.retryDelayInMs === \"number\") {\n          return {\n            status: \"retry\",\n            retry: {\n              timestamp: Date.now() + handleErrorResult.retryDelayInMs,\n              delay: handleErrorResult.retryDelayInMs,\n            },\n            error: handleErrorResult.error,\n          };\n        }\n\n        if (handleErrorResult.retry && typeof handleErrorResult.retry === \"object\") {\n          const delay = calculateNextRetryDelay(handleErrorResult.retry, execution.attempt.number);\n\n          return typeof delay === \"undefined\"\n            ? { status: \"noop\", error: handleErrorResult.error }\n            : {\n                status: \"retry\",\n                retry: { timestamp: Date.now() + delay, delay },\n                error: handleErrorResult.error,\n              };\n        }\n\n        return { status: \"noop\", error: handleErrorResult.error };\n      },\n      {\n        attributes: {\n          [SemanticInternalAttributes.STYLE_ICON]: \"exclamation-circle\",\n        },\n      }\n    );\n  }\n}\n", "import { z } from \"zod\";\nimport { TaskRunError } from \"./schemas/common\";\n\nexport class AbortTaskRunError extends Error {\n  constructor(message: string) {\n    super(message);\n    this.name = \"AbortTaskRunError\";\n  }\n}\n\nexport function parseError(error: unknown): TaskRunError {\n  if (error instanceof Error) {\n    return {\n      type: \"BUILT_IN_ERROR\",\n      name: error.name,\n      message: error.message,\n      stackTrace: error.stack ?? \"\",\n    };\n  }\n\n  if (typeof error === \"string\") {\n    return {\n      type: \"STRING_ERROR\",\n      raw: error,\n    };\n  }\n\n  try {\n    return {\n      type: \"CUSTOM_ERROR\",\n      raw: JSON.stringify(error),\n    };\n  } catch (e) {\n    return {\n      type: \"CUSTOM_ERROR\",\n      raw: String(error),\n    };\n  }\n}\n\nexport function createErrorTaskError(error: TaskRunError): any {\n  switch (error.type) {\n    case \"BUILT_IN_ERROR\": {\n      const e = new Error(error.message);\n\n      e.name = error.name;\n      e.stack = error.stackTrace;\n\n      return e;\n    }\n    case \"STRING_ERROR\": {\n      return error.raw;\n    }\n    case \"CUSTOM_ERROR\": {\n      return JSON.parse(error.raw);\n    }\n    case \"INTERNAL_ERROR\": {\n      return new Error(`trigger.dev internal error (${error.code})`);\n    }\n  }\n}\n\nexport const SerializedError = z.object({\n  message: z.string(),\n  name: z.string().optional(),\n  stackTrace: z.string().optional(),\n});\n\nexport type SerializedError = z.infer<typeof SerializedError>;\n\nexport function createJsonErrorObject(error: TaskRunError): SerializedError {\n  switch (error.type) {\n    case \"BUILT_IN_ERROR\": {\n      return {\n        name: error.name,\n        message: error.message,\n        stackTrace: error.stackTrace,\n      };\n    }\n    case \"STRING_ERROR\": {\n      return {\n        message: error.raw,\n      };\n    }\n    case \"CUSTOM_ERROR\": {\n      return {\n        message: error.raw,\n      };\n    }\n    case \"INTERNAL_ERROR\": {\n      return {\n        message: `trigger.dev internal error (${error.code})`,\n      };\n    }\n  }\n}\n\n// Removes any null characters from the error message\nexport function sanitizeError(error: TaskRunError): TaskRunError {\n  switch (error.type) {\n    case \"BUILT_IN_ERROR\": {\n      return {\n        type: \"BUILT_IN_ERROR\",\n        message: error.message?.replace(/\\0/g, \"\"),\n        name: error.name?.replace(/\\0/g, \"\"),\n        stackTrace: error.stackTrace?.replace(/\\0/g, \"\"),\n      };\n    }\n    case \"STRING_ERROR\": {\n      return {\n        type: \"STRING_ERROR\",\n        raw: error.raw.replace(/\\0/g, \"\"),\n      };\n    }\n    case \"CUSTOM_ERROR\": {\n      return {\n        type: \"CUSTOM_ERROR\",\n        raw: error.raw.replace(/\\0/g, \"\"),\n      };\n    }\n    case \"INTERNAL_ERROR\": {\n      return {\n        type: \"INTERNAL_ERROR\",\n        code: error.code,\n        message: error.message?.replace(/\\0/g, \"\"),\n        stackTrace: error.stackTrace?.replace(/\\0/g, \"\"),\n      };\n    }\n  }\n}\n\nexport function correctErrorStackTrace(\n  stackTrace: string,\n  projectDir?: string,\n  options?: { removeFirstLine?: boolean; isDev?: boolean }\n) {\n  const [errorLine, ...traceLines] = stackTrace.split(\"\\n\");\n\n  return [\n    options?.removeFirstLine ? undefined : errorLine,\n    ...traceLines.map((line) => correctStackTraceLine(line, projectDir, options?.isDev)),\n  ]\n    .filter(Boolean)\n    .join(\"\\n\");\n}\n\nconst LINES_TO_IGNORE = [\n  /ConsoleInterceptor/,\n  /TriggerTracer/,\n  /TaskExecutor/,\n  /EXECUTE_TASK_RUN/,\n  /@trigger.dev\\/core/,\n  /packages\\/core\\/src\\/v3/,\n  /safeJsonProcess/,\n  /__entryPoint.ts/,\n  /ZodIpc/,\n  /startActiveSpan/,\n  /processTicksAndRejections/,\n];\n\nfunction correctStackTraceLine(line: string, projectDir?: string, isDev?: boolean) {\n  if (LINES_TO_IGNORE.some((regex) => regex.test(line))) {\n    return;\n  }\n\n  // Check to see if the path is inside the project directory\n  if (isDev && projectDir && !line.includes(projectDir)) {\n    return;\n  }\n\n  return line.trim();\n}\n\nexport function groupTaskMetadataIssuesByTask(tasks: any, issues: z.ZodIssue[]) {\n  return issues.reduce(\n    (acc, issue) => {\n      if (issue.path.length === 0) {\n        return acc;\n      }\n\n      const taskIndex = issue.path[1];\n\n      if (typeof taskIndex !== \"number\") {\n        return acc;\n      }\n\n      const task = tasks[taskIndex];\n\n      if (!task) {\n        return acc;\n      }\n\n      const restOfPath = issue.path.slice(2);\n\n      const taskId = task.id;\n      const taskName = task.exportName;\n      const filePath = task.filePath;\n\n      const key = taskIndex;\n\n      const existing = acc[key] ?? {\n        id: taskId,\n        exportName: taskName,\n        filePath,\n        issues: [] as Array<{ message: string; path?: string }>,\n      };\n\n      existing.issues.push({\n        message: issue.message,\n        path: restOfPath.length === 0 ? undefined : restOfPath.join(\".\"),\n      });\n\n      return {\n        ...acc,\n        [key]: existing,\n      };\n    },\n    {} as Record<\n      number,\n      {\n        id: any;\n        exportName: string;\n        filePath: string;\n        issues: Array<{ message: string; path?: string }>;\n      }\n    >\n  );\n}\n", "import { Span, SpanStatusCode } from \"@opentelemetry/api\";\n\nexport { TracingSDK, type TracingSDKConfig, type TracingDiagnosticLogLevel } from \"./tracingSDK\";\n\nexport function recordSpanException(span: Span, error: unknown) {\n  if (error instanceof Error) {\n    span.recordException(sanitizeSpanError(error));\n  } else if (typeof error === \"string\") {\n    span.recordException(error.replace(/\\0/g, \"\"));\n  } else {\n    span.recordException(JSON.stringify(error).replace(/\\0/g, \"\"));\n  }\n\n  span.setStatus({ code: SpanStatusCode.ERROR });\n}\n\nfunction sanitizeSpanError(error: Error) {\n  // Create a new error object with the same name, message and stack trace\n  const sanitizedError = new Error(error.message.replace(/\\0/g, \"\"));\n  sanitizedError.name = error.name.replace(/\\0/g, \"\");\n  sanitizedError.stack = error.stack?.replace(/\\0/g, \"\");\n\n  return sanitizedError;\n}\n", "import { DiagConsoleLogger, DiagLogLevel, TracerProvider, diag } from \"@opentelemetry/api\";\nimport { logs } from \"@opentelemetry/api-logs\";\nimport { OTLPLogExporter } from \"@opentelemetry/exporter-logs-otlp-http\";\nimport { OTLPTraceExporter } from \"@opentelemetry/exporter-trace-otlp-http\";\nimport {\n  registerInstrumentations,\n  type InstrumentationOption,\n} from \"@opentelemetry/instrumentation\";\nimport {\n  DetectorSync,\n  IResource,\n  Resource,\n  ResourceAttributes,\n  ResourceDetectionConfig,\n  detectResourcesSync,\n  processDetectorSync,\n} from \"@opentelemetry/resources\";\nimport {\n  BatchLogRecordProcessor,\n  LoggerProvider,\n  SimpleLogRecordProcessor,\n} from \"@opentelemetry/sdk-logs\";\nimport {\n  BatchSpanProcessor,\n  NodeTracerProvider,\n  SimpleSpanProcessor,\n  SpanExporter,\n} from \"@opentelemetry/sdk-trace-node\";\nimport { SemanticResourceAttributes } from \"@opentelemetry/semantic-conventions\";\nimport {\n  OTEL_ATTRIBUTE_PER_EVENT_COUNT_LIMIT,\n  OTEL_ATTRIBUTE_PER_LINK_COUNT_LIMIT,\n  OTEL_LINK_COUNT_LIMIT,\n  OTEL_LOG_ATTRIBUTE_COUNT_LIMIT,\n  OTEL_LOG_ATTRIBUTE_VALUE_LENGTH_LIMIT,\n  OTEL_SPAN_ATTRIBUTE_COUNT_LIMIT,\n  OTEL_SPAN_ATTRIBUTE_VALUE_LENGTH_LIMIT,\n  OTEL_SPAN_EVENT_COUNT_LIMIT,\n} from \"../limits\";\nimport { SemanticInternalAttributes } from \"../semanticInternalAttributes\";\nimport { TaskContextLogProcessor, TaskContextSpanProcessor } from \"../taskContext/otelProcessors\";\nimport { getEnvVar } from \"../utils/getEnv\";\nimport { version } from \"../../../package.json\";\n\nclass AsyncResourceDetector implements DetectorSync {\n  private _promise: Promise<ResourceAttributes>;\n  private _resolver?: (value: ResourceAttributes) => void;\n  private _resolved: boolean = false;\n\n  constructor() {\n    this._promise = new Promise((resolver) => {\n      this._resolver = resolver;\n    });\n  }\n\n  detect(_config?: ResourceDetectionConfig): Resource {\n    return new Resource({}, this._promise);\n  }\n\n  resolveWithAttributes(attributes: ResourceAttributes) {\n    if (!this._resolver) {\n      throw new Error(\"Resolver not available\");\n    }\n\n    if (this._resolved) {\n      return;\n    }\n\n    this._resolved = true;\n    this._resolver(attributes);\n  }\n}\n\nexport type TracingDiagnosticLogLevel =\n  | \"none\"\n  | \"error\"\n  | \"warn\"\n  | \"info\"\n  | \"debug\"\n  | \"verbose\"\n  | \"all\";\n\nexport type TracingSDKConfig = {\n  url: string;\n  forceFlushTimeoutMillis?: number;\n  resource?: IResource;\n  instrumentations?: InstrumentationOption[];\n  diagLogLevel?: TracingDiagnosticLogLevel;\n};\n\nexport class TracingSDK {\n  public readonly asyncResourceDetector = new AsyncResourceDetector();\n  private readonly _logProvider: LoggerProvider;\n  private readonly _spanExporter: SpanExporter;\n  private readonly _traceProvider: NodeTracerProvider;\n\n  public readonly getLogger: LoggerProvider[\"getLogger\"];\n  public readonly getTracer: TracerProvider[\"getTracer\"];\n\n  constructor(private readonly config: TracingSDKConfig) {\n    setLogLevel(config.diagLogLevel ?? \"none\");\n\n    const envResourceAttributesSerialized = getEnvVar(\"OTEL_RESOURCE_ATTRIBUTES\");\n    const envResourceAttributes = envResourceAttributesSerialized\n      ? JSON.parse(envResourceAttributesSerialized)\n      : {};\n\n    const commonResources = detectResourcesSync({\n      detectors: [this.asyncResourceDetector, processDetectorSync],\n    })\n      .merge(\n        new Resource({\n          [SemanticResourceAttributes.CLOUD_PROVIDER]: \"trigger.dev\",\n          [SemanticInternalAttributes.TRIGGER]: true,\n          [SemanticInternalAttributes.CLI_VERSION]: version,\n        })\n      )\n      .merge(config.resource ?? new Resource({}))\n      .merge(new Resource(envResourceAttributes));\n\n    const traceProvider = new NodeTracerProvider({\n      forceFlushTimeoutMillis: config.forceFlushTimeoutMillis,\n      resource: commonResources,\n      spanLimits: {\n        attributeCountLimit: OTEL_SPAN_ATTRIBUTE_COUNT_LIMIT,\n        attributeValueLengthLimit: OTEL_SPAN_ATTRIBUTE_VALUE_LENGTH_LIMIT,\n        eventCountLimit: OTEL_SPAN_EVENT_COUNT_LIMIT,\n        attributePerEventCountLimit: OTEL_ATTRIBUTE_PER_EVENT_COUNT_LIMIT,\n        linkCountLimit: OTEL_LINK_COUNT_LIMIT,\n        attributePerLinkCountLimit: OTEL_ATTRIBUTE_PER_LINK_COUNT_LIMIT,\n      },\n    });\n\n    const spanExporter = new OTLPTraceExporter({\n      url: `${config.url}/v1/traces`,\n      timeoutMillis: config.forceFlushTimeoutMillis,\n    });\n\n    traceProvider.addSpanProcessor(\n      new TaskContextSpanProcessor(\n        getEnvVar(\"OTEL_BATCH_PROCESSING_ENABLED\") === \"1\"\n          ? new BatchSpanProcessor(spanExporter, {\n              maxExportBatchSize: parseInt(getEnvVar(\"OTEL_SPAN_MAX_EXPORT_BATCH_SIZE\") ?? \"64\"),\n              scheduledDelayMillis: parseInt(\n                getEnvVar(\"OTEL_SPAN_SCHEDULED_DELAY_MILLIS\") ?? \"200\"\n              ),\n              exportTimeoutMillis: parseInt(\n                getEnvVar(\"OTEL_SPAN_EXPORT_TIMEOUT_MILLIS\") ?? \"30000\"\n              ),\n              maxQueueSize: parseInt(getEnvVar(\"OTEL_SPAN_MAX_QUEUE_SIZE\") ?? \"512\"),\n            })\n          : new SimpleSpanProcessor(spanExporter)\n      )\n    );\n\n    traceProvider.register();\n\n    registerInstrumentations({\n      instrumentations: config.instrumentations ?? [],\n      tracerProvider: traceProvider,\n    });\n\n    const logExporter = new OTLPLogExporter({\n      url: `${config.url}/v1/logs`,\n    });\n\n    // To start a logger, you first need to initialize the Logger provider.\n    const loggerProvider = new LoggerProvider({\n      resource: commonResources,\n      logRecordLimits: {\n        attributeCountLimit: OTEL_LOG_ATTRIBUTE_COUNT_LIMIT,\n        attributeValueLengthLimit: OTEL_LOG_ATTRIBUTE_VALUE_LENGTH_LIMIT,\n      },\n    });\n\n    loggerProvider.addLogRecordProcessor(\n      new TaskContextLogProcessor(\n        getEnvVar(\"OTEL_BATCH_PROCESSING_ENABLED\") === \"1\"\n          ? new BatchLogRecordProcessor(logExporter, {\n              maxExportBatchSize: parseInt(getEnvVar(\"OTEL_LOG_MAX_EXPORT_BATCH_SIZE\") ?? \"64\"),\n              scheduledDelayMillis: parseInt(getEnvVar(\"OTEL_LOG_SCHEDULED_DELAY_MILLIS\") ?? \"200\"),\n              exportTimeoutMillis: parseInt(getEnvVar(\"OTEL_LOG_EXPORT_TIMEOUT_MILLIS\") ?? \"30000\"),\n              maxQueueSize: parseInt(getEnvVar(\"OTEL_LOG_MAX_QUEUE_SIZE\") ?? \"512\"),\n            })\n          : new SimpleLogRecordProcessor(logExporter)\n      )\n    );\n\n    this._logProvider = loggerProvider;\n    this._spanExporter = spanExporter;\n    this._traceProvider = traceProvider;\n\n    logs.setGlobalLoggerProvider(loggerProvider);\n\n    this.getLogger = loggerProvider.getLogger.bind(loggerProvider);\n    this.getTracer = traceProvider.getTracer.bind(traceProvider);\n  }\n\n  public async flush() {\n    await Promise.all([this._traceProvider.forceFlush(), this._logProvider.forceFlush()]);\n  }\n\n  public async shutdown() {\n    await Promise.all([this._traceProvider.shutdown(), this._logProvider.shutdown()]);\n  }\n}\n\nfunction setLogLevel(level: TracingDiagnosticLogLevel) {\n  let diagLogLevel: DiagLogLevel;\n\n  switch (level) {\n    case \"none\":\n      diagLogLevel = DiagLogLevel.NONE;\n      break;\n    case \"error\":\n      diagLogLevel = DiagLogLevel.ERROR;\n      break;\n    case \"warn\":\n      diagLogLevel = DiagLogLevel.WARN;\n      break;\n    case \"info\":\n      diagLogLevel = DiagLogLevel.INFO;\n      break;\n    case \"debug\":\n      diagLogLevel = DiagLogLevel.DEBUG;\n      break;\n    case \"verbose\":\n      diagLogLevel = DiagLogLevel.VERBOSE;\n      break;\n    case \"all\":\n      diagLogLevel = DiagLogLevel.ALL;\n      break;\n    default:\n      diagLogLevel = DiagLogLevel.NONE;\n  }\n\n  diag.setLogger(new DiagConsoleLogger(), diagLogLevel);\n}\n", "import { AttributeValue, Attributes } from \"@opentelemetry/api\";\n\nexport const OTEL_SPAN_ATTRIBUTE_COUNT_LIMIT = 256;\nexport const OTEL_LOG_ATTRIBUTE_COUNT_LIMIT = 256;\nexport const OTEL_SPAN_ATTRIBUTE_VALUE_LENGTH_LIMIT = 1028;\nexport const OTEL_LOG_ATTRIBUTE_VALUE_LENGTH_LIMIT = 1028;\nexport const OTEL_SPAN_EVENT_COUNT_LIMIT = 10;\nexport const OTEL_LINK_COUNT_LIMIT = 2;\nexport const OTEL_ATTRIBUTE_PER_LINK_COUNT_LIMIT = 10;\nexport const OTEL_ATTRIBUTE_PER_EVENT_COUNT_LIMIT = 10;\nexport const OFFLOAD_IO_PACKET_LENGTH_LIMIT = 128 * 1024;\n\nexport function imposeAttributeLimits(attributes: Attributes): Attributes {\n  const newAttributes: Attributes = {};\n\n  for (const [key, value] of Object.entries(attributes)) {\n    if (calculateAttributeValueLength(value) > OTEL_SPAN_ATTRIBUTE_VALUE_LENGTH_LIMIT) {\n      continue;\n    }\n\n    if (Object.keys(newAttributes).length >= OTEL_SPAN_ATTRIBUTE_COUNT_LIMIT) {\n      break;\n    }\n\n    newAttributes[key] = value;\n  }\n\n  return newAttributes;\n}\n\nfunction calculateAttributeValueLength(value: AttributeValue | undefined | null): number {\n  if (value === undefined || value === null) {\n    return 0;\n  }\n\n  if (typeof value === \"string\") {\n    return value.length;\n  }\n\n  if (typeof value === \"number\") {\n    return 8;\n  }\n\n  if (typeof value === \"boolean\") {\n    return 4;\n  }\n\n  if (Array.isArray(value)) {\n    return value.reduce((acc: number, v) => acc + calculateAttributeValueLength(v), 0);\n  }\n\n  return 0;\n}\n", "export const SemanticInternalAttributes = {\n  ENVIRONMENT_ID: \"ctx.environment.id\",\n  ENVIRONMENT_TYPE: \"ctx.environment.type\",\n  ORGANIZATION_ID: \"ctx.organization.id\",\n  ORGANIZATION_SLUG: \"ctx.organization.slug\",\n  ORGANIZATION_NAME: \"ctx.organization.name\",\n  PROJECT_ID: \"ctx.project.id\",\n  PROJECT_REF: \"ctx.project.ref\",\n  PROJECT_NAME: \"ctx.project.title\",\n  PROJECT_DIR: \"project.dir\",\n  ATTEMPT_ID: \"ctx.attempt.id\",\n  ATTEMPT_NUMBER: \"ctx.attempt.number\",\n  RUN_ID: \"ctx.run.id\",\n  RUN_IS_TEST: \"ctx.run.isTest\",\n  BATCH_ID: \"ctx.batch.id\",\n  TASK_SLUG: \"ctx.task.id\",\n  TASK_PATH: \"ctx.task.filePath\",\n  TASK_EXPORT_NAME: \"ctx.task.exportName\",\n  QUEUE_NAME: \"ctx.queue.name\",\n  QUEUE_ID: \"ctx.queue.id\",\n  MACHINE_PRESET_NAME: \"ctx.machine.name\",\n  MACHINE_PRESET_CPU: \"ctx.machine.cpu\",\n  MACHINE_PRESET_MEMORY: \"ctx.machine.memory\",\n  MACHINE_PRESET_CENTS_PER_MS: \"ctx.machine.centsPerMs\",\n  SPAN_PARTIAL: \"$span.partial\",\n  SPAN_ID: \"$span.span_id\",\n  OUTPUT: \"$output\",\n  OUTPUT_TYPE: \"$mime_type_output\",\n  STYLE: \"$style\",\n  STYLE_ICON: \"$style.icon\",\n  STYLE_VARIANT: \"$style.variant\",\n  STYLE_ACCESSORY: \"$style.accessory\",\n  METADATA: \"$metadata\",\n  TRIGGER: \"$trigger\",\n  PAYLOAD: \"$payload\",\n  PAYLOAD_TYPE: \"$mime_type_payload\",\n  SHOW: \"$show\",\n  SHOW_ACTIONS: \"$show.actions\",\n  WORKER_ID: \"worker.id\",\n  WORKER_VERSION: \"worker.version\",\n  CLI_VERSION: \"cli.version\",\n  SDK_VERSION: \"sdk.version\",\n  SDK_LANGUAGE: \"sdk.language\",\n  RETRY_AT: \"retry.at\",\n  RETRY_DELAY: \"retry.delay\",\n  RETRY_COUNT: \"retry.count\",\n  LINK_TITLE: \"$link.title\",\n  IDEMPOTENCY_KEY: \"ctx.run.idempotencyKey\",\n  USAGE_DURATION_MS: \"$usage.durationMs\",\n  USAGE_COST_IN_CENTS: \"$usage.costInCents\",\n  RATE_LIMIT_LIMIT: \"response.rateLimit.limit\",\n  RATE_LIMIT_REMAINING: \"response.rateLimit.remaining\",\n  RATE_LIMIT_RESET: \"response.rateLimit.reset\",\n};\n", "import { Attributes } from \"@opentelemetry/api\";\n\nexport const NULL_SENTINEL = \"$@null((\";\n\nexport function flattenAttributes(\n  obj: Record<string, unknown> | Array<unknown> | string | boolean | number | null | undefined,\n  prefix?: string\n): Attributes {\n  const result: Attributes = {};\n\n  // Check if obj is null or undefined\n  if (obj === undefined) {\n    return result;\n  }\n\n  if (obj === null) {\n    result[prefix || \"\"] = NULL_SENTINEL;\n    return result;\n  }\n\n  if (typeof obj === \"string\") {\n    result[prefix || \"\"] = obj;\n    return result;\n  }\n\n  if (typeof obj === \"number\") {\n    result[prefix || \"\"] = obj;\n    return result;\n  }\n\n  if (typeof obj === \"boolean\") {\n    result[prefix || \"\"] = obj;\n    return result;\n  }\n\n  for (const [key, value] of Object.entries(obj)) {\n    const newPrefix = `${prefix ? `${prefix}.` : \"\"}${Array.isArray(obj) ? `[${key}]` : key}`;\n    if (Array.isArray(value)) {\n      for (let i = 0; i < value.length; i++) {\n        if (typeof value[i] === \"object\" && value[i] !== null) {\n          // update null check here as well\n          Object.assign(result, flattenAttributes(value[i], `${newPrefix}.[${i}]`));\n        } else {\n          if (value[i] === null) {\n            result[`${newPrefix}.[${i}]`] = NULL_SENTINEL;\n          } else {\n            result[`${newPrefix}.[${i}]`] = value[i];\n          }\n        }\n      }\n    } else if (isRecord(value)) {\n      // update null check here\n      Object.assign(result, flattenAttributes(value, newPrefix));\n    } else {\n      if (typeof value === \"number\" || typeof value === \"string\" || typeof value === \"boolean\") {\n        result[newPrefix] = value;\n      } else if (value === null) {\n        result[newPrefix] = NULL_SENTINEL;\n      }\n    }\n  }\n\n  return result;\n}\n\nfunction isRecord(value: unknown): value is Record<string, unknown> {\n  return value !== null && typeof value === \"object\" && !Array.isArray(value);\n}\n\nexport function unflattenAttributes(\n  obj: Attributes\n): Record<string, unknown> | string | number | boolean | null | undefined {\n  if (typeof obj !== \"object\" || obj === null || Array.isArray(obj)) {\n    return obj;\n  }\n\n  if (\n    typeof obj === \"object\" &&\n    obj !== null &&\n    Object.keys(obj).length === 1 &&\n    Object.keys(obj)[0] === \"\"\n  ) {\n    return rehydrateNull(obj[\"\"]) as any;\n  }\n\n  if (Object.keys(obj).length === 0) {\n    return;\n  }\n\n  const result: Record<string, unknown> = {};\n\n  for (const [key, value] of Object.entries(obj)) {\n    const parts = key.split(\".\").reduce((acc, part) => {\n      if (part.includes(\"[\")) {\n        // Handling nested array indices\n        const subparts = part.split(/\\[|\\]/).filter((p) => p !== \"\");\n        acc.push(...subparts);\n      } else {\n        acc.push(part);\n      }\n      return acc;\n    }, [] as string[]);\n\n    let current: any = result;\n    for (let i = 0; i < parts.length - 1; i++) {\n      const part = parts[i];\n      const nextPart = parts[i + 1];\n      const isArray = /^\\d+$/.test(nextPart);\n      if (isArray && !Array.isArray(current[part])) {\n        current[part] = [];\n      } else if (!isArray && current[part] === undefined) {\n        current[part] = {};\n      }\n      current = current[part];\n    }\n    const lastPart = parts[parts.length - 1];\n    current[lastPart] = rehydrateNull(value);\n  }\n\n  // Convert the result to an array if all top-level keys are numeric indices\n  if (Object.keys(result).every((k) => /^\\d+$/.test(k))) {\n    const maxIndex = Math.max(...Object.keys(result).map((k) => parseInt(k)));\n    const arrayResult = Array(maxIndex + 1);\n    for (const key in result) {\n      arrayResult[parseInt(key)] = result[key];\n    }\n    return arrayResult as any;\n  }\n\n  return result;\n}\n\nexport function primitiveValueOrflattenedAttributes(\n  obj: Record<string, unknown> | Array<unknown> | string | boolean | number | undefined,\n  prefix: string | undefined\n): Attributes | string | number | boolean | undefined {\n  if (\n    typeof obj === \"string\" ||\n    typeof obj === \"number\" ||\n    typeof obj === \"boolean\" ||\n    obj === null ||\n    obj === undefined\n  ) {\n    return obj;\n  }\n\n  const attributes = flattenAttributes(obj, prefix);\n\n  if (\n    prefix !== undefined &&\n    typeof attributes[prefix] !== \"undefined\" &&\n    attributes[prefix] !== null\n  ) {\n    return attributes[prefix] as unknown as Attributes;\n  }\n\n  return attributes;\n}\n\nfunction rehydrateNull(value: any): any {\n  if (value === NULL_SENTINEL) {\n    return null;\n  }\n\n  return value;\n}\n", "export const _globalThis = typeof globalThis === \"object\" ? globalThis : global;\n", "import { ApiClientConfiguration } from \"../apiClientManager/types\";\nimport { Clock } from \"../clock/clock\";\nimport type { RuntimeManager } from \"../runtime/manager\";\nimport { TaskCatalog } from \"../task-catalog/catalog\";\nimport { TaskContext } from \"../taskContext/types\";\nimport { UsageManager } from \"../usage/types\";\nimport { _globalThis } from \"./platform\";\n\nconst GLOBAL_TRIGGER_DOT_DEV_KEY = Symbol.for(`dev.trigger.ts.api`);\n\nconst _global = _globalThis as TriggerDotDevGlobal;\n\nexport function registerGlobal<Type extends keyof TriggerDotDevGlobalAPI>(\n  type: Type,\n  instance: TriggerDotDevGlobalAPI[Type],\n  allowOverride = false\n): boolean {\n  const api = (_global[GLOBAL_TRIGGER_DOT_DEV_KEY] = _global[GLOBAL_TRIGGER_DOT_DEV_KEY] ?? {});\n\n  if (!allowOverride && api[type]) {\n    // already registered an API of this type\n    const err = new Error(`trigger.dev: Attempted duplicate registration of API: ${type}`);\n    return false;\n  }\n\n  api[type] = instance;\n\n  return true;\n}\n\nexport function getGlobal<Type extends keyof TriggerDotDevGlobalAPI>(\n  type: Type\n): TriggerDotDevGlobalAPI[Type] | undefined {\n  return _global[GLOBAL_TRIGGER_DOT_DEV_KEY]?.[type];\n}\n\nexport function unregisterGlobal(type: keyof TriggerDotDevGlobalAPI) {\n  const api = _global[GLOBAL_TRIGGER_DOT_DEV_KEY];\n\n  if (api) {\n    delete api[type];\n  }\n}\n\ntype TriggerDotDevGlobal = {\n  [GLOBAL_TRIGGER_DOT_DEV_KEY]?: TriggerDotDevGlobalAPI;\n};\n\ntype TriggerDotDevGlobalAPI = {\n  runtime?: RuntimeManager;\n  logger?: any;\n  clock?: Clock;\n  usage?: UsageManager;\n  [\"task-catalog\"]?: TaskCatalog;\n  [\"task-context\"]?: TaskContext;\n  [\"api-client\"]?: ApiClientConfiguration;\n};\n", "import { Attributes } from \"@opentelemetry/api\";\nimport { BackgroundWorkerProperties, TaskRunContext } from \"../schemas\";\nimport { getGlobal, registerGlobal, unregisterGlobal } from \"../utils/globals\";\nimport { TaskContext } from \"./types\";\nimport { SemanticInternalAttributes } from \"../semanticInternalAttributes\";\n\nconst API_NAME = \"task-context\";\n\nexport class TaskContextAPI {\n  private static _instance?: TaskContextAPI;\n\n  private constructor() {}\n\n  public static getInstance(): TaskContextAPI {\n    if (!this._instance) {\n      this._instance = new TaskContextAPI();\n    }\n\n    return this._instance;\n  }\n\n  get isInsideTask(): boolean {\n    return this.#getTaskContext() !== undefined;\n  }\n\n  get ctx(): TaskRunContext | undefined {\n    return this.#getTaskContext()?.ctx;\n  }\n\n  get worker(): BackgroundWorkerProperties | undefined {\n    return this.#getTaskContext()?.worker;\n  }\n\n  get attributes(): Attributes {\n    if (this.ctx) {\n      return {\n        ...this.contextAttributes,\n        ...this.workerAttributes,\n      };\n    }\n\n    return {};\n  }\n\n  get workerAttributes(): Attributes {\n    if (this.worker) {\n      return {\n        [SemanticInternalAttributes.WORKER_ID]: this.worker.id,\n        [SemanticInternalAttributes.WORKER_VERSION]: this.worker.version,\n      };\n    }\n\n    return {};\n  }\n\n  get contextAttributes(): Attributes {\n    if (this.ctx) {\n      return {\n        [SemanticInternalAttributes.ATTEMPT_ID]: this.ctx.attempt.id,\n        [SemanticInternalAttributes.ATTEMPT_NUMBER]: this.ctx.attempt.number,\n        [SemanticInternalAttributes.TASK_SLUG]: this.ctx.task.id,\n        [SemanticInternalAttributes.TASK_PATH]: this.ctx.task.filePath,\n        [SemanticInternalAttributes.TASK_EXPORT_NAME]: this.ctx.task.exportName,\n        [SemanticInternalAttributes.QUEUE_NAME]: this.ctx.queue.name,\n        [SemanticInternalAttributes.QUEUE_ID]: this.ctx.queue.id,\n        [SemanticInternalAttributes.ENVIRONMENT_ID]: this.ctx.environment.id,\n        [SemanticInternalAttributes.ENVIRONMENT_TYPE]: this.ctx.environment.type,\n        [SemanticInternalAttributes.ORGANIZATION_ID]: this.ctx.organization.id,\n        [SemanticInternalAttributes.PROJECT_ID]: this.ctx.project.id,\n        [SemanticInternalAttributes.PROJECT_REF]: this.ctx.project.ref,\n        [SemanticInternalAttributes.PROJECT_NAME]: this.ctx.project.name,\n        [SemanticInternalAttributes.RUN_ID]: this.ctx.run.id,\n        [SemanticInternalAttributes.RUN_IS_TEST]: this.ctx.run.isTest,\n        [SemanticInternalAttributes.ORGANIZATION_SLUG]: this.ctx.organization.slug,\n        [SemanticInternalAttributes.ORGANIZATION_NAME]: this.ctx.organization.name,\n        [SemanticInternalAttributes.BATCH_ID]: this.ctx.batch?.id,\n        [SemanticInternalAttributes.IDEMPOTENCY_KEY]: this.ctx.run.idempotencyKey,\n        [SemanticInternalAttributes.MACHINE_PRESET_NAME]: this.ctx.machine?.name,\n        [SemanticInternalAttributes.MACHINE_PRESET_CPU]: this.ctx.machine?.cpu,\n        [SemanticInternalAttributes.MACHINE_PRESET_MEMORY]: this.ctx.machine?.memory,\n        [SemanticInternalAttributes.MACHINE_PRESET_CENTS_PER_MS]: this.ctx.machine?.centsPerMs,\n      };\n    }\n\n    return {};\n  }\n\n  public disable() {\n    unregisterGlobal(API_NAME);\n  }\n\n  public setGlobalTaskContext(taskContext: TaskContext): boolean {\n    return registerGlobal(API_NAME, taskContext);\n  }\n\n  #getTaskContext(): TaskContext | undefined {\n    return getGlobal(API_NAME);\n  }\n}\n", "// Split module-level variable definition into separate files to allow\n// tree-shaking on each api instance.\nimport { TaskContextAPI } from \"./taskContext\";\n/** Entrypoint for logger API */\nexport const taskContext = TaskContextAPI.getInstance();\n", "import { LogRecord, LogRecordProcessor } from \"@opentelemetry/sdk-logs\";\nimport { Span, SpanProcessor } from \"@opentelemetry/sdk-trace-base\";\nimport { SemanticInternalAttributes } from \"../semanticInternalAttributes\";\nimport { Context } from \"@opentelemetry/api\";\nimport { flattenAttributes } from \"../utils/flattenAttributes\";\nimport { taskContext } from \"../task-context-api\";\n\nexport class TaskContextSpanProcessor implements SpanProcessor {\n  private _innerProcessor: SpanProcessor;\n\n  constructor(innerProcessor: SpanProcessor) {\n    this._innerProcessor = innerProcessor;\n  }\n\n  // Called when a span starts\n  onStart(span: Span, parentContext: Context): void {\n    if (taskContext.ctx) {\n      span.setAttributes(\n        flattenAttributes(\n          {\n            [SemanticInternalAttributes.ATTEMPT_ID]: taskContext.ctx.attempt.id,\n            [SemanticInternalAttributes.ATTEMPT_NUMBER]: taskContext.ctx.attempt.number,\n          },\n          SemanticInternalAttributes.METADATA\n        )\n      );\n    }\n\n    this._innerProcessor.onStart(span, parentContext);\n  }\n\n  // Delegate the rest of the methods to the wrapped processor\n\n  onEnd(span: Span): void {\n    this._innerProcessor.onEnd(span);\n  }\n\n  shutdown(): Promise<void> {\n    return this._innerProcessor.shutdown();\n  }\n\n  forceFlush(): Promise<void> {\n    return this._innerProcessor.forceFlush();\n  }\n}\n\nexport class TaskContextLogProcessor implements LogRecordProcessor {\n  private _innerProcessor: LogRecordProcessor;\n\n  constructor(innerProcessor: LogRecordProcessor) {\n    this._innerProcessor = innerProcessor;\n  }\n  forceFlush(): Promise<void> {\n    return this._innerProcessor.forceFlush();\n  }\n  onEmit(logRecord: LogRecord, context?: Context | undefined): void {\n    // Adds in the context attributes to the log record\n    if (taskContext.ctx) {\n      logRecord.setAttributes(\n        flattenAttributes(\n          {\n            [SemanticInternalAttributes.ATTEMPT_ID]: taskContext.ctx.attempt.id,\n            [SemanticInternalAttributes.ATTEMPT_NUMBER]: taskContext.ctx.attempt.number,\n          },\n          SemanticInternalAttributes.METADATA\n        )\n      );\n    }\n\n    this._innerProcessor.onEmit(logRecord, context);\n  }\n  shutdown(): Promise<void> {\n    return this._innerProcessor.shutdown();\n  }\n}\n", "export function getEnvVar(name: string): string | undefined {\n  // This could run in a non-Node.js environment (Bun, Deno, CF Worker, etc.), so don't just assume process.env is a thing\n  if (typeof process !== \"undefined\" && typeof process.env === \"object\" && process.env !== null) {\n    return process.env[name];\n  }\n}\n", "{\n  \"name\": \"@trigger.dev/core\",\n  \"version\": \"3.0.0-beta.56\",\n  \"description\": \"Core code used across the Trigger.dev SDK and platform\",\n  \"license\": \"MIT\",\n  \"main\": \"./dist/index.js\",\n  \"types\": \"./dist/index.d.ts\",\n  \"module\": \"./dist/index.mjs\",\n  \"publishConfig\": {\n    \"access\": \"public\"\n  },\n  \"files\": [\n    \"dist\"\n  ],\n  \"exports\": {\n    \".\": {\n      \"import\": {\n        \"types\": \"./dist/index.d.mts\",\n        \"default\": \"./dist/index.mjs\"\n      },\n      \"require\": \"./dist/index.js\",\n      \"types\": \"./dist/index.d.ts\"\n    },\n    \"./eventFilterMatches\": {\n      \"import\": {\n        \"types\": \"./dist/eventFilterMatches.d.mts\",\n        \"default\": \"./dist/eventFilterMatches.mjs\"\n      },\n      \"require\": \"./dist/eventFilterMatches.js\",\n      \"types\": \"./dist/eventFilterMatches.d.ts\"\n    },\n    \"./replacements\": {\n      \"import\": {\n        \"types\": \"./dist/replacements.d.mts\",\n        \"default\": \"./dist/replacements.mjs\"\n      },\n      \"require\": \"./dist/replacements.js\",\n      \"types\": \"./dist/replacements.d.ts\"\n    },\n    \"./requestFilterMatches\": {\n      \"import\": {\n        \"types\": \"./dist/requestFilterMatches.d.mts\",\n        \"default\": \"./dist/requestFilterMatches.mjs\"\n      },\n      \"require\": \"./dist/requestFilterMatches.js\",\n      \"types\": \"./dist/requestFilterMatches.d.ts\"\n    },\n    \"./retry\": {\n      \"import\": {\n        \"types\": \"./dist/retry.d.mts\",\n        \"default\": \"./dist/retry.mjs\"\n      },\n      \"require\": \"./dist/retry.js\",\n      \"types\": \"./dist/retry.d.ts\"\n    },\n    \"./utils\": {\n      \"import\": {\n        \"types\": \"./dist/utils.d.mts\",\n        \"default\": \"./dist/utils.mjs\"\n      },\n      \"require\": \"./dist/utils.js\",\n      \"types\": \"./dist/utils.d.ts\"\n    },\n    \"./schemas\": {\n      \"import\": {\n        \"types\": \"./dist/schemas/index.d.mts\",\n        \"default\": \"./dist/schemas/index.mjs\"\n      },\n      \"require\": \"./dist/schemas/index.js\",\n      \"types\": \"./dist/schemas/index.d.ts\"\n    },\n    \"./types\": {\n      \"import\": {\n        \"types\": \"./dist/types.d.mts\",\n        \"default\": \"./dist/types.mjs\"\n      },\n      \"require\": \"./dist/types.js\",\n      \"types\": \"./dist/types.d.ts\"\n    },\n    \"./versions\": {\n      \"import\": {\n        \"types\": \"./dist/versions.d.mts\",\n        \"default\": \"./dist/versions.mjs\"\n      },\n      \"require\": \"./dist/versions.js\",\n      \"types\": \"./dist/versions.d.ts\"\n    },\n    \"./v3\": {\n      \"import\": {\n        \"types\": \"./dist/v3/index.d.mts\",\n        \"default\": \"./dist/v3/index.mjs\"\n      },\n      \"require\": \"./dist/v3/index.js\",\n      \"types\": \"./dist/v3/index.d.ts\"\n    },\n    \"./v3/errors\": {\n      \"import\": {\n        \"types\": \"./dist/v3/errors.d.mts\",\n        \"default\": \"./dist/v3/errors.mjs\"\n      },\n      \"require\": \"./dist/v3/errors.js\",\n      \"types\": \"./dist/v3/errors.d.ts\"\n    },\n    \"./v3/logger-api\": {\n      \"import\": {\n        \"types\": \"./dist/v3/logger-api.d.mts\",\n        \"default\": \"./dist/v3/logger-api.mjs\"\n      },\n      \"require\": \"./dist/v3/logger-api.js\",\n      \"types\": \"./dist/v3/logger-api.d.ts\"\n    },\n    \"./v3/otel\": {\n      \"import\": {\n        \"types\": \"./dist/v3/otel/index.d.mts\",\n        \"default\": \"./dist/v3/otel/index.mjs\"\n      },\n      \"require\": \"./dist/v3/otel/index.js\",\n      \"types\": \"./dist/v3/otel/index.d.ts\"\n    },\n    \"./v3/semanticInternalAttributes\": {\n      \"import\": {\n        \"types\": \"./dist/v3/semanticInternalAttributes.d.mts\",\n        \"default\": \"./dist/v3/semanticInternalAttributes.mjs\"\n      },\n      \"require\": \"./dist/v3/semanticInternalAttributes.js\",\n      \"types\": \"./dist/v3/semanticInternalAttributes.d.ts\"\n    },\n    \"./v3/utils/durations\": {\n      \"import\": {\n        \"types\": \"./dist/v3/utils/durations.d.mts\",\n        \"default\": \"./dist/v3/utils/durations.mjs\"\n      },\n      \"require\": \"./dist/v3/utils/durations.js\",\n      \"types\": \"./dist/v3/utils/durations.d.ts\"\n    },\n    \"./v3/utils/flattenAttributes\": {\n      \"import\": {\n        \"types\": \"./dist/v3/utils/flattenAttributes.d.mts\",\n        \"default\": \"./dist/v3/utils/flattenAttributes.mjs\"\n      },\n      \"require\": \"./dist/v3/utils/flattenAttributes.js\",\n      \"types\": \"./dist/v3/utils/flattenAttributes.d.ts\"\n    },\n    \"./v3/utils/ioSerialization\": {\n      \"import\": {\n        \"types\": \"./dist/v3/utils/ioSerialization.d.mts\",\n        \"default\": \"./dist/v3/utils/ioSerialization.mjs\"\n      },\n      \"require\": \"./dist/v3/utils/ioSerialization.js\",\n      \"types\": \"./dist/v3/utils/ioSerialization.d.ts\"\n    },\n    \"./v3/utils/omit\": {\n      \"import\": {\n        \"types\": \"./dist/v3/utils/omit.d.mts\",\n        \"default\": \"./dist/v3/utils/omit.mjs\"\n      },\n      \"require\": \"./dist/v3/utils/omit.js\",\n      \"types\": \"./dist/v3/utils/omit.d.ts\"\n    },\n    \"./v3/utils/retries\": {\n      \"import\": {\n        \"types\": \"./dist/v3/utils/retries.d.mts\",\n        \"default\": \"./dist/v3/utils/retries.mjs\"\n      },\n      \"require\": \"./dist/v3/utils/retries.js\",\n      \"types\": \"./dist/v3/utils/retries.d.ts\"\n    },\n    \"./v3/utils/structuredLogger\": {\n      \"import\": {\n        \"types\": \"./dist/v3/utils/structuredLogger.d.mts\",\n        \"default\": \"./dist/v3/utils/structuredLogger.mjs\"\n      },\n      \"require\": \"./dist/v3/utils/structuredLogger.js\",\n      \"types\": \"./dist/v3/utils/structuredLogger.d.ts\"\n    },\n    \"./v3/zodfetch\": {\n      \"import\": {\n        \"types\": \"./dist/v3/zodfetch.d.mts\",\n        \"default\": \"./dist/v3/zodfetch.mjs\"\n      },\n      \"require\": \"./dist/v3/zodfetch.js\",\n      \"types\": \"./dist/v3/zodfetch.d.ts\"\n    },\n    \"./v3/zodMessageHandler\": {\n      \"import\": {\n        \"types\": \"./dist/v3/zodMessageHandler.d.mts\",\n        \"default\": \"./dist/v3/zodMessageHandler.mjs\"\n      },\n      \"require\": \"./dist/v3/zodMessageHandler.js\",\n      \"types\": \"./dist/v3/zodMessageHandler.d.ts\"\n    },\n    \"./v3/zodNamespace\": {\n      \"import\": {\n        \"types\": \"./dist/v3/zodNamespace.d.mts\",\n        \"default\": \"./dist/v3/zodNamespace.mjs\"\n      },\n      \"require\": \"./dist/v3/zodNamespace.js\",\n      \"types\": \"./dist/v3/zodNamespace.d.ts\"\n    },\n    \"./v3/zodSocket\": {\n      \"import\": {\n        \"types\": \"./dist/v3/zodSocket.d.mts\",\n        \"default\": \"./dist/v3/zodSocket.mjs\"\n      },\n      \"require\": \"./dist/v3/zodSocket.js\",\n      \"types\": \"./dist/v3/zodSocket.d.ts\"\n    },\n    \"./v3/zodIpc\": {\n      \"import\": {\n        \"types\": \"./dist/v3/zodIpc.d.mts\",\n        \"default\": \"./dist/v3/zodIpc.mjs\"\n      },\n      \"require\": \"./dist/v3/zodIpc.js\",\n      \"types\": \"./dist/v3/zodIpc.d.ts\"\n    },\n    \"./v3/utils/timers\": {\n      \"import\": {\n        \"types\": \"./dist/v3/utils/timers.d.mts\",\n        \"default\": \"./dist/v3/utils/timers.mjs\"\n      },\n      \"require\": \"./dist/v3/utils/timers.js\",\n      \"types\": \"./dist/v3/utils/timers.d.ts\"\n    },\n    \"./v3/dev\": {\n      \"import\": {\n        \"types\": \"./dist/v3/dev/index.d.mts\",\n        \"default\": \"./dist/v3/dev/index.mjs\"\n      },\n      \"require\": \"./dist/v3/dev/index.js\",\n      \"types\": \"./dist/v3/dev/index.d.ts\"\n    },\n    \"./v3/prod\": {\n      \"import\": {\n        \"types\": \"./dist/v3/prod/index.d.mts\",\n        \"default\": \"./dist/v3/prod/index.mjs\"\n      },\n      \"require\": \"./dist/v3/prod/index.js\",\n      \"types\": \"./dist/v3/prod/index.d.ts\"\n    },\n    \"./v3/workers\": {\n      \"import\": {\n        \"types\": \"./dist/v3/workers/index.d.mts\",\n        \"default\": \"./dist/v3/workers/index.mjs\"\n      },\n      \"require\": \"./dist/v3/workers/index.js\",\n      \"types\": \"./dist/v3/workers/index.d.ts\"\n    },\n    \"./v3/schemas\": {\n      \"import\": {\n        \"types\": \"./dist/v3/schemas/index.d.mts\",\n        \"default\": \"./dist/v3/schemas/index.mjs\"\n      },\n      \"require\": \"./dist/v3/schemas/index.js\",\n      \"types\": \"./dist/v3/schemas/index.d.ts\"\n    },\n    \"./package.json\": \"./package.json\"\n  },\n  \"typesVersions\": {\n    \"*\": {\n      \"v3\": [\n        \"./dist/v3/index.d.ts\"\n      ],\n      \"v3/otel\": [\n        \"./dist/v3/otel/index.d.ts\"\n      ]\n    }\n  },\n  \"sideEffects\": false,\n  \"scripts\": {\n    \"clean\": \"rimraf dist\",\n    \"build\": \"npm run clean && npm run build:tsup\",\n    \"build:tsup\": \"tsup --dts-resolve\",\n    \"typecheck\": \"tsc --noEmit\",\n    \"test\": \"jest\"\n  },\n  \"dependencies\": {\n    \"@google-cloud/precise-date\": \"^4.0.0\",\n    \"@opentelemetry/api\": \"^1.8.0\",\n    \"@opentelemetry/api-logs\": \"^0.48.0\",\n    \"@opentelemetry/exporter-logs-otlp-http\": \"^0.49.1\",\n    \"@opentelemetry/exporter-trace-otlp-http\": \"^0.49.1\",\n    \"@opentelemetry/instrumentation\": \"^0.49.1\",\n    \"@opentelemetry/resources\": \"^1.22.0\",\n    \"@opentelemetry/sdk-logs\": \"^0.49.1\",\n    \"@opentelemetry/sdk-node\": \"^0.49.1\",\n    \"@opentelemetry/sdk-trace-base\": \"^1.22.0\",\n    \"@opentelemetry/sdk-trace-node\": \"^1.22.0\",\n    \"@opentelemetry/semantic-conventions\": \"^1.22.0\",\n    \"humanize-duration\": \"^3.27.3\",\n    \"socket.io-client\": \"4.7.5\",\n    \"superjson\": \"^2.2.1\",\n    \"ulidx\": \"^2.2.1\",\n    \"zod\": \"3.22.3\",\n    \"zod-error\": \"1.5.0\",\n    \"zod-validation-error\": \"^1.5.0\"\n  },\n  \"devDependencies\": {\n    \"@trigger.dev/tsconfig\": \"workspace:*\",\n    \"@trigger.dev/tsup\": \"workspace:*\",\n    \"@types/humanize-duration\": \"^3.27.1\",\n    \"@types/jest\": \"^29.5.3\",\n    \"@types/node\": \"20.12.7\",\n    \"@types/readable-stream\": \"^4.0.14\",\n    \"jest\": \"^29.6.2\",\n    \"rimraf\": \"^3.0.2\",\n    \"socket.io\": \"4.7.4\",\n    \"ts-jest\": \"^29.1.1\",\n    \"tsup\": \"^8.0.1\",\n    \"typescript\": \"^5.3.0\"\n  },\n  \"engines\": {\n    \"node\": \">=18.0.0\"\n  }\n}", "import { z } from \"zod\";\nimport { BackgroundWorkerMetadata, ImageDetailsMetadata } from \"./resources\";\nimport { QueueOptions } from \"./schemas\";\nimport { SerializedError } from \"../errors\";\n\nexport const WhoAmIResponseSchema = z.object({\n  userId: z.string(),\n  email: z.string().email(),\n  dashboardUrl: z.string(),\n});\n\nexport type WhoAmIResponse = z.infer<typeof WhoAmIResponseSchema>;\n\nexport const GetProjectResponseBody = z.object({\n  id: z.string(),\n  externalRef: z.string(),\n  name: z.string(),\n  slug: z.string(),\n  createdAt: z.coerce.date(),\n  organization: z.object({\n    id: z.string(),\n    title: z.string(),\n    slug: z.string(),\n    createdAt: z.coerce.date(),\n  }),\n});\n\nexport type GetProjectResponseBody = z.infer<typeof GetProjectResponseBody>;\n\nexport const GetProjectsResponseBody = z.array(GetProjectResponseBody);\n\nexport type GetProjectsResponseBody = z.infer<typeof GetProjectsResponseBody>;\n\nexport const GetProjectEnvResponse = z.object({\n  apiKey: z.string(),\n  name: z.string(),\n  apiUrl: z.string(),\n});\n\nexport type GetProjectEnvResponse = z.infer<typeof GetProjectEnvResponse>;\n\nexport const CreateBackgroundWorkerRequestBody = z.object({\n  localOnly: z.boolean(),\n  metadata: BackgroundWorkerMetadata,\n  supportsLazyAttempts: z.boolean().optional(),\n});\n\nexport type CreateBackgroundWorkerRequestBody = z.infer<typeof CreateBackgroundWorkerRequestBody>;\n\nexport const CreateBackgroundWorkerResponse = z.object({\n  id: z.string(),\n  version: z.string(),\n  contentHash: z.string(),\n});\n\nexport type CreateBackgroundWorkerResponse = z.infer<typeof CreateBackgroundWorkerResponse>;\n\n//an array of 1, 2, or 3 strings\nconst RunTag = z.string().max(64, \"Tags must be less than 64 characters\");\nexport const RunTags = z.union([RunTag, RunTag.array()]);\n\nexport type RunTags = z.infer<typeof RunTags>;\n\nexport const TriggerTaskRequestBody = z.object({\n  payload: z.any(),\n  context: z.any(),\n  options: z\n    .object({\n      dependentAttempt: z.string().optional(),\n      dependentBatch: z.string().optional(),\n      lockToVersion: z.string().optional(),\n      queue: QueueOptions.optional(),\n      concurrencyKey: z.string().optional(),\n      idempotencyKey: z.string().optional(),\n      test: z.boolean().optional(),\n      payloadType: z.string().optional(),\n      delay: z.string().or(z.coerce.date()).optional(),\n      ttl: z.string().or(z.number().nonnegative().int()).optional(),\n      tags: RunTags.optional(),\n      maxAttempts: z.number().int().optional(),\n    })\n    .optional(),\n});\n\nexport type TriggerTaskRequestBody = z.infer<typeof TriggerTaskRequestBody>;\n\nexport const TriggerTaskResponse = z.object({\n  id: z.string(),\n});\n\nexport type TriggerTaskResponse = z.infer<typeof TriggerTaskResponse>;\n\nexport const BatchTriggerTaskRequestBody = z.object({\n  items: TriggerTaskRequestBody.array(),\n  dependentAttempt: z.string().optional(),\n});\n\nexport type BatchTriggerTaskRequestBody = z.infer<typeof BatchTriggerTaskRequestBody>;\n\nexport const BatchTriggerTaskResponse = z.object({\n  batchId: z.string(),\n  runs: z.string().array(),\n});\n\nexport type BatchTriggerTaskResponse = z.infer<typeof BatchTriggerTaskResponse>;\n\nexport const GetBatchResponseBody = z.object({\n  id: z.string(),\n  items: z.array(\n    z.object({\n      id: z.string(),\n      taskRunId: z.string(),\n      status: z.enum([\"PENDING\", \"CANCELED\", \"COMPLETED\", \"FAILED\"]),\n    })\n  ),\n});\n\nexport type GetBatchResponseBody = z.infer<typeof GetBatchResponseBody>;\n\nexport const AddTagsRequestBody = z.object({\n  tags: RunTags,\n});\n\nexport type AddTagsRequestBody = z.infer<typeof AddTagsRequestBody>;\n\nexport const RescheduleRunRequestBody = z.object({\n  delay: z.string().or(z.coerce.date()),\n});\n\nexport type RescheduleRunRequestBody = z.infer<typeof RescheduleRunRequestBody>;\n\nexport const GetEnvironmentVariablesResponseBody = z.object({\n  variables: z.record(z.string()),\n});\n\nexport type GetEnvironmentVariablesResponseBody = z.infer<\n  typeof GetEnvironmentVariablesResponseBody\n>;\n\nexport const StartDeploymentIndexingRequestBody = z.object({\n  imageReference: z.string(),\n  selfHosted: z.boolean().optional(),\n});\n\nexport type StartDeploymentIndexingRequestBody = z.infer<typeof StartDeploymentIndexingRequestBody>;\n\nexport const StartDeploymentIndexingResponseBody = z.object({\n  id: z.string(),\n  contentHash: z.string(),\n});\n\nexport type StartDeploymentIndexingResponseBody = z.infer<\n  typeof StartDeploymentIndexingResponseBody\n>;\n\nexport const ExternalBuildData = z.object({\n  buildId: z.string(),\n  buildToken: z.string(),\n  projectId: z.string(),\n});\n\nexport type ExternalBuildData = z.infer<typeof ExternalBuildData>;\n\nexport const InitializeDeploymentResponseBody = z.object({\n  id: z.string(),\n  contentHash: z.string(),\n  shortCode: z.string(),\n  version: z.string(),\n  imageTag: z.string(),\n  externalBuildData: ExternalBuildData.optional().nullable(),\n  registryHost: z.string().optional(),\n});\n\nexport type InitializeDeploymentResponseBody = z.infer<typeof InitializeDeploymentResponseBody>;\n\nexport const InitializeDeploymentRequestBody = z.object({\n  contentHash: z.string(),\n  userId: z.string().optional(),\n});\n\nexport type InitializeDeploymentRequestBody = z.infer<typeof InitializeDeploymentRequestBody>;\n\nexport const DeploymentErrorData = z.object({\n  name: z.string(),\n  message: z.string(),\n  stack: z.string().optional(),\n  stderr: z.string().optional(),\n});\n\nexport const GetDeploymentResponseBody = z.object({\n  id: z.string(),\n  status: z.enum([\n    \"PENDING\",\n    \"BUILDING\",\n    \"DEPLOYING\",\n    \"DEPLOYED\",\n    \"FAILED\",\n    \"CANCELED\",\n    \"TIMED_OUT\",\n  ]),\n  contentHash: z.string(),\n  shortCode: z.string(),\n  version: z.string(),\n  imageReference: z.string().optional(),\n  errorData: DeploymentErrorData.optional().nullable(),\n  worker: z\n    .object({\n      id: z.string(),\n      version: z.string(),\n      tasks: z.array(\n        z.object({\n          id: z.string(),\n          slug: z.string(),\n          filePath: z.string(),\n          exportName: z.string(),\n        })\n      ),\n    })\n    .optional(),\n});\n\nexport type GetDeploymentResponseBody = z.infer<typeof GetDeploymentResponseBody>;\n\nexport const CreateUploadPayloadUrlResponseBody = z.object({\n  presignedUrl: z.string(),\n});\n\nexport type CreateUploadPayloadUrlResponseBody = z.infer<typeof CreateUploadPayloadUrlResponseBody>;\n\nexport const ReplayRunResponse = z.object({\n  id: z.string(),\n});\n\nexport type ReplayRunResponse = z.infer<typeof ReplayRunResponse>;\n\nexport const CanceledRunResponse = z.object({\n  id: z.string(),\n});\n\nexport type CanceledRunResponse = z.infer<typeof CanceledRunResponse>;\n\nexport const ScheduleType = z.union([z.literal(\"DECLARATIVE\"), z.literal(\"IMPERATIVE\")]);\n\nexport const ScheduledTaskPayload = z.object({\n  /** The schedule id associated with this run (you can have many schedules for the same task).\n    You can use this to remove the schedule, update it, etc */\n  scheduleId: z.string(),\n  /** The type of schedule – `\"DECLARATIVE\"` or `\"IMPERATIVE\"`.\n   *\n   * **DECLARATIVE** – defined inline on your `schedules.task` using the `cron` property. They can only be created, updated or deleted by modifying the `cron` property on your task.\n   *\n   * **IMPERATIVE** – created using the `schedules.create` functions or in the dashboard.\n   */\n  type: ScheduleType,\n  /** When the task was scheduled to run.\n   * Note this will be slightly different from `new Date()` because it takes a few ms to run the task.\n   * \n   * This date is UTC. To output it as a string with a timezone you would do this: \n   * ```ts\n   * const formatted = payload.timestamp.toLocaleString(\"en-US\", {\n        timeZone: payload.timezone,\n    });\n    ```  */\n  timestamp: z.date(),\n  /** When the task was last run (it has been).\n    This can be undefined if it's never been run. This date is UTC. */\n  lastTimestamp: z.date().optional(),\n  /** You can optionally provide an external id when creating the schedule.\n    Usually you would use a userId or some other unique identifier.\n    This defaults to undefined if you didn't provide one. */\n  externalId: z.string().optional(),\n  /** The IANA timezone the schedule is set to. The default is UTC.\n   * You can see the full list of supported timezones here: https://cloud.trigger.dev/timezones\n   */\n  timezone: z.string(),\n  /** The next 5 dates this task is scheduled to run */\n  upcoming: z.array(z.date()),\n});\n\nexport type ScheduledTaskPayload = z.infer<typeof ScheduledTaskPayload>;\n\nexport const CreateScheduleOptions = z.object({\n  /** The id of the task you want to attach to. */\n  task: z.string(),\n  /**  The schedule in CRON format.\n   * \n   * ```txt\n*    *    *    *    *    *\n┬    ┬    ┬    ┬    ┬\n│    │    │    │    |\n│    │    │    │    └ day of week (0 - 7, 1L - 7L) (0 or 7 is Sun)\n│    │    │    └───── month (1 - 12)\n│    │    └────────── day of month (1 - 31, L)\n│    └─────────────── hour (0 - 23)\n└──────────────────── minute (0 - 59)\n   * ```\n\n\"L\" means the last. In the \"day of week\" field, 1L means the last Monday of the month. In the day of month field, L means the last day of the month.\n\n   */\n  cron: z.string(),\n  /** You can only create one schedule with this key. If you use it twice, the second call will update the schedule.\n   *\n   * This is required to prevent you from creating duplicate schedules. */\n  deduplicationKey: z.string(),\n  /** Optionally, you can specify your own IDs (like a user ID) and then use it inside the run function of your task.\n   *\n   * This allows you to have per-user CRON tasks.\n   */\n  externalId: z.string().optional(),\n  /** Optionally, you can specify a timezone in the IANA format. If unset it will use UTC.\n   * If specified then the CRON will be evaluated in that timezone and will respect daylight savings.\n   *\n   * If you set the CRON to `0 0 * * *` and the timezone to `America/New_York` then the task will run at midnight in New York time, no matter whether it's daylight savings or not.\n   *\n   * You can see the full list of supported timezones here: https://cloud.trigger.dev/timezones\n   *\n   * @example \"America/New_York\", \"Europe/London\", \"Asia/Tokyo\", \"Africa/Cairo\"\n   *\n   */\n  timezone: z.string().optional(),\n});\n\nexport type CreateScheduleOptions = z.infer<typeof CreateScheduleOptions>;\n\nexport const UpdateScheduleOptions = CreateScheduleOptions.omit({ deduplicationKey: true });\n\nexport type UpdateScheduleOptions = z.infer<typeof UpdateScheduleOptions>;\n\nexport const ScheduleGenerator = z.object({\n  type: z.literal(\"CRON\"),\n  expression: z.string(),\n  description: z.string(),\n});\n\nexport type ScheduleGenerator = z.infer<typeof ScheduleGenerator>;\n\nexport const ScheduleObject = z.object({\n  id: z.string(),\n  type: ScheduleType,\n  task: z.string(),\n  active: z.boolean(),\n  deduplicationKey: z.string().nullish(),\n  externalId: z.string().nullish(),\n  generator: ScheduleGenerator,\n  timezone: z.string(),\n  nextRun: z.coerce.date().nullish(),\n  environments: z.array(\n    z.object({\n      id: z.string(),\n      type: z.string(),\n      userName: z.string().nullish(),\n    })\n  ),\n});\n\nexport type ScheduleObject = z.infer<typeof ScheduleObject>;\n\nexport const DeletedScheduleObject = z.object({\n  id: z.string(),\n});\n\nexport type DeletedScheduleObject = z.infer<typeof DeletedScheduleObject>;\n\nexport const ListSchedulesResult = z.object({\n  data: z.array(ScheduleObject),\n  pagination: z.object({\n    currentPage: z.number(),\n    totalPages: z.number(),\n    count: z.number(),\n  }),\n});\n\nexport type ListSchedulesResult = z.infer<typeof ListSchedulesResult>;\n\nexport const ListScheduleOptions = z.object({\n  page: z.number().optional(),\n  perPage: z.number().optional(),\n});\n\nexport type ListScheduleOptions = z.infer<typeof ListScheduleOptions>;\n\nexport const TimezonesResult = z.object({\n  timezones: z.array(z.string()),\n});\n\nexport type TimezonesResult = z.infer<typeof TimezonesResult>;\n\nexport const RunStatus = z.enum([\n  /// Task hasn't been deployed yet but is waiting to be executed\n  \"WAITING_FOR_DEPLOY\",\n  /// Task is waiting to be executed by a worker\n  \"QUEUED\",\n  /// Task is currently being executed by a worker\n  \"EXECUTING\",\n  /// Task has failed and is waiting to be retried\n  \"REATTEMPTING\",\n  /// Task has been paused by the system, and will be resumed by the system\n  \"FROZEN\",\n  /// Task has been completed successfully\n  \"COMPLETED\",\n  /// Task has been canceled by the user\n  \"CANCELED\",\n  /// Task has been completed with errors\n  \"FAILED\",\n  /// Task has crashed and won't be retried, most likely the worker ran out of resources, e.g. memory or storage\n  \"CRASHED\",\n  /// Task was interrupted during execution, mostly this happens in development environments\n  \"INTERRUPTED\",\n  /// Task has failed to complete, due to an error in the system\n  \"SYSTEM_FAILURE\",\n  /// Task has been scheduled to run at a specific time\n  \"DELAYED\",\n  /// Task has expired and won't be executed\n  \"EXPIRED\",\n]);\n\nexport type RunStatus = z.infer<typeof RunStatus>;\n\nexport const AttemptStatus = z.enum([\n  \"PENDING\",\n  \"EXECUTING\",\n  \"PAUSED\",\n  \"COMPLETED\",\n  \"FAILED\",\n  \"CANCELED\",\n]);\n\nexport type AttemptStatus = z.infer<typeof AttemptStatus>;\n\nexport const RunEnvironmentDetails = z.object({\n  id: z.string(),\n  name: z.string(),\n  user: z.string().optional(),\n});\n\nexport type RunEnvironmentDetails = z.infer<typeof RunEnvironmentDetails>;\n\nexport const RunScheduleDetails = z.object({\n  id: z.string(),\n  externalId: z.string().optional(),\n  deduplicationKey: z.string().optional(),\n  generator: ScheduleGenerator,\n});\n\nexport type RunScheduleDetails = z.infer<typeof RunScheduleDetails>;\n\nconst CommonRunFields = {\n  id: z.string(),\n  status: RunStatus,\n  taskIdentifier: z.string(),\n  idempotencyKey: z.string().optional(),\n  version: z.string().optional(),\n  isQueued: z.boolean(),\n  isExecuting: z.boolean(),\n  isCompleted: z.boolean(),\n  isSuccess: z.boolean(),\n  isFailed: z.boolean(),\n  isCancelled: z.boolean(),\n  isTest: z.boolean(),\n  createdAt: z.coerce.date(),\n  updatedAt: z.coerce.date(),\n  startedAt: z.coerce.date().optional(),\n  finishedAt: z.coerce.date().optional(),\n  delayedUntil: z.coerce.date().optional(),\n  ttl: z.string().optional(),\n  expiredAt: z.coerce.date().optional(),\n  tags: z.string().array(),\n  costInCents: z.number(),\n  baseCostInCents: z.number(),\n  durationMs: z.number(),\n};\n\nexport const RetrieveRunResponse = z.object({\n  ...CommonRunFields,\n  payload: z.any().optional(),\n  payloadPresignedUrl: z.string().optional(),\n  output: z.any().optional(),\n  outputPresignedUrl: z.string().optional(),\n  schedule: RunScheduleDetails.optional(),\n  attempts: z.array(\n    z\n      .object({\n        id: z.string(),\n        status: AttemptStatus,\n        createdAt: z.coerce.date(),\n        updatedAt: z.coerce.date(),\n        startedAt: z.coerce.date().optional(),\n        completedAt: z.coerce.date().optional(),\n        error: SerializedError.optional(),\n      })\n      .optional()\n  ),\n});\n\nexport type RetrieveRunResponse = z.infer<typeof RetrieveRunResponse>;\n\nexport const ListRunResponseItem = z.object({\n  ...CommonRunFields,\n  env: RunEnvironmentDetails,\n});\n\nexport type ListRunResponseItem = z.infer<typeof ListRunResponseItem>;\n\nexport const ListRunResponse = z.object({\n  data: z.array(ListRunResponseItem),\n  pagination: z.object({\n    next: z.string().optional(),\n    previous: z.string().optional(),\n  }),\n});\n\nexport type ListRunResponse = z.infer<typeof ListRunResponse>;\n\nexport const CreateEnvironmentVariableRequestBody = z.object({\n  name: z.string(),\n  value: z.string(),\n});\n\nexport type CreateEnvironmentVariableRequestBody = z.infer<\n  typeof CreateEnvironmentVariableRequestBody\n>;\n\nexport const UpdateEnvironmentVariableRequestBody = z.object({\n  value: z.string(),\n});\n\nexport type UpdateEnvironmentVariableRequestBody = z.infer<\n  typeof UpdateEnvironmentVariableRequestBody\n>;\n\nexport const ImportEnvironmentVariablesRequestBody = z.object({\n  variables: z.record(z.string()),\n  override: z.boolean().optional(),\n});\n\nexport type ImportEnvironmentVariablesRequestBody = z.infer<\n  typeof ImportEnvironmentVariablesRequestBody\n>;\n\nexport const EnvironmentVariableResponseBody = z.object({\n  success: z.boolean(),\n});\n\nexport type EnvironmentVariableResponseBody = z.infer<typeof EnvironmentVariableResponseBody>;\n\nexport const EnvironmentVariableValue = z.object({\n  value: z.string(),\n});\n\nexport type EnvironmentVariableValue = z.infer<typeof EnvironmentVariableValue>;\n\nexport const EnvironmentVariable = z.object({\n  name: z.string(),\n  value: z.string(),\n});\n\nexport const EnvironmentVariables = z.array(EnvironmentVariable);\n\nexport type EnvironmentVariables = z.infer<typeof EnvironmentVariables>;\n", "import { z } from \"zod\";\nimport { QueueOptions, RetryOptions, ScheduleMetadata } from \"./schemas\";\nimport { MachineConfig } from \"./common\";\n\nexport const TaskResource = z.object({\n  id: z.string(),\n  filePath: z.string(),\n  exportName: z.string(),\n  queue: QueueOptions.optional(),\n  retry: RetryOptions.optional(),\n  machine: MachineConfig.optional(),\n  triggerSource: z.string().optional(),\n  schedule: ScheduleMetadata.optional(),\n});\n\nexport type TaskResource = z.infer<typeof TaskResource>;\n\nexport const BackgroundWorkerMetadata = z.object({\n  packageVersion: z.string(),\n  contentHash: z.string(),\n  cliPackageVersion: z.string().optional(),\n  tasks: z.array(TaskResource),\n});\n\nexport type BackgroundWorkerMetadata = z.infer<typeof BackgroundWorkerMetadata>;\n\nexport const ImageDetailsMetadata = z.object({\n  contentHash: z.string(),\n  imageTag: z.string(),\n});\n\nexport type ImageDetailsMetadata = z.infer<typeof ImageDetailsMetadata>;\n", "import { z } from \"zod\";\nimport { RequireKeys } from \"../types\";\nimport { MachineConfig, MachinePreset, TaskRunExecution } from \"./common\";\n\n/*\n    WARNING: Never import anything from ./messages here. If it's needed in both, put it here instead.\n*/\nexport const EnvironmentType = z.enum([\"PRODUCTION\", \"STAGING\", \"DEVELOPMENT\", \"PREVIEW\"]);\nexport type EnvironmentType = z.infer<typeof EnvironmentType>;\n\nexport const TaskRunExecutionPayload = z.object({\n  execution: TaskRunExecution,\n  traceContext: z.record(z.unknown()),\n  environment: z.record(z.string()).optional(),\n});\n\nexport type TaskRunExecutionPayload = z.infer<typeof TaskRunExecutionPayload>;\n\n// **IMPORTANT NOTE**: If you change this schema, make sure it is backwards compatible with the previous version as this also used when a worker signals to the coordinator that a TaskRun is complete.\n// Strategies for not breaking backwards compatibility:\n// 1. Add new fields as optional\n// 2. If a field is required, add a default value\nexport const ProdTaskRunExecution = TaskRunExecution.extend({\n  worker: z.object({\n    id: z.string(),\n    contentHash: z.string(),\n    version: z.string(),\n  }),\n  machine: MachinePreset.default({ name: \"small-1x\", cpu: 1, memory: 1, centsPerMs: 0 }),\n});\n\nexport type ProdTaskRunExecution = z.infer<typeof ProdTaskRunExecution>;\n\nexport const ProdTaskRunExecutionPayload = z.object({\n  execution: ProdTaskRunExecution,\n  traceContext: z.record(z.unknown()),\n  environment: z.record(z.string()).optional(),\n});\n\nexport type ProdTaskRunExecutionPayload = z.infer<typeof ProdTaskRunExecutionPayload>;\n\nexport const FixedWindowRateLimit = z.object({\n  type: z.literal(\"fixed-window\"),\n  limit: z.number(),\n  window: z.union([\n    z.object({\n      seconds: z.number(),\n    }),\n    z.object({\n      minutes: z.number(),\n    }),\n    z.object({\n      hours: z.number(),\n    }),\n  ]),\n});\n\nexport const SlidingWindowRateLimit = z.object({\n  type: z.literal(\"sliding-window\"),\n  limit: z.number(),\n  window: z.union([\n    z.object({\n      seconds: z.number(),\n    }),\n    z.object({\n      minutes: z.number(),\n    }),\n    z.object({\n      hours: z.number(),\n    }),\n  ]),\n});\n\nexport const RateLimitOptions = z.discriminatedUnion(\"type\", [\n  FixedWindowRateLimit,\n  SlidingWindowRateLimit,\n]);\n\nexport type RateLimitOptions = z.infer<typeof RateLimitOptions>;\n\nexport const RetryOptions = z.object({\n  /** The number of attempts before giving up */\n  maxAttempts: z.number().int().optional(),\n  /** The exponential factor to use when calculating the next retry time.\n   *\n   * Each subsequent retry will be calculated as `previousTimeout * factor`\n   */\n  factor: z.number().optional(),\n  /** The minimum time to wait before retrying */\n  minTimeoutInMs: z.number().int().optional(),\n  /** The maximum time to wait before retrying */\n  maxTimeoutInMs: z.number().int().optional(),\n  /** Randomize the timeout between retries.\n   *\n   * This can be useful to prevent the thundering herd problem where all retries happen at the same time.\n   */\n  randomize: z.boolean().optional(),\n});\n\nexport type RetryOptions = z.infer<typeof RetryOptions>;\n\nexport const QueueOptions = z.object({\n  /** You can define a shared queue and then pass the name in to your task.\n   * \n   * @example\n   * \n   * ```ts\n   * const myQueue = queue({\n      name: \"my-queue\",\n      concurrencyLimit: 1,\n    });\n\n    export const task1 = task({\n      id: \"task-1\",\n      queue: {\n        name: \"my-queue\",\n      },\n      run: async (payload: { message: string }) => {\n        // ...\n      },\n    });\n\n    export const task2 = task({\n      id: \"task-2\",\n      queue: {\n        name: \"my-queue\",\n      },\n      run: async (payload: { message: string }) => {\n        // ...\n      },\n    });\n   * ```\n   */\n  name: z.string().optional(),\n  /** An optional property that specifies the maximum number of concurrent run executions.\n   *\n   * If this property is omitted, the task can potentially use up the full concurrency of an environment. */\n  concurrencyLimit: z.number().int().min(0).max(1000).optional(),\n  /** @deprecated This feature is coming soon */\n  rateLimit: RateLimitOptions.optional(),\n});\n\nexport type QueueOptions = z.infer<typeof QueueOptions>;\n\nexport const ScheduleMetadata = z.object({\n  cron: z.string(),\n  timezone: z.string(),\n});\n\nexport const TaskMetadata = z.object({\n  id: z.string(),\n  packageVersion: z.string(),\n  queue: QueueOptions.optional(),\n  retry: RetryOptions.optional(),\n  machine: MachineConfig.optional(),\n  triggerSource: z.string().optional(),\n  schedule: ScheduleMetadata.optional(),\n});\n\nexport type TaskMetadata = z.infer<typeof TaskMetadata>;\n\nexport const TaskFileMetadata = z.object({\n  filePath: z.string(),\n  exportName: z.string(),\n});\n\nexport type TaskFileMetadata = z.infer<typeof TaskFileMetadata>;\n\nexport const TaskMetadataWithFilePath = z.object({\n  id: z.string(),\n  packageVersion: z.string(),\n  queue: QueueOptions.optional(),\n  retry: RetryOptions.optional(),\n  machine: MachineConfig.optional(),\n  triggerSource: z.string().optional(),\n  schedule: ScheduleMetadata.optional(),\n  filePath: z.string(),\n  exportName: z.string(),\n});\n\nexport type TaskMetadataWithFilePath = z.infer<typeof TaskMetadataWithFilePath>;\n\nexport const PostStartCauses = z.enum([\"index\", \"create\", \"restore\"]);\nexport type PostStartCauses = z.infer<typeof PostStartCauses>;\n\nexport const PreStopCauses = z.enum([\"terminate\"]);\nexport type PreStopCauses = z.infer<typeof PreStopCauses>;\n\nconst RegexSchema = z.custom<RegExp>((val) => {\n  try {\n    // Check to see if val is a regex\n    return typeof (val as RegExp).test === \"function\";\n  } catch {\n    return false;\n  }\n});\n\nexport const Config = z.object({\n  project: z.string(),\n  triggerDirectories: z.string().array().optional(),\n  triggerUrl: z.string().optional(),\n  projectDir: z.string().optional(),\n  tsconfigPath: z.string().optional(),\n  retries: z\n    .object({\n      enabledInDev: z.boolean().default(true),\n      default: RetryOptions.optional(),\n    })\n    .optional(),\n  additionalPackages: z.string().array().optional(),\n  additionalFiles: z.string().array().optional(),\n  dependenciesToBundle: z.array(z.union([z.string(), RegexSchema])).optional(),\n  logLevel: z.string().optional(),\n  enableConsoleLogging: z.boolean().optional(),\n  postInstall: z.string().optional(),\n  extraCACerts: z.string().optional(),\n});\n\nexport type Config = z.infer<typeof Config>;\nexport type ResolvedConfig = RequireKeys<\n  Config,\n  \"triggerDirectories\" | \"triggerUrl\" | \"projectDir\" | \"tsconfigPath\"\n>;\n\nexport const WaitReason = z.enum([\"WAIT_FOR_DURATION\", \"WAIT_FOR_TASK\", \"WAIT_FOR_BATCH\"]);\n\nexport type WaitReason = z.infer<typeof WaitReason>;\n\nexport const TaskRunExecutionLazyAttemptPayload = z.object({\n  runId: z.string(),\n  attemptCount: z.number().optional(),\n  messageId: z.string(),\n  isTest: z.boolean(),\n  traceContext: z.record(z.unknown()),\n  environment: z.record(z.string()).optional(),\n});\n\nexport type TaskRunExecutionLazyAttemptPayload = z.infer<typeof TaskRunExecutionLazyAttemptPayload>;\n", "import { z } from \"zod\";\n\n// Defaults to 0.5\nexport const MachineCpu = z.union([\n  z.literal(0.25),\n  z.literal(0.5),\n  z.literal(1),\n  z.literal(2),\n  z.literal(4),\n]);\n\nexport type MachineCpu = z.infer<typeof MachineCpu>;\n\n// Defaults to 1\nexport const MachineMemory = z.union([\n  z.literal(0.25),\n  z.literal(0.5),\n  z.literal(1),\n  z.literal(2),\n  z.literal(4),\n  z.literal(8),\n]);\n\nexport type MachineMemory = z.infer<typeof MachineMemory>;\n\n// Default is small-1x\nexport const MachinePresetName = z.enum([\n  \"micro\",\n  \"small-1x\",\n  \"small-2x\",\n  \"medium-1x\",\n  \"medium-2x\",\n  \"large-1x\",\n  \"large-2x\",\n]);\n\nexport type MachinePresetName = z.infer<typeof MachinePresetName>;\n\nexport const MachineConfig = z.object({\n  cpu: MachineCpu.optional(),\n  memory: MachineMemory.optional(),\n  preset: MachinePresetName.optional(),\n});\n\nexport type MachineConfig = z.infer<typeof MachineConfig>;\n\nexport const MachinePreset = z.object({\n  name: MachinePresetName,\n  cpu: z.number(),\n  memory: z.number(),\n  centsPerMs: z.number(),\n});\n\nexport type MachinePreset = z.infer<typeof MachinePreset>;\n\nexport const TaskRunBuiltInError = z.object({\n  type: z.literal(\"BUILT_IN_ERROR\"),\n  name: z.string(),\n  message: z.string(),\n  stackTrace: z.string(),\n});\n\nexport type TaskRunBuiltInError = z.infer<typeof TaskRunBuiltInError>;\n\nexport const TaskRunCustomErrorObject = z.object({\n  type: z.literal(\"CUSTOM_ERROR\"),\n  raw: z.string(),\n});\n\nexport type TaskRunCustomErrorObject = z.infer<typeof TaskRunCustomErrorObject>;\n\nexport const TaskRunStringError = z.object({\n  type: z.literal(\"STRING_ERROR\"),\n  raw: z.string(),\n});\n\nexport type TaskRunStringError = z.infer<typeof TaskRunStringError>;\n\nexport const TaskRunErrorCodes = {\n  COULD_NOT_FIND_EXECUTOR: \"COULD_NOT_FIND_EXECUTOR\",\n  COULD_NOT_FIND_TASK: \"COULD_NOT_FIND_TASK\",\n  CONFIGURED_INCORRECTLY: \"CONFIGURED_INCORRECTLY\",\n  TASK_ALREADY_RUNNING: \"TASK_ALREADY_RUNNING\",\n  TASK_EXECUTION_FAILED: \"TASK_EXECUTION_FAILED\",\n  TASK_EXECUTION_ABORTED: \"TASK_EXECUTION_ABORTED\",\n  TASK_PROCESS_EXITED_WITH_NON_ZERO_CODE: \"TASK_PROCESS_EXITED_WITH_NON_ZERO_CODE\",\n  TASK_PROCESS_SIGKILL_TIMEOUT: \"TASK_PROCESS_SIGKILL_TIMEOUT\",\n  TASK_RUN_CANCELLED: \"TASK_RUN_CANCELLED\",\n  TASK_OUTPUT_ERROR: \"TASK_OUTPUT_ERROR\",\n  HANDLE_ERROR_ERROR: \"HANDLE_ERROR_ERROR\",\n  GRACEFUL_EXIT_TIMEOUT: \"GRACEFUL_EXIT_TIMEOUT\",\n  TASK_RUN_CRASHED: \"TASK_RUN_CRASHED\",\n} as const;\n\nexport const TaskRunInternalError = z.object({\n  type: z.literal(\"INTERNAL_ERROR\"),\n  code: z.enum([\n    \"COULD_NOT_FIND_EXECUTOR\",\n    \"COULD_NOT_FIND_TASK\",\n    \"CONFIGURED_INCORRECTLY\",\n    \"TASK_ALREADY_RUNNING\",\n    \"TASK_EXECUTION_FAILED\",\n    \"TASK_EXECUTION_ABORTED\",\n    \"TASK_PROCESS_EXITED_WITH_NON_ZERO_CODE\",\n    \"TASK_PROCESS_SIGKILL_TIMEOUT\",\n    \"TASK_RUN_CANCELLED\",\n    \"TASK_OUTPUT_ERROR\",\n    \"HANDLE_ERROR_ERROR\",\n    \"GRACEFUL_EXIT_TIMEOUT\",\n    \"TASK_RUN_HEARTBEAT_TIMEOUT\",\n    \"TASK_RUN_CRASHED\",\n  ]),\n  message: z.string().optional(),\n  stackTrace: z.string().optional(),\n});\n\nexport type TaskRunInternalError = z.infer<typeof TaskRunInternalError>;\n\nexport const TaskRunError = z.discriminatedUnion(\"type\", [\n  TaskRunBuiltInError,\n  TaskRunCustomErrorObject,\n  TaskRunStringError,\n  TaskRunInternalError,\n]);\n\nexport type TaskRunError = z.infer<typeof TaskRunError>;\n\nexport const TaskRun = z.object({\n  id: z.string(),\n  payload: z.string(),\n  payloadType: z.string(),\n  context: z.any(),\n  tags: z.array(z.string()),\n  isTest: z.boolean().default(false),\n  createdAt: z.coerce.date(),\n  startedAt: z.coerce.date().default(() => new Date()),\n  idempotencyKey: z.string().optional(),\n  maxAttempts: z.number().optional(),\n  durationMs: z.number().default(0),\n  costInCents: z.number().default(0),\n  baseCostInCents: z.number().default(0),\n  version: z.string().optional(),\n});\n\nexport type TaskRun = z.infer<typeof TaskRun>;\n\nexport const TaskRunExecutionTask = z.object({\n  id: z.string(),\n  filePath: z.string(),\n  exportName: z.string(),\n});\n\nexport type TaskRunExecutionTask = z.infer<typeof TaskRunExecutionTask>;\n\nexport const TaskRunExecutionAttempt = z.object({\n  id: z.string(),\n  number: z.number(),\n  startedAt: z.coerce.date(),\n  backgroundWorkerId: z.string(),\n  backgroundWorkerTaskId: z.string(),\n  status: z.string(),\n});\n\nexport type TaskRunExecutionAttempt = z.infer<typeof TaskRunExecutionAttempt>;\n\nexport const TaskRunExecutionEnvironment = z.object({\n  id: z.string(),\n  slug: z.string(),\n  type: z.enum([\"PRODUCTION\", \"STAGING\", \"DEVELOPMENT\", \"PREVIEW\"]),\n});\n\nexport type TaskRunExecutionEnvironment = z.infer<typeof TaskRunExecutionEnvironment>;\n\nexport const TaskRunExecutionOrganization = z.object({\n  id: z.string(),\n  slug: z.string(),\n  name: z.string(),\n});\n\nexport type TaskRunExecutionOrganization = z.infer<typeof TaskRunExecutionOrganization>;\n\nexport const TaskRunExecutionProject = z.object({\n  id: z.string(),\n  ref: z.string(),\n  slug: z.string(),\n  name: z.string(),\n});\n\nexport type TaskRunExecutionProject = z.infer<typeof TaskRunExecutionProject>;\n\nexport const TaskRunExecutionQueue = z.object({\n  id: z.string(),\n  name: z.string(),\n});\n\nexport type TaskRunExecutionQueue = z.infer<typeof TaskRunExecutionQueue>;\n\nexport const TaskRunExecutionBatch = z.object({\n  id: z.string(),\n});\n\nexport const TaskRunExecution = z.object({\n  task: TaskRunExecutionTask,\n  attempt: TaskRunExecutionAttempt,\n  run: TaskRun,\n  queue: TaskRunExecutionQueue,\n  environment: TaskRunExecutionEnvironment,\n  organization: TaskRunExecutionOrganization,\n  project: TaskRunExecutionProject,\n  batch: TaskRunExecutionBatch.optional(),\n  machine: MachinePreset.optional(),\n});\n\nexport type TaskRunExecution = z.infer<typeof TaskRunExecution>;\n\nexport const TaskRunContext = z.object({\n  task: TaskRunExecutionTask,\n  attempt: TaskRunExecutionAttempt.omit({\n    backgroundWorkerId: true,\n    backgroundWorkerTaskId: true,\n  }),\n  run: TaskRun.omit({ payload: true, payloadType: true }),\n  queue: TaskRunExecutionQueue,\n  environment: TaskRunExecutionEnvironment,\n  organization: TaskRunExecutionOrganization,\n  project: TaskRunExecutionProject,\n  batch: TaskRunExecutionBatch.optional(),\n  machine: MachinePreset.optional(),\n});\n\nexport type TaskRunContext = z.infer<typeof TaskRunContext>;\n\nexport const TaskRunExecutionRetry = z.object({\n  timestamp: z.number(),\n  delay: z.number(),\n  error: z.unknown().optional(),\n});\n\nexport type TaskRunExecutionRetry = z.infer<typeof TaskRunExecutionRetry>;\n\nexport const TaskRunExecutionUsage = z.object({\n  durationMs: z.number(),\n});\n\nexport type TaskRunExecutionUsage = z.infer<typeof TaskRunExecutionUsage>;\n\nexport const TaskRunFailedExecutionResult = z.object({\n  ok: z.literal(false),\n  id: z.string(),\n  error: TaskRunError,\n  retry: TaskRunExecutionRetry.optional(),\n  skippedRetrying: z.boolean().optional(),\n  usage: TaskRunExecutionUsage.optional(),\n});\n\nexport type TaskRunFailedExecutionResult = z.infer<typeof TaskRunFailedExecutionResult>;\n\nexport const TaskRunSuccessfulExecutionResult = z.object({\n  ok: z.literal(true),\n  id: z.string(),\n  output: z.string().optional(),\n  outputType: z.string(),\n  usage: TaskRunExecutionUsage.optional(),\n});\n\nexport type TaskRunSuccessfulExecutionResult = z.infer<typeof TaskRunSuccessfulExecutionResult>;\n\nexport const TaskRunExecutionResult = z.discriminatedUnion(\"ok\", [\n  TaskRunSuccessfulExecutionResult,\n  TaskRunFailedExecutionResult,\n]);\n\nexport type TaskRunExecutionResult = z.infer<typeof TaskRunExecutionResult>;\n\nexport const BatchTaskRunExecutionResult = z.object({\n  id: z.string(),\n  items: TaskRunExecutionResult.array(),\n});\n\nexport type BatchTaskRunExecutionResult = z.infer<typeof BatchTaskRunExecutionResult>;\n", "import { context, propagation } from \"@opentelemetry/api\";\nimport { z } from \"zod\";\nimport { version } from \"../../../package.json\";\nimport {\n  AddTagsRequestBody,\n  BatchTaskRunExecutionResult,\n  BatchTriggerTaskRequestBody,\n  BatchTriggerTaskResponse,\n  CanceledRunResponse,\n  CreateEnvironmentVariableRequestBody,\n  CreateScheduleOptions,\n  CreateUploadPayloadUrlResponseBody,\n  DeletedScheduleObject,\n  EnvironmentVariableResponseBody,\n  EnvironmentVariableValue,\n  EnvironmentVariables,\n  ListRunResponseItem,\n  ListScheduleOptions,\n  ReplayRunResponse,\n  RescheduleRunRequestBody,\n  RetrieveRunResponse,\n  ScheduleObject,\n  TaskRunExecutionResult,\n  TriggerTaskRequestBody,\n  TriggerTaskResponse,\n  UpdateEnvironmentVariableRequestBody,\n  UpdateScheduleOptions,\n} from \"../schemas\";\nimport { taskContext } from \"../task-context-api\";\nimport {\n  ApiRequestOptions,\n  CursorPagePromise,\n  ZodFetchOptions,\n  isRequestOptions,\n  zodfetch,\n  zodfetchCursorPage,\n  zodfetchOffsetLimitPage,\n} from \"./core\";\nimport { ApiError } from \"./errors\";\nimport {\n  CreateEnvironmentVariableParams,\n  ImportEnvironmentVariablesParams,\n  ListProjectRunsQueryParams,\n  ListRunsQueryParams,\n  UpdateEnvironmentVariableParams,\n} from \"./types\";\n\nexport type {\n  CreateEnvironmentVariableParams,\n  ImportEnvironmentVariablesParams,\n  UpdateEnvironmentVariableParams,\n};\n\nexport type TriggerOptions = {\n  spanParentAsLink?: boolean;\n};\n\nconst DEFAULT_ZOD_FETCH_OPTIONS: ZodFetchOptions = {\n  retry: {\n    maxAttempts: 3,\n    minTimeoutInMs: 1000,\n    maxTimeoutInMs: 30_000,\n    factor: 2,\n    randomize: false,\n  },\n};\n\nexport { isRequestOptions };\nexport type { ApiRequestOptions };\n\n/**\n * Trigger.dev v3 API client\n */\nexport class ApiClient {\n  private readonly baseUrl: string;\n  private readonly defaultRequestOptions: ZodFetchOptions;\n\n  constructor(\n    baseUrl: string,\n    private readonly accessToken: string,\n    requestOptions: ApiRequestOptions = {}\n  ) {\n    this.baseUrl = baseUrl.replace(/\\/$/, \"\");\n    this.defaultRequestOptions = mergeRequestOptions(DEFAULT_ZOD_FETCH_OPTIONS, requestOptions);\n  }\n\n  async getRunResult(\n    runId: string,\n    requestOptions?: ZodFetchOptions\n  ): Promise<TaskRunExecutionResult | undefined> {\n    try {\n      return await zodfetch(\n        TaskRunExecutionResult,\n        `${this.baseUrl}/api/v1/runs/${runId}/result`,\n        {\n          method: \"GET\",\n          headers: this.#getHeaders(false),\n        },\n        mergeRequestOptions(this.defaultRequestOptions, requestOptions)\n      );\n    } catch (error) {\n      if (error instanceof ApiError) {\n        if (error.status === 404) {\n          return undefined;\n        }\n      }\n\n      throw error;\n    }\n  }\n\n  async getBatchResults(\n    batchId: string,\n    requestOptions?: ZodFetchOptions\n  ): Promise<BatchTaskRunExecutionResult | undefined> {\n    return await zodfetch(\n      BatchTaskRunExecutionResult,\n      `${this.baseUrl}/api/v1/batches/${batchId}/results`,\n      {\n        method: \"GET\",\n        headers: this.#getHeaders(false),\n      },\n      mergeRequestOptions(this.defaultRequestOptions, requestOptions)\n    );\n  }\n\n  triggerTask(\n    taskId: string,\n    body: TriggerTaskRequestBody,\n    options?: TriggerOptions,\n    requestOptions?: ZodFetchOptions\n  ) {\n    const encodedTaskId = encodeURIComponent(taskId);\n\n    return zodfetch(\n      TriggerTaskResponse,\n      `${this.baseUrl}/api/v1/tasks/${encodedTaskId}/trigger`,\n      {\n        method: \"POST\",\n        headers: this.#getHeaders(options?.spanParentAsLink ?? false),\n        body: JSON.stringify(body),\n      },\n      mergeRequestOptions(this.defaultRequestOptions, requestOptions)\n    );\n  }\n\n  batchTriggerTask(\n    taskId: string,\n    body: BatchTriggerTaskRequestBody,\n    options?: TriggerOptions,\n    requestOptions?: ZodFetchOptions\n  ) {\n    const encodedTaskId = encodeURIComponent(taskId);\n\n    return zodfetch(\n      BatchTriggerTaskResponse,\n      `${this.baseUrl}/api/v1/tasks/${encodedTaskId}/batch`,\n      {\n        method: \"POST\",\n        headers: this.#getHeaders(options?.spanParentAsLink ?? false),\n        body: JSON.stringify(body),\n      },\n      mergeRequestOptions(this.defaultRequestOptions, requestOptions)\n    );\n  }\n\n  createUploadPayloadUrl(filename: string, requestOptions?: ZodFetchOptions) {\n    return zodfetch(\n      CreateUploadPayloadUrlResponseBody,\n      `${this.baseUrl}/api/v1/packets/${filename}`,\n      {\n        method: \"PUT\",\n        headers: this.#getHeaders(false),\n      },\n      mergeRequestOptions(this.defaultRequestOptions, requestOptions)\n    );\n  }\n\n  getPayloadUrl(filename: string, requestOptions?: ZodFetchOptions) {\n    return zodfetch(\n      CreateUploadPayloadUrlResponseBody,\n      `${this.baseUrl}/api/v1/packets/${filename}`,\n      {\n        method: \"GET\",\n        headers: this.#getHeaders(false),\n      },\n      mergeRequestOptions(this.defaultRequestOptions, requestOptions)\n    );\n  }\n\n  retrieveRun(runId: string, requestOptions?: ZodFetchOptions) {\n    return zodfetch(\n      RetrieveRunResponse,\n      `${this.baseUrl}/api/v3/runs/${runId}`,\n      {\n        method: \"GET\",\n        headers: this.#getHeaders(false),\n      },\n      mergeRequestOptions(this.defaultRequestOptions, requestOptions)\n    );\n  }\n\n  listRuns(\n    query?: ListRunsQueryParams,\n    requestOptions?: ZodFetchOptions\n  ): CursorPagePromise<typeof ListRunResponseItem> {\n    const searchParams = createSearchQueryForListRuns(query);\n\n    return zodfetchCursorPage(\n      ListRunResponseItem,\n      `${this.baseUrl}/api/v1/runs`,\n      {\n        query: searchParams,\n        limit: query?.limit,\n        after: query?.after,\n        before: query?.before,\n      },\n      {\n        method: \"GET\",\n        headers: this.#getHeaders(false),\n      },\n      mergeRequestOptions(this.defaultRequestOptions, requestOptions)\n    );\n  }\n\n  listProjectRuns(\n    projectRef: string,\n    query?: ListProjectRunsQueryParams,\n    requestOptions?: ZodFetchOptions\n  ): CursorPagePromise<typeof ListRunResponseItem> {\n    const searchParams = createSearchQueryForListRuns(query);\n\n    if (query?.env) {\n      searchParams.append(\n        \"filter[env]\",\n        Array.isArray(query.env) ? query.env.join(\",\") : query.env\n      );\n    }\n\n    return zodfetchCursorPage(\n      ListRunResponseItem,\n      `${this.baseUrl}/api/v1/projects/${projectRef}/runs`,\n      {\n        query: searchParams,\n        limit: query?.limit,\n        after: query?.after,\n        before: query?.before,\n      },\n      {\n        method: \"GET\",\n        headers: this.#getHeaders(false),\n      },\n      mergeRequestOptions(this.defaultRequestOptions, requestOptions)\n    );\n  }\n\n  replayRun(runId: string, requestOptions?: ZodFetchOptions) {\n    return zodfetch(\n      ReplayRunResponse,\n      `${this.baseUrl}/api/v1/runs/${runId}/replay`,\n      {\n        method: \"POST\",\n        headers: this.#getHeaders(false),\n      },\n      mergeRequestOptions(this.defaultRequestOptions, requestOptions)\n    );\n  }\n\n  cancelRun(runId: string, requestOptions?: ZodFetchOptions) {\n    return zodfetch(\n      CanceledRunResponse,\n      `${this.baseUrl}/api/v2/runs/${runId}/cancel`,\n      {\n        method: \"POST\",\n        headers: this.#getHeaders(false),\n      },\n      mergeRequestOptions(this.defaultRequestOptions, requestOptions)\n    );\n  }\n\n  rescheduleRun(runId: string, body: RescheduleRunRequestBody, requestOptions?: ZodFetchOptions) {\n    return zodfetch(\n      RetrieveRunResponse,\n      `${this.baseUrl}/api/v1/runs/${runId}/reschedule`,\n      {\n        method: \"POST\",\n        headers: this.#getHeaders(false),\n        body: JSON.stringify(body),\n      },\n      mergeRequestOptions(this.defaultRequestOptions, requestOptions)\n    );\n  }\n\n  addTags(runId: string, body: AddTagsRequestBody, requestOptions?: ZodFetchOptions) {\n    return zodfetch(\n      z.object({ message: z.string() }),\n      `${this.baseUrl}/api/v1/runs/${runId}/tags`,\n      {\n        method: \"POST\",\n        headers: this.#getHeaders(false),\n        body: JSON.stringify(body),\n      },\n      mergeRequestOptions(this.defaultRequestOptions, requestOptions)\n    );\n  }\n\n  createSchedule(options: CreateScheduleOptions, requestOptions?: ZodFetchOptions) {\n    return zodfetch(\n      ScheduleObject,\n      `${this.baseUrl}/api/v1/schedules`,\n      {\n        method: \"POST\",\n        headers: this.#getHeaders(false),\n        body: JSON.stringify(options),\n      },\n      mergeRequestOptions(this.defaultRequestOptions, requestOptions)\n    );\n  }\n\n  listSchedules(options?: ListScheduleOptions, requestOptions?: ZodFetchOptions) {\n    const searchParams = new URLSearchParams();\n\n    if (options?.page) {\n      searchParams.append(\"page\", options.page.toString());\n    }\n\n    if (options?.perPage) {\n      searchParams.append(\"perPage\", options.perPage.toString());\n    }\n\n    return zodfetchOffsetLimitPage(\n      ScheduleObject,\n      `${this.baseUrl}/api/v1/schedules`,\n      {\n        page: options?.page,\n        limit: options?.perPage,\n      },\n      {\n        method: \"GET\",\n        headers: this.#getHeaders(false),\n      },\n      mergeRequestOptions(this.defaultRequestOptions, requestOptions)\n    );\n  }\n\n  retrieveSchedule(scheduleId: string, requestOptions?: ZodFetchOptions) {\n    return zodfetch(\n      ScheduleObject,\n      `${this.baseUrl}/api/v1/schedules/${scheduleId}`,\n      {\n        method: \"GET\",\n        headers: this.#getHeaders(false),\n      },\n      mergeRequestOptions(this.defaultRequestOptions, requestOptions)\n    );\n  }\n\n  updateSchedule(\n    scheduleId: string,\n    options: UpdateScheduleOptions,\n    requestOptions?: ZodFetchOptions\n  ) {\n    return zodfetch(\n      ScheduleObject,\n      `${this.baseUrl}/api/v1/schedules/${scheduleId}`,\n      {\n        method: \"PUT\",\n        headers: this.#getHeaders(false),\n        body: JSON.stringify(options),\n      },\n      mergeRequestOptions(this.defaultRequestOptions, requestOptions)\n    );\n  }\n\n  deactivateSchedule(scheduleId: string, requestOptions?: ZodFetchOptions) {\n    return zodfetch(\n      ScheduleObject,\n      `${this.baseUrl}/api/v1/schedules/${scheduleId}/deactivate`,\n      {\n        method: \"POST\",\n        headers: this.#getHeaders(false),\n      },\n      mergeRequestOptions(this.defaultRequestOptions, requestOptions)\n    );\n  }\n\n  activateSchedule(scheduleId: string, requestOptions?: ZodFetchOptions) {\n    return zodfetch(\n      ScheduleObject,\n      `${this.baseUrl}/api/v1/schedules/${scheduleId}/activate`,\n      {\n        method: \"POST\",\n        headers: this.#getHeaders(false),\n      },\n      mergeRequestOptions(this.defaultRequestOptions, requestOptions)\n    );\n  }\n\n  deleteSchedule(scheduleId: string, requestOptions?: ZodFetchOptions) {\n    return zodfetch(\n      DeletedScheduleObject,\n      `${this.baseUrl}/api/v1/schedules/${scheduleId}`,\n      {\n        method: \"DELETE\",\n        headers: this.#getHeaders(false),\n      },\n      mergeRequestOptions(this.defaultRequestOptions, requestOptions)\n    );\n  }\n\n  listEnvVars(projectRef: string, slug: string, requestOptions?: ZodFetchOptions) {\n    return zodfetch(\n      EnvironmentVariables,\n      `${this.baseUrl}/api/v1/projects/${projectRef}/envvars/${slug}`,\n      {\n        method: \"GET\",\n        headers: this.#getHeaders(false),\n      },\n      mergeRequestOptions(this.defaultRequestOptions, requestOptions)\n    );\n  }\n\n  importEnvVars(\n    projectRef: string,\n    slug: string,\n    body: ImportEnvironmentVariablesParams,\n    requestOptions?: ZodFetchOptions\n  ) {\n    return zodfetch(\n      EnvironmentVariableResponseBody,\n      `${this.baseUrl}/api/v1/projects/${projectRef}/envvars/${slug}/import`,\n      {\n        method: \"POST\",\n        headers: this.#getHeaders(false),\n        body: JSON.stringify(body),\n      },\n      mergeRequestOptions(this.defaultRequestOptions, requestOptions)\n    );\n  }\n\n  retrieveEnvVar(projectRef: string, slug: string, key: string, requestOptions?: ZodFetchOptions) {\n    return zodfetch(\n      EnvironmentVariableValue,\n      `${this.baseUrl}/api/v1/projects/${projectRef}/envvars/${slug}/${key}`,\n      {\n        method: \"GET\",\n        headers: this.#getHeaders(false),\n      },\n      mergeRequestOptions(this.defaultRequestOptions, requestOptions)\n    );\n  }\n\n  createEnvVar(\n    projectRef: string,\n    slug: string,\n    body: CreateEnvironmentVariableRequestBody,\n    requestOptions?: ZodFetchOptions\n  ) {\n    return zodfetch(\n      EnvironmentVariableResponseBody,\n      `${this.baseUrl}/api/v1/projects/${projectRef}/envvars/${slug}`,\n      {\n        method: \"POST\",\n        headers: this.#getHeaders(false),\n        body: JSON.stringify(body),\n      },\n      mergeRequestOptions(this.defaultRequestOptions, requestOptions)\n    );\n  }\n\n  updateEnvVar(\n    projectRef: string,\n    slug: string,\n    key: string,\n    body: UpdateEnvironmentVariableRequestBody,\n    requestOptions?: ZodFetchOptions\n  ) {\n    return zodfetch(\n      EnvironmentVariableResponseBody,\n      `${this.baseUrl}/api/v1/projects/${projectRef}/envvars/${slug}/${key}`,\n      {\n        method: \"PUT\",\n        headers: this.#getHeaders(false),\n        body: JSON.stringify(body),\n      },\n      mergeRequestOptions(this.defaultRequestOptions, requestOptions)\n    );\n  }\n\n  deleteEnvVar(projectRef: string, slug: string, key: string, requestOptions?: ZodFetchOptions) {\n    return zodfetch(\n      EnvironmentVariableResponseBody,\n      `${this.baseUrl}/api/v1/projects/${projectRef}/envvars/${slug}/${key}`,\n      {\n        method: \"DELETE\",\n        headers: this.#getHeaders(false),\n      },\n      mergeRequestOptions(this.defaultRequestOptions, requestOptions)\n    );\n  }\n\n  #getHeaders(spanParentAsLink: boolean) {\n    const headers: Record<string, string> = {\n      \"Content-Type\": \"application/json\",\n      Authorization: `Bearer ${this.accessToken}`,\n      \"trigger-version\": version,\n    };\n\n    // Only inject the context if we are inside a task\n    if (taskContext.isInsideTask) {\n      headers[\"x-trigger-worker\"] = \"true\";\n      propagation.inject(context.active(), headers);\n\n      if (spanParentAsLink) {\n        headers[\"x-trigger-span-parent-as-link\"] = \"1\";\n      }\n    }\n\n    return headers;\n  }\n}\n\nfunction createSearchQueryForListRuns(query?: ListRunsQueryParams): URLSearchParams {\n  const searchParams = new URLSearchParams();\n\n  if (query) {\n    if (query.status) {\n      searchParams.append(\n        \"filter[status]\",\n        Array.isArray(query.status) ? query.status.join(\",\") : query.status\n      );\n    }\n\n    if (query.taskIdentifier) {\n      searchParams.append(\n        \"filter[taskIdentifier]\",\n        Array.isArray(query.taskIdentifier) ? query.taskIdentifier.join(\",\") : query.taskIdentifier\n      );\n    }\n\n    if (query.version) {\n      searchParams.append(\n        \"filter[version]\",\n        Array.isArray(query.version) ? query.version.join(\",\") : query.version\n      );\n    }\n\n    if (query.bulkAction) {\n      searchParams.append(\"filter[bulkAction]\", query.bulkAction);\n    }\n\n    if (query.tag) {\n      searchParams.append(\n        \"filter[tag]\",\n        Array.isArray(query.tag) ? query.tag.join(\",\") : query.tag\n      );\n    }\n\n    if (query.schedule) {\n      searchParams.append(\"filter[schedule]\", query.schedule);\n    }\n\n    if (typeof query.isTest === \"boolean\") {\n      searchParams.append(\"filter[isTest]\", String(query.isTest));\n    }\n\n    if (query.from) {\n      searchParams.append(\n        \"filter[createdAt][from]\",\n        query.from instanceof Date ? query.from.getTime().toString() : query.from.toString()\n      );\n    }\n\n    if (query.to) {\n      searchParams.append(\n        \"filter[createdAt][to]\",\n        query.to instanceof Date ? query.to.getTime().toString() : query.to.toString()\n      );\n    }\n\n    if (query.period) {\n      searchParams.append(\"filter[createdAt][period]\", query.period);\n    }\n  }\n\n  return searchParams;\n}\n\nexport function mergeRequestOptions(\n  defaultOptions: ZodFetchOptions,\n  options?: ApiRequestOptions\n): ZodFetchOptions {\n  if (!options) {\n    return defaultOptions;\n  }\n\n  return {\n    ...defaultOptions,\n    ...options,\n    retry: {\n      ...defaultOptions.retry,\n      ...options.retry,\n    },\n  };\n}\n", "import { z } from \"zod\";\nimport { fromZodError } from \"zod-validation-error\";\nimport { RetryOptions } from \"../schemas\";\nimport { calculateNextRetryDelay } from \"../utils/retries\";\nimport { ApiConnectionError, ApiError } from \"./errors\";\n\nimport { Attributes, Span } from \"@opentelemetry/api\";\nimport { SemanticInternalAttributes } from \"../semanticInternalAttributes\";\nimport { TriggerTracer } from \"../tracer\";\nimport { accessoryAttributes } from \"../utils/styleAttributes\";\nimport {\n  CursorPage,\n  CursorPageParams,\n  CursorPageResponse,\n  OffsetLimitPage,\n  OffsetLimitPageParams,\n  OffsetLimitPageResponse,\n} from \"./pagination\";\n\nexport const defaultRetryOptions = {\n  maxAttempts: 3,\n  factor: 2,\n  minTimeoutInMs: 1000,\n  maxTimeoutInMs: 60000,\n  randomize: false,\n} satisfies RetryOptions;\n\nexport type ZodFetchOptions = {\n  retry?: RetryOptions;\n  tracer?: TriggerTracer;\n  name?: string;\n  attributes?: Attributes;\n  icon?: string;\n  onResponseBody?: (body: unknown, span: Span) => void;\n};\n\nexport type ApiRequestOptions = Pick<ZodFetchOptions, \"retry\">;\ntype KeysEnum<T> = { [P in keyof Required<T>]: true };\n\n// This is required so that we can determine if a given object matches the ApiRequestOptions\n// type at runtime. While this requires duplication, it is enforced by the TypeScript\n// compiler such that any missing / extraneous keys will cause an error.\nconst requestOptionsKeys: KeysEnum<ApiRequestOptions> = {\n  retry: true,\n};\n\nexport const isRequestOptions = (obj: unknown): obj is ApiRequestOptions => {\n  return (\n    typeof obj === \"object\" &&\n    obj !== null &&\n    !isEmptyObj(obj) &&\n    Object.keys(obj).every((k) => hasOwn(requestOptionsKeys, k))\n  );\n};\n\ninterface FetchCursorPageParams extends CursorPageParams {\n  query?: URLSearchParams;\n}\n\ninterface FetchOffsetLimitPageParams extends OffsetLimitPageParams {\n  query?: URLSearchParams;\n}\n\nexport function zodfetch<TResponseBodySchema extends z.ZodTypeAny>(\n  schema: TResponseBodySchema,\n  url: string,\n  requestInit?: RequestInit,\n  options?: ZodFetchOptions\n): ApiPromise<z.output<TResponseBodySchema>> {\n  return new ApiPromise(_doZodFetch(schema, url, requestInit, options));\n}\n\nexport function zodfetchCursorPage<TItemSchema extends z.ZodTypeAny>(\n  schema: TItemSchema,\n  url: string,\n  params: FetchCursorPageParams,\n  requestInit?: RequestInit,\n  options?: ZodFetchOptions\n) {\n  const query = new URLSearchParams(params.query);\n\n  if (params.limit) {\n    query.set(\"page[size]\", String(params.limit));\n  }\n\n  if (params.after) {\n    query.set(\"page[after]\", params.after);\n  }\n\n  if (params.before) {\n    query.set(\"page[before]\", params.before);\n  }\n\n  const cursorPageSchema = z.object({\n    data: z.array(schema),\n    pagination: z.object({\n      next: z.string().optional(),\n      previous: z.string().optional(),\n    }),\n  });\n\n  const $url = new URL(url);\n  $url.search = query.toString();\n\n  const fetchResult = _doZodFetch(cursorPageSchema, $url.href, requestInit, options);\n\n  return new CursorPagePromise(fetchResult, schema, url, params, requestInit, options);\n}\n\nexport function zodfetchOffsetLimitPage<TItemSchema extends z.ZodTypeAny>(\n  schema: TItemSchema,\n  url: string,\n  params: FetchOffsetLimitPageParams,\n  requestInit?: RequestInit,\n  options?: ZodFetchOptions\n) {\n  const query = new URLSearchParams(params.query);\n\n  if (params.limit) {\n    query.set(\"perPage\", String(params.limit));\n  }\n\n  if (params.page) {\n    query.set(\"page\", String(params.page));\n  }\n\n  const offsetLimitPageSchema = z.object({\n    data: z.array(schema),\n    pagination: z.object({\n      currentPage: z.coerce.number(),\n      totalPages: z.coerce.number(),\n      count: z.coerce.number(),\n    }),\n  });\n\n  const $url = new URL(url);\n  $url.search = query.toString();\n\n  const fetchResult = _doZodFetch(offsetLimitPageSchema, $url.href, requestInit, options);\n\n  return new OffsetLimitPagePromise(fetchResult, schema, url, params, requestInit, options);\n}\n\ntype ZodFetchResult<T> = {\n  data: T;\n  response: Response;\n};\n\ntype PromiseOrValue<T> = T | Promise<T>;\n\nasync function traceZodFetch<T>(\n  params: {\n    url: string;\n    requestInit?: RequestInit;\n    options?: ZodFetchOptions;\n  },\n  callback: (span?: Span) => Promise<T>\n): Promise<T> {\n  if (!params.options?.tracer) {\n    return callback();\n  }\n\n  const url = new URL(params.url);\n  const method = params.requestInit?.method ?? \"GET\";\n  const name = params.options.name ?? `${method} ${url.pathname}`;\n\n  return await params.options.tracer.startActiveSpan(\n    name,\n    async (span) => {\n      return await callback(span);\n    },\n    {\n      attributes: {\n        [SemanticInternalAttributes.STYLE_ICON]: params.options?.icon ?? \"api\",\n        ...params.options.attributes,\n      },\n    }\n  );\n}\n\nasync function _doZodFetch<TResponseBodySchema extends z.ZodTypeAny>(\n  schema: TResponseBodySchema,\n  url: string,\n  requestInit?: PromiseOrValue<RequestInit>,\n  options?: ZodFetchOptions\n): Promise<ZodFetchResult<z.output<TResponseBodySchema>>> {\n  const $requestInit = await requestInit;\n\n  return traceZodFetch({ url, requestInit: $requestInit, options }, async (span) => {\n    const result = await _doZodFetchWithRetries(schema, url, $requestInit, options);\n\n    if (options?.onResponseBody && span) {\n      options.onResponseBody(result.data, span);\n    }\n\n    return result;\n  });\n}\n\nasync function _doZodFetchWithRetries<TResponseBodySchema extends z.ZodTypeAny>(\n  schema: TResponseBodySchema,\n  url: string,\n  requestInit?: RequestInit,\n  options?: ZodFetchOptions,\n  attempt = 1\n): Promise<ZodFetchResult<z.output<TResponseBodySchema>>> {\n  try {\n    const response = await fetch(url, requestInitWithCache(requestInit));\n\n    const responseHeaders = createResponseHeaders(response.headers);\n\n    if (!response.ok) {\n      const retryResult = shouldRetry(response, attempt, options?.retry);\n\n      if (retryResult.retry) {\n        await waitForRetry(url, attempt + 1, retryResult.delay, options, requestInit, response);\n\n        return await _doZodFetchWithRetries(schema, url, requestInit, options, attempt + 1);\n      } else {\n        const errText = await response.text().catch((e) => castToError(e).message);\n        const errJSON = safeJsonParse(errText);\n        const errMessage = errJSON ? undefined : errText;\n\n        throw ApiError.generate(response.status, errJSON, errMessage, responseHeaders);\n      }\n    }\n\n    const jsonBody = await response.json();\n    const parsedResult = schema.safeParse(jsonBody);\n\n    if (parsedResult.success) {\n      return { data: parsedResult.data, response };\n    }\n\n    throw fromZodError(parsedResult.error);\n  } catch (error) {\n    if (error instanceof ApiError) {\n      throw error;\n    }\n\n    if (options?.retry) {\n      const retry = { ...defaultRetryOptions, ...options.retry };\n\n      const delay = calculateNextRetryDelay(retry, attempt);\n\n      if (delay) {\n        await waitForRetry(url, attempt + 1, delay, options, requestInit);\n\n        return await _doZodFetchWithRetries(schema, url, requestInit, options, attempt + 1);\n      }\n    }\n\n    throw new ApiConnectionError({ cause: castToError(error) });\n  }\n}\n\nfunction castToError(err: any): Error {\n  if (err instanceof Error) return err;\n  return new Error(err);\n}\n\ntype ShouldRetryResult =\n  | {\n      retry: false;\n    }\n  | {\n      retry: true;\n      delay: number;\n    };\n\nfunction shouldRetry(\n  response: Response,\n  attempt: number,\n  retryOptions?: RetryOptions\n): ShouldRetryResult {\n  function shouldRetryForOptions(): ShouldRetryResult {\n    const retry = { ...defaultRetryOptions, ...retryOptions };\n\n    const delay = calculateNextRetryDelay(retry, attempt);\n\n    if (delay) {\n      return { retry: true, delay };\n    } else {\n      return { retry: false };\n    }\n  }\n\n  // Note this is not a standard header.\n  const shouldRetryHeader = response.headers.get(\"x-should-retry\");\n\n  // If the server explicitly says whether or not to retry, obey.\n  if (shouldRetryHeader === \"true\") return shouldRetryForOptions();\n  if (shouldRetryHeader === \"false\") return { retry: false };\n\n  // Retry on request timeouts.\n  if (response.status === 408) return shouldRetryForOptions();\n\n  // Retry on lock timeouts.\n  if (response.status === 409) return shouldRetryForOptions();\n\n  // Retry on rate limits.\n  if (response.status === 429) {\n    if (\n      attempt >= (typeof retryOptions?.maxAttempts === \"number\" ? retryOptions?.maxAttempts : 3)\n    ) {\n      return { retry: false };\n    }\n\n    // x-ratelimit-reset is the unix timestamp in milliseconds when the rate limit will reset.\n    const resetAtUnixEpochMs = response.headers.get(\"x-ratelimit-reset\");\n\n    if (resetAtUnixEpochMs) {\n      const resetAtUnixEpoch = parseInt(resetAtUnixEpochMs, 10);\n      const delay = resetAtUnixEpoch - Date.now() + Math.floor(Math.random() * 1000);\n\n      if (delay > 0) {\n        return { retry: true, delay };\n      }\n    }\n\n    return shouldRetryForOptions();\n  }\n\n  // Retry internal errors.\n  if (response.status >= 500) return shouldRetryForOptions();\n\n  return { retry: false };\n}\n\nfunction safeJsonParse(text: string): any {\n  try {\n    return JSON.parse(text);\n  } catch (e) {\n    return undefined;\n  }\n}\n\nfunction createResponseHeaders(headers: Response[\"headers\"]): Record<string, string> {\n  return new Proxy(\n    Object.fromEntries(\n      // @ts-ignore\n      headers.entries()\n    ),\n    {\n      get(target, name) {\n        const key = name.toString();\n        return target[key.toLowerCase()] || target[key];\n      },\n    }\n  );\n}\n\nfunction requestInitWithCache(requestInit?: RequestInit): RequestInit {\n  try {\n    const withCache: RequestInit = {\n      ...requestInit,\n      cache: \"no-cache\",\n    };\n\n    const _ = new Request(\"http://localhost\", withCache);\n\n    return withCache;\n  } catch (error) {\n    return requestInit ?? {};\n  }\n}\n\n/**\n * A subclass of `Promise` providing additional helper methods\n * for interacting with the SDK.\n */\nexport class ApiPromise<T> extends Promise<T> {\n  constructor(private responsePromise: Promise<ZodFetchResult<T>>) {\n    super((resolve) => {\n      // this is maybe a bit weird but this has to be a no-op to not implicitly\n      // parse the response body; instead .then, .catch, .finally are overridden\n      // to parse the response\n      resolve(null as any);\n    });\n  }\n\n  /**\n   * Gets the raw `Response` instance instead of parsing the response\n   * data.\n   *\n   * If you want to parse the response body but still get the `Response`\n   * instance, you can use {@link withResponse()}.\n   */\n  asResponse(): Promise<Response> {\n    return this.responsePromise.then((p) => p.response);\n  }\n\n  /**\n   * Gets the parsed response data and the raw `Response` instance.\n   *\n   * If you just want to get the raw `Response` instance without parsing it,\n   * you can use {@link asResponse()}.\n   */\n  async withResponse(): Promise<{ data: T; response: Response }> {\n    const [data, response] = await Promise.all([this.parse(), this.asResponse()]);\n    return { data, response };\n  }\n\n  private parse(): Promise<T> {\n    return this.responsePromise.then((result) => result.data);\n  }\n\n  override then<TResult1 = T, TResult2 = never>(\n    onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,\n    onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null\n  ): Promise<TResult1 | TResult2> {\n    return this.parse().then(onfulfilled, onrejected);\n  }\n\n  override catch<TResult = never>(\n    onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null\n  ): Promise<T | TResult> {\n    return this.parse().catch(onrejected);\n  }\n\n  override finally(onfinally?: (() => void) | undefined | null): Promise<T> {\n    return this.parse().finally(onfinally);\n  }\n}\n\nexport class CursorPagePromise<TItemSchema extends z.ZodTypeAny>\n  extends ApiPromise<CursorPage<z.output<TItemSchema>>>\n  implements AsyncIterable<z.output<TItemSchema>>\n{\n  constructor(\n    result: Promise<ZodFetchResult<CursorPageResponse<z.output<TItemSchema>>>>,\n    private schema: TItemSchema,\n    private url: string,\n    private params: FetchCursorPageParams,\n    private requestInit?: RequestInit,\n    private options?: ZodFetchOptions\n  ) {\n    super(\n      result.then((result) => ({\n        data: new CursorPage(result.data.data, result.data.pagination, this.#fetchPage.bind(this)),\n        response: result.response,\n      }))\n    );\n  }\n\n  #fetchPage(params: Omit<CursorPageParams, \"limit\">): Promise<CursorPage<z.output<TItemSchema>>> {\n    return zodfetchCursorPage(\n      this.schema,\n      this.url,\n      { ...this.params, ...params },\n      this.requestInit,\n      this.options\n    );\n  }\n\n  /**\n   * Allow auto-paginating iteration on an unawaited list call, eg:\n   *\n   *    for await (const item of client.items.list()) {\n   *      console.log(item)\n   *    }\n   */\n  async *[Symbol.asyncIterator]() {\n    const page = await this;\n    for await (const item of page) {\n      yield item;\n    }\n  }\n}\n\nexport class OffsetLimitPagePromise<TItemSchema extends z.ZodTypeAny>\n  extends ApiPromise<OffsetLimitPage<z.output<TItemSchema>>>\n  implements AsyncIterable<z.output<TItemSchema>>\n{\n  constructor(\n    result: Promise<ZodFetchResult<OffsetLimitPageResponse<z.output<TItemSchema>>>>,\n    private schema: TItemSchema,\n    private url: string,\n    private params: FetchOffsetLimitPageParams,\n    private requestInit?: RequestInit,\n    private options?: ZodFetchOptions\n  ) {\n    super(\n      result.then((result) => ({\n        data: new OffsetLimitPage(\n          result.data.data,\n          result.data.pagination,\n          this.#fetchPage.bind(this)\n        ),\n        response: result.response,\n      }))\n    );\n  }\n\n  #fetchPage(\n    params: Omit<FetchOffsetLimitPageParams, \"limit\">\n  ): Promise<OffsetLimitPage<z.output<TItemSchema>>> {\n    return zodfetchOffsetLimitPage(\n      this.schema,\n      this.url,\n      { ...this.params, ...params },\n      this.requestInit,\n      this.options\n    );\n  }\n\n  /**\n   * Allow auto-paginating iteration on an unawaited list call, eg:\n   *\n   *    for await (const item of client.items.list()) {\n   *      console.log(item)\n   *    }\n   */\n  async *[Symbol.asyncIterator]() {\n    const page = await this;\n    for await (const item of page) {\n      yield item;\n    }\n  }\n}\n\nasync function waitForRetry(\n  url: string,\n  attempt: number,\n  delay: number,\n  options?: ZodFetchOptions,\n  requestInit?: RequestInit,\n  response?: Response\n): Promise<void> {\n  if (options?.tracer) {\n    const method = requestInit?.method ?? \"GET\";\n\n    return options.tracer.startActiveSpan(\n      response ? `wait after ${response.status}` : `wait after error`,\n      async (span) => {\n        await new Promise((resolve) => setTimeout(resolve, delay));\n      },\n      {\n        attributes: {\n          [SemanticInternalAttributes.STYLE_ICON]: \"wait\",\n          ...accessoryAttributes({\n            items: [\n              {\n                text: `retrying ${options?.name ?? method.toUpperCase()} in ${delay}ms`,\n                variant: \"normal\",\n              },\n            ],\n            style: \"codepath\",\n          }),\n        },\n      }\n    );\n  }\n\n  await new Promise((resolve) => setTimeout(resolve, delay));\n}\n\n// https://stackoverflow.com/a/34491287\nexport function isEmptyObj(obj: Object | null | undefined): boolean {\n  if (!obj) return true;\n  for (const _k in obj) return false;\n  return true;\n}\n\n// https://eslint.org/docs/latest/rules/no-prototype-builtins\nexport function hasOwn(obj: Object, key: string): boolean {\n  return Object.prototype.hasOwnProperty.call(obj, key);\n}\n", "import { calculateResetAt as calculateResetAtInternal } from \"../../retry\";\nimport { FetchRetryOptions, type RetryOptions } from \"../schemas\";\n\nexport const defaultRetryOptions = {\n  maxAttempts: 3,\n  factor: 2,\n  minTimeoutInMs: 1000,\n  maxTimeoutInMs: 60000,\n  randomize: true,\n} satisfies RetryOptions;\n\nexport const defaultFetchRetryOptions = {\n  byStatus: {\n    \"429,408,409,5xx\": {\n      strategy: \"backoff\",\n      ...defaultRetryOptions,\n    },\n  },\n  connectionError: defaultRetryOptions,\n  timeout: defaultRetryOptions,\n} satisfies FetchRetryOptions;\n\n/**\n *\n * @param options\n * @param attempt - The current attempt number. If the first attempt has failed, this will be 1.\n * @returns\n */\nexport function calculateNextRetryDelay(options: RetryOptions, attempt: number) {\n  const opts = { ...defaultRetryOptions, ...options };\n\n  if (attempt >= opts.maxAttempts) {\n    return;\n  }\n\n  const { factor, minTimeoutInMs, maxTimeoutInMs, randomize } = opts;\n\n  const random = randomize ? Math.random() + 1 : 1;\n\n  const timeout = Math.min(maxTimeoutInMs, random * minTimeoutInMs * Math.pow(factor, attempt - 1));\n\n  // Round to the nearest integer\n  return Math.round(timeout);\n}\n\nexport function calculateResetAt(\n  resets: string | undefined | null,\n  format:\n    | \"unix_timestamp\"\n    | \"iso_8601\"\n    | \"iso_8601_duration_openai_variant\"\n    | \"unix_timestamp_in_ms\",\n  now: number = Date.now()\n): number | undefined {\n  const resetAt = calculateResetAtInternal(resets, format, new Date(now));\n\n  return resetAt?.getTime();\n}\n", "export type APIHeaders = Record<string, string | null | undefined>;\n\nexport class ApiError extends Error {\n  readonly status: number | undefined;\n  readonly headers: APIHeaders | undefined;\n  readonly error: Object | undefined;\n\n  readonly code: string | null | undefined;\n  readonly param: string | null | undefined;\n  readonly type: string | undefined;\n\n  constructor(\n    status: number | undefined,\n    error: Object | undefined,\n    message: string | undefined,\n    headers: APIHeaders | undefined\n  ) {\n    super(`${ApiError.makeMessage(status, error, message)}`);\n    this.name = \"TriggerApiError\";\n    this.status = status;\n    this.headers = headers;\n\n    const data = error as Record<string, any>;\n    this.error = data;\n    this.code = data?.[\"code\"];\n    this.param = data?.[\"param\"];\n    this.type = data?.[\"type\"];\n  }\n\n  private static makeMessage(status: number | undefined, error: any, message: string | undefined) {\n    const msg = error?.message\n      ? typeof error.message === \"string\"\n        ? error.message\n        : JSON.stringify(error.message)\n      : error\n      ? JSON.stringify(error)\n      : message;\n\n    if (status && msg) {\n      return `${status} ${msg}`;\n    }\n    if (status) {\n      return `${status} status code (no body)`;\n    }\n    if (msg) {\n      return msg;\n    }\n    return \"(no status code or body)\";\n  }\n\n  static generate(\n    status: number | undefined,\n    errorResponse: Object | undefined,\n    message: string | undefined,\n    headers: APIHeaders | undefined\n  ) {\n    if (!status) {\n      return new ApiConnectionError({ cause: castToError(errorResponse) });\n    }\n\n    const error = (errorResponse as Record<string, any>)?.[\"error\"];\n\n    if (status === 400) {\n      return new BadRequestError(status, error, message, headers);\n    }\n\n    if (status === 401) {\n      return new AuthenticationError(status, error, message, headers);\n    }\n\n    if (status === 403) {\n      return new PermissionDeniedError(status, error, message, headers);\n    }\n\n    if (status === 404) {\n      return new NotFoundError(status, error, message, headers);\n    }\n\n    if (status === 409) {\n      return new ConflictError(status, error, message, headers);\n    }\n\n    if (status === 422) {\n      return new UnprocessableEntityError(status, error, message, headers);\n    }\n\n    if (status === 429) {\n      return new RateLimitError(status, error, message, headers);\n    }\n\n    if (status >= 500) {\n      return new InternalServerError(status, error, message, headers);\n    }\n\n    return new ApiError(status, error, message, headers);\n  }\n}\n\nexport class ApiConnectionError extends ApiError {\n  override readonly status: undefined = undefined;\n\n  constructor({ message, cause }: { message?: string; cause?: Error | undefined }) {\n    super(undefined, undefined, message || \"Connection error.\", undefined);\n    // in some environments the 'cause' property is already declared\n    // @ts-ignore\n    if (cause) this.cause = cause;\n  }\n}\n\nexport class BadRequestError extends ApiError {\n  override readonly status: 400 = 400;\n}\n\nexport class AuthenticationError extends ApiError {\n  override readonly status: 401 = 401;\n}\n\nexport class PermissionDeniedError extends ApiError {\n  override readonly status: 403 = 403;\n}\n\nexport class NotFoundError extends ApiError {\n  override readonly status: 404 = 404;\n}\n\nexport class ConflictError extends ApiError {\n  override readonly status: 409 = 409;\n}\n\nexport class UnprocessableEntityError extends ApiError {\n  override readonly status: 422 = 422;\n}\n\nexport class RateLimitError extends ApiError {\n  override readonly status: 429 = 429;\n\n  get millisecondsUntilReset(): number | undefined {\n    // x-ratelimit-reset is the unix timestamp in milliseconds when the rate limit will reset.\n    const resetAtUnixEpochMs = (this.headers ?? {})[\"x-ratelimit-reset\"];\n\n    if (typeof resetAtUnixEpochMs === \"string\") {\n      const resetAtUnixEpoch = parseInt(resetAtUnixEpochMs, 10);\n\n      if (isNaN(resetAtUnixEpoch)) {\n        return;\n      }\n\n      // Add between 0 and 2000ms to the reset time to add jitter\n      return Math.max(resetAtUnixEpoch - Date.now() + Math.floor(Math.random() * 2000), 0);\n    }\n  }\n}\n\nexport class InternalServerError extends ApiError {}\n\nfunction castToError(err: any): Error {\n  if (err instanceof Error) return err;\n  return new Error(err);\n}\n", "import { Attributes } from \"@opentelemetry/api\";\nimport { Accessory } from \"../schemas\";\nimport { flattenAttributes } from \"./flattenAttributes\";\nimport { SemanticInternalAttributes } from \"../semanticInternalAttributes\";\n\nexport function accessoryAttributes(accessory: Accessory): Attributes {\n  return flattenAttributes(accessory, SemanticInternalAttributes.STYLE_ACCESSORY);\n}\n", "export interface CursorPageParams {\n  limit?: number;\n  after?: string;\n  before?: string;\n}\n\nexport interface OffsetLimitPageParams {\n  limit?: number;\n  page?: number;\n}\n\nexport interface PageResponse<Item> {\n  data: Array<Item>;\n}\n\nexport interface CursorPageResponse<Item> extends PageResponse<Item> {\n  pagination: {\n    next?: string;\n    previous?: string;\n  };\n}\n\nexport interface OffsetLimitPageResponse<Item> extends PageResponse<Item> {\n  pagination: {\n    currentPage: number;\n    totalPages: number;\n    count: number;\n  };\n}\n\nexport interface Page<Item> {\n  getPaginatedItems(): Item[];\n  hasNextPage(): boolean;\n  hasPreviousPage(): boolean;\n}\n\nexport class CursorPage<Item> implements CursorPageResponse<Item>, Page<Item>, AsyncIterable<Item> {\n  data: Array<Item>;\n  pagination: { next?: string; previous?: string };\n\n  constructor(\n    data: Array<Item>,\n    pagination: { next?: string; previous?: string },\n    private pageFetcher: (params: Omit<CursorPageParams, \"limit\">) => Promise<CursorPage<Item>>\n  ) {\n    this.data = data;\n    this.pagination = pagination;\n  }\n\n  getPaginatedItems(): Item[] {\n    return this.data ?? [];\n  }\n\n  hasNextPage(): boolean {\n    return !!this.pagination.next;\n  }\n\n  hasPreviousPage(): boolean {\n    return !!this.pagination.previous;\n  }\n\n  getNextPage(): Promise<CursorPage<Item>> {\n    if (!this.pagination.next) {\n      throw new Error(\"No next page available\");\n    }\n\n    return this.pageFetcher({ after: this.pagination.next });\n  }\n\n  getPreviousPage(): Promise<CursorPage<Item>> {\n    if (!this.pagination.previous) {\n      throw new Error(\"No previous page available\");\n    }\n\n    return this.pageFetcher({ before: this.pagination.previous });\n  }\n\n  async *iterPages() {\n    // eslint-disable-next-line @typescript-eslint/no-this-alias\n    let page: CursorPage<Item> = this;\n    yield page;\n    while (page.hasNextPage()) {\n      page = await page.getNextPage();\n      yield page;\n    }\n  }\n\n  async *[Symbol.asyncIterator]() {\n    for await (const page of this.iterPages()) {\n      for (const item of page.getPaginatedItems()) {\n        yield item;\n      }\n    }\n  }\n}\n\nexport class OffsetLimitPage<Item>\n  implements OffsetLimitPageResponse<Item>, Page<Item>, AsyncIterable<Item>\n{\n  data: Array<Item>;\n  pagination: { currentPage: number; totalPages: number; count: number };\n\n  constructor(\n    data: Array<Item>,\n    pagination: { currentPage: number; totalPages: number; count: number },\n    private pageFetcher: (\n      params: Omit<OffsetLimitPageParams, \"limit\">\n    ) => Promise<OffsetLimitPage<Item>>\n  ) {\n    this.data = data;\n    this.pagination = pagination;\n  }\n\n  getPaginatedItems(): Item[] {\n    return this.data ?? [];\n  }\n\n  hasNextPage(): boolean {\n    return this.pagination.currentPage < this.pagination.totalPages;\n  }\n\n  hasPreviousPage(): boolean {\n    return this.pagination.currentPage > 1;\n  }\n\n  getNextPage(): Promise<OffsetLimitPage<Item>> {\n    if (!this.hasNextPage()) {\n      throw new Error(\"No next page available\");\n    }\n\n    return this.pageFetcher({\n      page: this.pagination.currentPage + 1,\n    });\n  }\n\n  getPreviousPage(): Promise<OffsetLimitPage<Item>> {\n    if (!this.hasPreviousPage()) {\n      throw new Error(\"No previous page available\");\n    }\n\n    return this.pageFetcher({\n      page: this.pagination.currentPage - 1,\n    });\n  }\n\n  async *iterPages() {\n    // eslint-disable-next-line @typescript-eslint/no-this-alias\n    let page: OffsetLimitPage<Item> = this;\n    yield page;\n    while (page.hasNextPage()) {\n      page = await page.getNextPage();\n      yield page;\n    }\n  }\n\n  async *[Symbol.asyncIterator]() {\n    for await (const page of this.iterPages()) {\n      for (const item of page.getPaginatedItems()) {\n        yield item;\n      }\n    }\n  }\n}\n", "import { ApiClient } from \"../apiClient\";\nimport { getGlobal, registerGlobal, unregisterGlobal } from \"../utils/globals\";\nimport { getEnvVar } from \"../utils/getEnv\";\nimport { ApiClientConfiguration } from \"./types\";\n\nconst API_NAME = \"api-client\";\n\nexport class APIClientManagerAPI {\n  private static _instance?: APIClientManagerAPI;\n\n  private constructor() {}\n\n  public static getInstance(): APIClientManagerAPI {\n    if (!this._instance) {\n      this._instance = new APIClientManagerAPI();\n    }\n\n    return this._instance;\n  }\n\n  public disable() {\n    unregisterGlobal(API_NAME);\n  }\n\n  public setGlobalAPIClientConfiguration(config: ApiClientConfiguration): boolean {\n    return registerGlobal(API_NAME, config);\n  }\n\n  get baseURL(): string | undefined {\n    const store = this.#getConfig();\n    return store?.baseURL ?? getEnvVar(\"TRIGGER_API_URL\") ?? \"https://api.trigger.dev\";\n  }\n\n  get accessToken(): string | undefined {\n    const store = this.#getConfig();\n    return store?.secretKey ?? getEnvVar(\"TRIGGER_SECRET_KEY\") ?? getEnvVar(\"TRIGGER_ACCESS_TOKEN\");\n  }\n\n  get client(): ApiClient | undefined {\n    if (!this.baseURL || !this.accessToken) {\n      return undefined;\n    }\n\n    return new ApiClient(this.baseURL, this.accessToken);\n  }\n\n  #getConfig(): ApiClientConfiguration | undefined {\n    return getGlobal(API_NAME);\n  }\n}\n", "// Split module-level variable definition into separate files to allow\n// tree-shaking on each api instance.\nimport { APIClientManagerAPI } from \"./apiClientManager\";\n/** Entrypoint for logger API */\nexport const apiClientManager = APIClientManagerAPI.getInstance();\n\nexport type { ApiClientConfiguration } from \"./apiClientManager/types\";\n", "import { Attributes, Span } from \"@opentelemetry/api\";\nimport { OFFLOAD_IO_PACKET_LENGTH_LIMIT, imposeAttributeLimits } from \"../limits\";\nimport { SemanticInternalAttributes } from \"../semanticInternalAttributes\";\nimport { TriggerTracer } from \"../tracer\";\nimport { flattenAttributes } from \"./flattenAttributes\";\nimport { apiClientManager } from \"../apiClientManager-api\";\n\nexport type IOPacket = {\n  data?: string | undefined;\n  dataType: string;\n};\n\nexport async function parsePacket(value: IOPacket): Promise<any> {\n  if (!value.data) {\n    return undefined;\n  }\n\n  switch (value.dataType) {\n    case \"application/json\":\n      return JSON.parse(value.data);\n    case \"application/super+json\":\n      const { parse } = await loadSuperJSON();\n\n      return parse(value.data);\n    case \"text/plain\":\n      return value.data;\n    case \"application/store\":\n      throw new Error(\n        `Cannot parse an application/store packet (${value.data}). Needs to be imported first.`\n      );\n    default:\n      return value.data;\n  }\n}\n\nexport async function stringifyIO(value: any): Promise<IOPacket> {\n  if (value === undefined) {\n    return { dataType: \"application/json\" };\n  }\n\n  if (typeof value === \"string\") {\n    return { data: value, dataType: \"text/plain\" };\n  }\n\n  try {\n    const { stringify } = await loadSuperJSON();\n    const data = stringify(value);\n\n    return { data, dataType: \"application/super+json\" };\n  } catch {\n    return { data: value, dataType: \"application/json\" };\n  }\n}\n\nexport async function conditionallyExportPacket(\n  packet: IOPacket,\n  pathPrefix: string,\n  tracer?: TriggerTracer\n): Promise<IOPacket> {\n  if (apiClientManager.client) {\n    const { needsOffloading, size } = packetRequiresOffloading(packet);\n\n    if (needsOffloading) {\n      if (!tracer) {\n        return await exportPacket(packet, pathPrefix);\n      } else {\n        const result = await tracer.startActiveSpan(\n          \"store.uploadOutput\",\n          async (span) => {\n            return await exportPacket(packet, pathPrefix);\n          },\n          {\n            attributes: {\n              byteLength: size,\n              [SemanticInternalAttributes.STYLE_ICON]: \"cloud-upload\",\n            },\n          }\n        );\n\n        return result ?? packet;\n      }\n    }\n  }\n\n  return packet;\n}\n\nexport function packetRequiresOffloading(\n  packet: IOPacket,\n  lengthLimit?: number\n): {\n  needsOffloading: boolean;\n  size: number;\n} {\n  if (!packet.data) {\n    return {\n      needsOffloading: false,\n      size: 0,\n    };\n  }\n\n  const byteSize = Buffer.byteLength(packet.data, \"utf8\");\n\n  return {\n    needsOffloading: byteSize >= (lengthLimit ?? OFFLOAD_IO_PACKET_LENGTH_LIMIT),\n    size: byteSize,\n  };\n}\n\nasync function exportPacket(packet: IOPacket, pathPrefix: string): Promise<IOPacket> {\n  // Offload the output\n  const filename = `${pathPrefix}.${getPacketExtension(packet.dataType)}`;\n\n  const presignedResponse = await apiClientManager.client!.createUploadPayloadUrl(filename);\n\n  const uploadResponse = await fetch(presignedResponse.presignedUrl, {\n    method: \"PUT\",\n    headers: {\n      \"Content-Type\": packet.dataType,\n    },\n    body: packet.data,\n  });\n\n  if (!uploadResponse.ok) {\n    throw new Error(\n      `Failed to upload output to ${presignedResponse.presignedUrl}: ${uploadResponse.statusText}`\n    );\n  }\n\n  return {\n    data: filename,\n    dataType: \"application/store\",\n  };\n}\n\nexport async function conditionallyImportPacket(\n  packet: IOPacket,\n  tracer?: TriggerTracer\n): Promise<IOPacket> {\n  if (packet.dataType !== \"application/store\") {\n    return packet;\n  }\n\n  if (!tracer) {\n    return await importPacket(packet);\n  } else {\n    const result = await tracer.startActiveSpan(\n      \"store.downloadPayload\",\n      async (span) => {\n        return await importPacket(packet, span);\n      },\n      {\n        attributes: {\n          [SemanticInternalAttributes.STYLE_ICON]: \"cloud-download\",\n        },\n      }\n    );\n\n    return result ?? packet;\n  }\n}\n\nasync function importPacket(packet: IOPacket, span?: Span): Promise<IOPacket> {\n  if (!packet.data) {\n    return packet;\n  }\n\n  if (!apiClientManager.client) {\n    return packet;\n  }\n\n  const presignedResponse = await apiClientManager.client.getPayloadUrl(packet.data);\n\n  const response = await fetch(presignedResponse.presignedUrl);\n\n  if (!response.ok) {\n    throw new Error(\n      `Failed to import packet ${presignedResponse.presignedUrl}: ${response.statusText}`\n    );\n  }\n\n  const data = await response.text();\n\n  span?.setAttribute(\"size\", Buffer.byteLength(data, \"utf8\"));\n\n  return {\n    data,\n    dataType: response.headers.get(\"content-type\") ?? \"application/json\",\n  };\n}\n\nexport async function createPacketAttributes(\n  packet: IOPacket,\n  dataKey: string,\n  dataTypeKey: string\n): Promise<Attributes | undefined> {\n  if (!packet.data) {\n    return;\n  }\n\n  switch (packet.dataType) {\n    case \"application/json\":\n      return {\n        ...flattenAttributes(packet, dataKey),\n        [dataTypeKey]: packet.dataType,\n      };\n    case \"application/super+json\":\n      const { parse } = await loadSuperJSON();\n\n      if (typeof packet.data === \"undefined\" || packet.data === null) {\n        return;\n      }\n\n      try {\n        const parsed = parse(packet.data) as any;\n        const jsonified = JSON.parse(JSON.stringify(parsed, safeReplacer));\n\n        const result = {\n          ...flattenAttributes(jsonified, dataKey),\n          [dataTypeKey]: \"application/json\",\n        };\n\n        return result;\n      } catch (e) {\n        return;\n      }\n\n    case \"application/store\":\n      return {\n        [dataKey]: packet.data,\n        [dataTypeKey]: packet.dataType,\n      };\n    case \"text/plain\":\n      return {\n        [dataKey]: packet.data,\n        [dataTypeKey]: packet.dataType,\n      };\n    default:\n      return;\n  }\n}\n\nexport async function createPacketAttributesAsJson(\n  data: any,\n  dataType: string\n): Promise<Attributes> {\n  if (\n    typeof data === \"string\" ||\n    typeof data === \"number\" ||\n    typeof data === \"boolean\" ||\n    data === null ||\n    data === undefined\n  ) {\n    return data;\n  }\n\n  switch (dataType) {\n    case \"application/json\":\n      return imposeAttributeLimits(flattenAttributes(data, undefined));\n    case \"application/super+json\":\n      const { deserialize } = await loadSuperJSON();\n\n      const deserialized = deserialize(data) as any;\n      const jsonify = safeJsonParse(JSON.stringify(deserialized, safeReplacer));\n\n      return imposeAttributeLimits(flattenAttributes(jsonify, undefined));\n    case \"application/store\":\n      return data;\n    default:\n      return {};\n  }\n}\n\nexport async function prettyPrintPacket(rawData: any, dataType?: string): Promise<string> {\n  if (rawData === undefined) {\n    return \"\";\n  }\n\n  if (dataType === \"application/super+json\") {\n    if (typeof rawData === \"string\") {\n      rawData = safeJsonParse(rawData);\n    }\n    const { deserialize } = await loadSuperJSON();\n\n    return await prettyPrintPacket(deserialize(rawData), \"application/json\");\n  }\n\n  if (dataType === \"application/json\") {\n    if (typeof rawData === \"string\") {\n      rawData = safeJsonParse(rawData);\n    }\n    return JSON.stringify(rawData, safeReplacer, 2);\n  }\n\n  if (typeof rawData === \"string\") {\n    return rawData;\n  }\n\n  return JSON.stringify(rawData, safeReplacer, 2);\n}\n\nfunction safeReplacer(key: string, value: any) {\n  // If it is a BigInt\n  if (typeof value === \"bigint\") {\n    return value.toString(); // Convert to string\n  }\n\n  // if it is a Regex\n  if (value instanceof RegExp) {\n    return value.toString(); // Convert to string\n  }\n\n  // if it is a Set\n  if (value instanceof Set) {\n    return Array.from(value); // Convert to array\n  }\n\n  // if it is a Map, convert it to an object\n  if (value instanceof Map) {\n    const obj: Record<string, any> = {};\n    value.forEach((v, k) => {\n      obj[k] = v;\n    });\n    return obj;\n  }\n\n  return value; // Otherwise return the value as is\n}\n\nfunction getPacketExtension(outputType: string): string {\n  switch (outputType) {\n    case \"application/json\":\n      return \"json\";\n    case \"application/super+json\":\n      return \"json\";\n    case \"text/plain\":\n      return \"txt\";\n    default:\n      return \"txt\";\n  }\n}\n\nasync function loadSuperJSON(): Promise<typeof import(\"superjson\")> {\n  return await import(\"superjson\");\n}\n\nfunction safeJsonParse(value: string): any {\n  try {\n    return JSON.parse(value);\n  } catch {\n    return;\n  }\n}\n\nexport async function replaceSuperJsonPayload(original: string, newPayload: string) {\n  const superjson = await loadSuperJSON();\n  const originalObject = superjson.parse(original);\n  const { meta } = superjson.serialize(originalObject);\n\n  const newSuperJson = {\n    json: JSON.parse(newPayload) as any,\n    meta,\n  };\n\n  return superjson.deserialize(newSuperJson);\n}\n", "import { PreciseDate } from \"@google-cloud/precise-date\";\nimport { Clock, ClockTime } from \"./clock\";\n\nexport type PreciseWallClockOptions = {\n  origin?: ClockTime;\n  now?: PreciseDate;\n};\n\nexport class PreciseWallClock implements Clock {\n  private _origin: {\n    clockTime: ClockTime;\n    preciseDate: PreciseDate;\n  };\n\n  get #originClockTime() {\n    return this._origin.clockTime;\n  }\n\n  get #originPreciseDate() {\n    return this._origin.preciseDate;\n  }\n\n  constructor(options: PreciseWallClockOptions = {}) {\n    this._origin = {\n      clockTime: options.origin ?? process.hrtime(),\n      preciseDate: options.now ?? new PreciseDate(),\n    };\n  }\n\n  preciseNow(): [number, number] {\n    const elapsedHrTime = process.hrtime(this.#originClockTime);\n    const elapsedNanoseconds = BigInt(elapsedHrTime[0]) * BigInt(1e9) + BigInt(elapsedHrTime[1]);\n\n    const preciseDate = new PreciseDate(this.#originPreciseDate.getFullTime() + elapsedNanoseconds);\n    const dateStruct = preciseDate.toStruct();\n\n    return [dateStruct.seconds, dateStruct.nanos];\n  }\n\n  reset() {\n    this._origin = {\n      clockTime: process.hrtime(),\n      preciseDate: new PreciseDate(),\n    };\n  }\n}\n", "import { Attributes, Span, SpanOptions } from \"@opentelemetry/api\";\nimport { Logger, SeverityNumber } from \"@opentelemetry/api-logs\";\nimport { iconStringForSeverity } from \"../icons\";\nimport { SemanticInternalAttributes } from \"../semanticInternalAttributes\";\nimport { TriggerTracer } from \"../tracer\";\nimport { flattenAttributes } from \"../utils/flattenAttributes\";\nimport { ClockTime } from \"../clock/clock\";\nimport { clock } from \"../clock-api\";\n\nexport type LogLevel = \"none\" | \"error\" | \"warn\" | \"info\" | \"debug\" | \"log\";\n\nexport const logLevels: Array<LogLevel> = [\"none\", \"error\", \"warn\", \"info\", \"debug\"];\n\nexport type TaskLoggerConfig = {\n  logger: Logger;\n  tracer: TriggerTracer;\n  level: LogLevel;\n};\n\nexport interface TaskLogger {\n  debug(message: string, properties?: Record<string, unknown>): void;\n  log(message: string, properties?: Record<string, unknown>): void;\n  info(message: string, properties?: Record<string, unknown>): void;\n  warn(message: string, properties?: Record<string, unknown>): void;\n  error(message: string, properties?: Record<string, unknown>): void;\n  trace<T>(name: string, fn: (span: Span) => Promise<T>, options?: SpanOptions): Promise<T>;\n}\n\nexport class OtelTaskLogger implements TaskLogger {\n  private readonly _level: number;\n\n  constructor(private readonly _config: TaskLoggerConfig) {\n    this._level = logLevels.indexOf(_config.level);\n  }\n\n  debug(message: string, properties?: Record<string, unknown>) {\n    if (this._level < 4) return; // [\"none\", \"error\", \"warn\", \"info\", \"debug\"];\n\n    this.#emitLog(message, this.#getTimestampInHrTime(), \"debug\", SeverityNumber.DEBUG, properties);\n  }\n\n  log(message: string, properties?: Record<string, unknown>) {\n    if (this._level < 3) return; // [\"none\", \"error\", \"warn\", \"info\", \"debug\"];\n\n    this.#emitLog(message, this.#getTimestampInHrTime(), \"log\", SeverityNumber.INFO, properties);\n  }\n\n  info(message: string, properties?: Record<string, unknown>) {\n    if (this._level < 3) return; // [\"none\", \"error\", \"warn\", \"info\", \"debug\"];\n\n    this.#emitLog(message, this.#getTimestampInHrTime(), \"info\", SeverityNumber.INFO, properties);\n  }\n\n  warn(message: string, properties?: Record<string, unknown>) {\n    if (this._level < 2) return; // [\"none\", \"error\", \"warn\", \"info\", \"debug\"];\n\n    this.#emitLog(message, this.#getTimestampInHrTime(), \"warn\", SeverityNumber.WARN, properties);\n  }\n\n  error(message: string, properties?: Record<string, unknown>) {\n    if (this._level < 1) return; // [\"none\", \"error\", \"warn\", \"info\", \"debug\"];\n\n    this.#emitLog(message, this.#getTimestampInHrTime(), \"error\", SeverityNumber.ERROR, properties);\n  }\n\n  #emitLog(\n    message: string,\n    timestamp: ClockTime,\n    severityText: string,\n    severityNumber: SeverityNumber,\n    properties?: Record<string, unknown>\n  ) {\n    let attributes: Attributes = { ...flattenAttributes(safeJsonProcess(properties)) };\n\n    const icon = iconStringForSeverity(severityNumber);\n    if (icon !== undefined) {\n      attributes[SemanticInternalAttributes.STYLE_ICON] = icon;\n    }\n\n    this._config.logger.emit({\n      severityNumber,\n      severityText,\n      body: message,\n      attributes,\n      timestamp,\n    });\n  }\n\n  trace<T>(name: string, fn: (span: Span) => Promise<T>, options?: SpanOptions): Promise<T> {\n    return this._config.tracer.startActiveSpan(name, fn, options);\n  }\n\n  #getTimestampInHrTime(): ClockTime {\n    return clock.preciseNow();\n  }\n}\n\nexport class NoopTaskLogger implements TaskLogger {\n  debug() {}\n  log() {}\n  info() {}\n  warn() {}\n  error() {}\n  trace<T>(name: string, fn: (span: Span) => Promise<T>): Promise<T> {\n    return fn({} as Span);\n  }\n}\n\nfunction safeJsonProcess(value?: Record<string, unknown>): Record<string, unknown> | undefined {\n  try {\n    return JSON.parse(JSON.stringify(value, jsonErrorReplacer));\n  } catch {\n    return value;\n  }\n}\n\nfunction jsonErrorReplacer(key: string, value: unknown) {\n  if (value instanceof Error) {\n    return {\n      name: value.name,\n      message: value.message,\n      stack: value.stack,\n    };\n  }\n\n  return value;\n}\n", "import { SeverityNumber } from \"@opentelemetry/api-logs\";\n\nexport function iconStringForSeverity(severityNumber: SeverityNumber) {\n  switch (severityNumber) {\n    case SeverityNumber.UNSPECIFIED:\n      return undefined;\n    case SeverityNumber.TRACE:\n    case SeverityNumber.TRACE2:\n    case SeverityNumber.TRACE3:\n    case SeverityNumber.TRACE4:\n      return \"trace\";\n    case SeverityNumber.DEBUG:\n    case SeverityNumber.DEBUG2:\n    case SeverityNumber.DEBUG3:\n    case SeverityNumber.DEBUG4:\n      return \"debug\";\n    case SeverityNumber.INFO:\n    case SeverityNumber.INFO2:\n    case SeverityNumber.INFO3:\n    case SeverityNumber.INFO4:\n      return \"info\";\n    case SeverityNumber.WARN:\n    case SeverityNumber.WARN2:\n    case SeverityNumber.WARN3:\n    case SeverityNumber.WARN4:\n      return \"warn\";\n    case SeverityNumber.ERROR:\n    case SeverityNumber.ERROR2:\n    case SeverityNumber.ERROR3:\n    case SeverityNumber.ERROR4:\n      return \"error\";\n    case SeverityNumber.FATAL:\n    case SeverityNumber.FATAL2:\n    case SeverityNumber.FATAL3:\n    case SeverityNumber.FATAL4:\n      return \"fatal\";\n  }\n}\n", "import { PreciseDate } from \"@google-cloud/precise-date\";\nimport { Clock } from \"./clock\";\n\nexport class SimpleClock implements Clock {\n  preciseNow(): [number, number] {\n    const now = new PreciseDate();\n    const nowStruct = now.toStruct();\n\n    return [nowStruct.seconds, nowStruct.nanos];\n  }\n\n  reset() {\n    // do nothing\n  }\n}\n", "const API_NAME = \"clock\";\n\nimport { getGlobal, registerGlobal } from \"../utils/globals\";\nimport type { Clock, ClockTime } from \"./clock\";\nimport { SimpleClock } from \"./simpleClock\";\n\nconst SIMPLE_CLOCK = new SimpleClock();\n\nexport class ClockAPI {\n  private static _instance?: ClockAPI;\n\n  private constructor() {}\n\n  public static getInstance(): ClockAPI {\n    if (!this._instance) {\n      this._instance = new ClockAPI();\n    }\n\n    return this._instance;\n  }\n\n  public setGlobalClock(clock: Clock): boolean {\n    return registerGlobal(API_NAME, clock);\n  }\n\n  public preciseNow(): ClockTime {\n    return this.#getClock().preciseNow();\n  }\n\n  public reset(): void {\n    this.#getClock().reset();\n  }\n\n  #getClock(): Clock {\n    return getGlobal(API_NAME) ?? SIMPLE_CLOCK;\n  }\n}\n", "// Split module-level variable definition into separate files to allow\n// tree-shaking on each api instance.\nimport { ClockAPI } from \"./clock\";\n/** Entrypoint for clock API */\nexport const clock = ClockAPI.getInstance();\n", "import type * as logsAPI from \"@opentelemetry/api-logs\";\nimport { SeverityNumber } from \"@opentelemetry/api-logs\";\nimport util from \"node:util\";\nimport { iconStringForSeverity } from \"./icons\";\nimport { SemanticInternalAttributes } from \"./semanticInternalAttributes\";\nimport { flattenAttributes } from \"./utils/flattenAttributes\";\nimport { ClockTime } from \"./clock/clock\";\nimport { clock } from \"./clock-api\";\n\nexport class ConsoleInterceptor {\n  constructor(\n    private readonly logger: logsAPI.Logger,\n    private readonly sendToStdIO: boolean\n  ) {}\n\n  // Intercept the console and send logs to the OpenTelemetry logger\n  // during the execution of the callback\n  async intercept<T>(console: Console, callback: () => Promise<T>): Promise<T> {\n    // Save the original console methods\n    const originalConsole = {\n      log: console.log,\n      info: console.info,\n      warn: console.warn,\n      error: console.error,\n      debug: console.debug,\n    };\n\n    // Override the console methods\n    console.log = this.log.bind(this);\n    console.info = this.info.bind(this);\n    console.warn = this.warn.bind(this);\n    console.error = this.error.bind(this);\n    console.debug = this.debug.bind(this);\n\n    try {\n      return await callback();\n    } finally {\n      // Restore the original console methods\n      console.log = originalConsole.log;\n      console.info = originalConsole.info;\n      console.warn = originalConsole.warn;\n      console.error = originalConsole.error;\n      console.debug = originalConsole.debug;\n    }\n  }\n\n  debug(...args: unknown[]): void {\n    this.#handleLog(SeverityNumber.DEBUG, this.#getTimestampInHrTime(), \"Debug\", ...args);\n  }\n\n  log(...args: unknown[]): void {\n    this.#handleLog(SeverityNumber.INFO, this.#getTimestampInHrTime(), \"Log\", ...args);\n  }\n\n  info(...args: unknown[]): void {\n    this.#handleLog(SeverityNumber.INFO, this.#getTimestampInHrTime(), \"Info\", ...args);\n  }\n\n  warn(...args: unknown[]): void {\n    this.#handleLog(SeverityNumber.WARN, this.#getTimestampInHrTime(), \"Warn\", ...args);\n  }\n\n  error(...args: unknown[]): void {\n    this.#handleLog(SeverityNumber.ERROR, this.#getTimestampInHrTime(), \"Error\", ...args);\n  }\n\n  #handleLog(\n    severityNumber: SeverityNumber,\n    timestamp: ClockTime,\n    severityText: string,\n    ...args: unknown[]\n  ): void {\n    const body = util.format(...args);\n\n    if (this.sendToStdIO) {\n      if (severityNumber === SeverityNumber.ERROR) {\n        process.stderr.write(body);\n      } else {\n        process.stdout.write(body);\n      }\n    }\n\n    const parsed = tryParseJSON(body);\n\n    if (parsed.ok) {\n      this.logger.emit({\n        severityNumber,\n        severityText,\n        body: getLogMessage(parsed.value, severityText),\n        attributes: { ...this.#getAttributes(severityNumber), ...flattenAttributes(parsed.value) },\n        timestamp,\n      });\n\n      return;\n    }\n\n    this.logger.emit({\n      severityNumber,\n      severityText,\n      body,\n      attributes: this.#getAttributes(severityNumber),\n      timestamp,\n    });\n  }\n\n  #getTimestampInHrTime(): ClockTime {\n    return clock.preciseNow();\n  }\n\n  #getAttributes(severityNumber: SeverityNumber): logsAPI.LogAttributes {\n    const icon = iconStringForSeverity(severityNumber);\n    let result: logsAPI.LogAttributes = {};\n\n    if (icon !== undefined) {\n      result[SemanticInternalAttributes.STYLE_ICON] = icon;\n    }\n\n    return result;\n  }\n}\n\nfunction getLogMessage(value: Record<string, unknown>, fallback: string): string {\n  if (typeof value[\"message\"] === \"string\") {\n    return value[\"message\"];\n  }\n\n  if (typeof value[\"msg\"] === \"string\") {\n    return value[\"msg\"];\n  }\n\n  if (typeof value[\"body\"] === \"string\") {\n    return value[\"body\"];\n  }\n\n  if (typeof value[\"error\"] === \"string\") {\n    return value[\"error\"];\n  }\n\n  return fallback;\n}\n\nfunction tryParseJSON(\n  value: string\n): { ok: true; value: Record<string, unknown> } | { ok: false; value: string } {\n  try {\n    const parsed = JSON.parse(value);\n\n    if (typeof parsed === \"object\" && parsed !== null && !Array.isArray(parsed)) {\n      return { ok: true, value: parsed };\n    }\n\n    return { ok: false, value };\n  } catch (e) {\n    return { ok: false, value };\n  }\n}\n", "import { TaskFileMetadata, TaskMetadata, TaskMetadataWithFilePath } from \"../schemas\";\nimport { TaskMetadataWithFunctions } from \"../types\";\nimport { TaskCatalog } from \"./catalog\";\n\nexport class StandardTaskCatalog implements TaskCatalog {\n  private _taskMetadata: Map<string, TaskMetadata> = new Map();\n  private _taskFunctions: Map<string, TaskMetadataWithFunctions[\"fns\"]> = new Map();\n  private _taskFileMetadata: Map<string, TaskFileMetadata> = new Map();\n\n  registerTaskMetadata(task: TaskMetadataWithFunctions): void {\n    const { fns, ...metadata } = task;\n\n    this._taskMetadata.set(task.id, metadata);\n    this._taskFunctions.set(task.id, fns);\n  }\n\n  updateTaskMetadata(id: string, updates: Partial<TaskMetadataWithFunctions>): void {\n    const existingMetadata = this._taskMetadata.get(id);\n\n    if (existingMetadata) {\n      this._taskMetadata.set(id, {\n        ...existingMetadata,\n        ...updates,\n      });\n    }\n\n    if (updates.fns) {\n      const existingFunctions = this._taskFunctions.get(id);\n\n      if (existingFunctions) {\n        this._taskFunctions.set(id, {\n          ...existingFunctions,\n          ...updates.fns,\n        });\n      }\n    }\n  }\n\n  registerTaskFileMetadata(id: string, metadata: TaskFileMetadata): void {\n    this._taskFileMetadata.set(id, metadata);\n  }\n\n  // Return all the tasks, without the functions\n  getAllTaskMetadata(): Array<TaskMetadataWithFilePath> {\n    const result: Array<TaskMetadataWithFilePath> = [];\n\n    for (const [id, metadata] of this._taskMetadata) {\n      const fileMetadata = this._taskFileMetadata.get(id);\n\n      if (!fileMetadata) {\n        continue;\n      }\n\n      result.push({\n        ...metadata,\n        ...fileMetadata,\n      });\n    }\n\n    return result;\n  }\n\n  getTaskMetadata(id: string): TaskMetadataWithFilePath | undefined {\n    const metadata = this._taskMetadata.get(id);\n    const fileMetadata = this._taskFileMetadata.get(id);\n\n    if (!metadata || !fileMetadata) {\n      return undefined;\n    }\n\n    return {\n      ...metadata,\n      ...fileMetadata,\n    };\n  }\n\n  getTask(id: string): TaskMetadataWithFunctions | undefined {\n    const metadata = this._taskMetadata.get(id);\n    const fileMetadata = this._taskFileMetadata.get(id);\n    const fns = this._taskFunctions.get(id);\n\n    if (!metadata || !fns || !fileMetadata) {\n      return undefined;\n    }\n\n    return {\n      ...metadata,\n      ...fileMetadata,\n      fns,\n    };\n  }\n\n  taskExists(id: string): boolean {\n    return this._taskMetadata.has(id);\n  }\n\n  disable() {\n    // noop\n  }\n}\n", "import { UsageManager, UsageMeasurement, UsageSample } from \"./types\";\n\nexport class NoopUsageManager implements UsageManager {\n  disable(): void {\n    // Noop\n  }\n\n  start(): UsageMeasurement {\n    return {\n      sample: () => ({ cpuTime: 0, wallTime: 0 }),\n    };\n  }\n\n  stop(measurement: UsageMeasurement): UsageSample {\n    return measurement.sample();\n  }\n\n  pauseAsync<T>(cb: () => Promise<T>): Promise<T> {\n    return cb();\n  }\n\n  sample(): UsageSample | undefined {\n    return undefined;\n  }\n}\n", "const API_NAME = \"usage\";\n\nimport { getGlobal, registerGlobal, unregisterGlobal } from \"../utils/globals\";\nimport type { UsageManager, UsageMeasurement, UsageSample } from \"./types\";\nimport { NoopUsageManager } from \"./noopUsageManager\";\n\nconst NOOP_USAGE_MANAGER = new NoopUsageManager();\n\nexport class UsageAPI implements UsageManager {\n  private static _instance?: UsageAPI;\n\n  private constructor() {}\n\n  public static getInstance(): UsageAPI {\n    if (!this._instance) {\n      this._instance = new UsageAPI();\n    }\n\n    return this._instance;\n  }\n\n  public setGlobalUsageManager(manager: UsageManager): boolean {\n    return registerGlobal(API_NAME, manager);\n  }\n\n  public disable() {\n    this.#getUsageManager().disable();\n    unregisterGlobal(API_NAME);\n  }\n\n  public start(): UsageMeasurement {\n    return this.#getUsageManager().start();\n  }\n\n  public stop(measurement: UsageMeasurement): UsageSample {\n    return this.#getUsageManager().stop(measurement);\n  }\n\n  public pauseAsync<T>(cb: () => Promise<T>): Promise<T> {\n    return this.#getUsageManager().pauseAsync(cb);\n  }\n\n  public sample(): UsageSample | undefined {\n    return this.#getUsageManager().sample();\n  }\n\n  #getUsageManager(): UsageManager {\n    return getGlobal(API_NAME) ?? NOOP_USAGE_MANAGER;\n  }\n}\n", "// Split module-level variable definition into separate files to allow\n// tree-shaking on each api instance.\nimport { UsageAPI } from \"./usage/api\";\n/** Entrypoint for usage API */\nexport const usage = UsageAPI.getInstance();\n", "/**\n * Contains two parts: the first part is the seconds, the second part is the nanoseconds.\n *\n */\nexport type ClockTime = [number, number];\n\nexport interface Clock {\n  preciseNow(): ClockTime;\n  reset(): void;\n}\n\nexport function calculateDurationInMs(start: ClockTime, end: ClockTime): number {\n  const [startSeconds, startNanoseconds] = start;\n  const [endSeconds, endNanoseconds] = end;\n\n  const seconds = endSeconds - startSeconds;\n  const nanoseconds = endNanoseconds - startNanoseconds;\n\n  return Math.floor(seconds * 1000 + nanoseconds / 1000000);\n}\n", "import { UsageManager, UsageMeasurement, UsageSample } from \"./types\";\nimport { clock } from \"../clock-api\";\nimport { ClockTime, calculateDurationInMs } from \"../clock/clock\";\n\nclass DevUsageMeasurement implements UsageMeasurement {\n  private _pauses: Map<string, { start: ClockTime; end?: ClockTime }> = new Map();\n  private _endedAt: ClockTime | undefined;\n\n  constructor(\n    public readonly id: string,\n    private startedAt: ClockTime = clock.preciseNow()\n  ) {}\n\n  stop() {\n    this._endedAt = clock.preciseNow();\n  }\n\n  sample(): UsageSample {\n    const endedAt = this._endedAt ?? clock.preciseNow();\n\n    const wallTime = this.startedAt ? calculateDurationInMs(this.startedAt, endedAt) : 0;\n\n    if (wallTime === 0) {\n      return { cpuTime: 0, wallTime: 0 };\n    }\n\n    const totalPauses = Array.from(this._pauses.values()).reduce((total, pause) => {\n      return total + calculateDurationInMs(pause.start, pause.end ?? endedAt);\n    }, 0);\n\n    const cpuTime = wallTime - totalPauses;\n\n    return {\n      wallTime,\n      cpuTime,\n    };\n  }\n\n  registerPause(pauseId: string, start: ClockTime, end?: ClockTime) {\n    this._pauses.set(pauseId, { start, end });\n  }\n}\n\nexport class DevUsageManager implements UsageManager {\n  private _firstMeasurement?: DevUsageMeasurement;\n  private _currentMeasurements: Map<string, DevUsageMeasurement> = new Map();\n  private _pauses: Map<string, { start: ClockTime; end?: ClockTime }> = new Map();\n\n  disable(): void {}\n\n  sample(): UsageSample | undefined {\n    return this._firstMeasurement?.sample();\n  }\n\n  start(): DevUsageMeasurement {\n    // generate a random ID\n    const id = generateRandomString();\n\n    const measurement = new DevUsageMeasurement(id);\n\n    if (!this._firstMeasurement) {\n      this._firstMeasurement = measurement;\n    }\n\n    this._currentMeasurements.set(id, measurement);\n\n    return measurement;\n  }\n\n  stop(measurement: DevUsageMeasurement): UsageSample {\n    measurement.stop();\n\n    const sample = measurement.sample();\n\n    this._currentMeasurements.delete(measurement.id);\n\n    return sample;\n  }\n\n  async pauseAsync<T>(cb: () => Promise<T>): Promise<T> {\n    const pauseId = generateRandomString();\n\n    const pauseStart = clock.preciseNow();\n\n    try {\n      this._pauses.set(pauseId, { start: pauseStart });\n\n      for (const measurement of this._currentMeasurements.values()) {\n        measurement.registerPause(pauseId, pauseStart);\n      }\n\n      return await cb();\n    } finally {\n      const pauseEnd = clock.preciseNow();\n\n      this._pauses.set(pauseId, { start: pauseStart, end: pauseEnd });\n\n      for (const measurement of this._currentMeasurements.values()) {\n        measurement.registerPause(pauseId, pauseStart, pauseEnd);\n      }\n    }\n  }\n}\n\nfunction generateRandomString() {\n  let result = \"\";\n  const characters = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\";\n  const charactersLength = characters.length;\n\n  for (var i = 0; i < 16; i++) {\n    result += characters.charAt(Math.floor(Math.random() * charactersLength));\n  }\n\n  return result;\n}\n", "import { setInterval } from \"node:timers/promises\";\nimport { UsageManager, UsageMeasurement, UsageSample } from \"./types\";\nimport { UsageClient } from \"./usageClient\";\n\nexport type ProdUsageManagerOptions = {\n  heartbeatIntervalMs?: number;\n  url?: string;\n  jwt?: string;\n};\n\nexport class ProdUsageManager implements UsageManager {\n  private _measurement: UsageMeasurement | undefined;\n  private _abortController: AbortController | undefined;\n  private _lastSample: UsageSample | undefined;\n  private _usageClient: UsageClient | undefined;\n\n  constructor(\n    private readonly delegageUsageManager: UsageManager,\n    private readonly options: ProdUsageManagerOptions\n  ) {\n    if (this.options.url && this.options.jwt) {\n      this._usageClient = new UsageClient(this.options.url, this.options.jwt);\n    }\n  }\n\n  get isReportingEnabled() {\n    return typeof this._usageClient !== \"undefined\";\n  }\n\n  disable(): void {\n    this.delegageUsageManager.disable();\n    this._abortController?.abort();\n  }\n\n  sample(): UsageSample | undefined {\n    return this._measurement?.sample();\n  }\n\n  start(): UsageMeasurement {\n    if (!this.isReportingEnabled || !this.options.heartbeatIntervalMs) {\n      return this.delegageUsageManager.start();\n    }\n\n    if (!this._measurement) {\n      this._measurement = this.delegageUsageManager.start();\n\n      this.#startReportingHeartbeat().catch(console.error);\n\n      return this._measurement;\n    }\n\n    return this.delegageUsageManager.start();\n  }\n\n  stop(measurement: UsageMeasurement): UsageSample {\n    return this.delegageUsageManager.stop(measurement);\n  }\n\n  async pauseAsync<T>(cb: () => Promise<T>): Promise<T> {\n    return this.delegageUsageManager.pauseAsync(cb);\n  }\n\n  async #startReportingHeartbeat() {\n    if (!this._measurement || !this.isReportingEnabled || !this.options.heartbeatIntervalMs) {\n      return;\n    }\n\n    this._abortController = new AbortController();\n\n    for await (const _ of setInterval(this.options.heartbeatIntervalMs)) {\n      if (this._abortController.signal.aborted) {\n        break;\n      }\n\n      await this.#reportUsage();\n    }\n  }\n\n  async flush() {\n    return await this.#reportUsage();\n  }\n\n  async #reportUsage() {\n    if (!this._measurement) {\n      return;\n    }\n\n    if (!this.isReportingEnabled) {\n      return;\n    }\n\n    const client = this._usageClient;\n\n    if (!client) {\n      return;\n    }\n\n    const sample = this._measurement.sample();\n\n    const cpuTimeSinceLastSample = this._lastSample\n      ? sample.cpuTime - this._lastSample.cpuTime\n      : sample.cpuTime;\n\n    this._lastSample = sample;\n\n    if (cpuTimeSinceLastSample <= 0) {\n      return;\n    }\n\n    await client.sendUsageEvent({ durationMs: cpuTimeSinceLastSample });\n  }\n}\n", "import { apiClientManager } from \"../apiClientManager-api\";\n\nexport type UsageClientOptions = {\n  token: string;\n  baseUrl: string;\n};\n\nexport type UsageEvent = {\n  durationMs: number;\n};\n\nexport class UsageClient {\n  constructor(\n    private readonly url: string,\n    private jwt: string\n  ) {}\n\n  async sendUsageEvent(event: UsageEvent): Promise<void> {\n    try {\n      const response = await fetch(this.url, {\n        method: \"POST\",\n        body: JSON.stringify(event),\n        headers: {\n          \"content-type\": \"application/json\",\n          \"x-trigger-jwt\": this.jwt,\n          accept: \"application/json\",\n          authorization: `Bearer ${apiClientManager.accessToken}`, // this is used to renew the JWT\n        },\n      });\n\n      if (response.ok) {\n        const renewedJwt = response.headers.get(\"x-trigger-jwt\");\n\n        if (renewedJwt) {\n          this.jwt = renewedJwt;\n        }\n      }\n    } catch (error) {\n      console.error(`Failed to send usage event: ${error}`);\n    }\n  }\n}\n", "import { setInterval, setTimeout } from \"node:timers/promises\";\n\nexport async function unboundedTimeout<T = void>(\n  delay: number = 0,\n  value?: T,\n  options?: Parameters<typeof setTimeout>[2]\n): Promise<T> {\n  const maxDelay = 2147483647; // Highest value that will fit in a 32-bit signed integer\n\n  const fullTimeouts = Math.floor(delay / maxDelay);\n  const remainingDelay = delay % maxDelay;\n\n  let lastTimeoutResult = await setTimeout(remainingDelay, value, options);\n\n  for (let i = 0; i < fullTimeouts; i++) {\n    lastTimeoutResult = await setTimeout(maxDelay, value, options);\n  }\n\n  return lastTimeoutResult;\n}\n\nexport async function checkpointSafeTimeout(delay: number = 0): Promise<void> {\n  const scanIntervalMs = 1000;\n\n  // Every scanIntervalMs, check if delay has elapsed\n  for await (const start of setInterval(scanIntervalMs, Date.now())) {\n    if (Date.now() - start > delay) {\n      break;\n    }\n  }\n}\n", "import {\n  BatchTaskRunExecutionResult,\n  TaskRunContext,\n  TaskRunExecution,\n  TaskRunExecutionResult,\n} from \"../schemas\";\nimport { RuntimeManager } from \"./manager\";\nimport { unboundedTimeout } from \"../utils/timers\";\n\nexport class DevRuntimeManager implements RuntimeManager {\n  _taskWaits: Map<string, { resolve: (value: TaskRunExecutionResult) => void }> = new Map();\n\n  _batchWaits: Map<\n    string,\n    { resolve: (value: BatchTaskRunExecutionResult) => void; reject: (err?: any) => void }\n  > = new Map();\n\n  _pendingCompletionNotifications: Map<string, TaskRunExecutionResult> = new Map();\n\n  disable(): void {\n    // do nothing\n  }\n\n  async waitForDuration(ms: number): Promise<void> {\n    await unboundedTimeout(ms);\n  }\n\n  async waitUntil(date: Date): Promise<void> {\n    return this.waitForDuration(date.getTime() - Date.now());\n  }\n\n  async waitForTask(params: { id: string; ctx: TaskRunContext }): Promise<TaskRunExecutionResult> {\n    const pendingCompletion = this._pendingCompletionNotifications.get(params.id);\n\n    if (pendingCompletion) {\n      this._pendingCompletionNotifications.delete(params.id);\n\n      return pendingCompletion;\n    }\n\n    const promise = new Promise<TaskRunExecutionResult>((resolve) => {\n      this._taskWaits.set(params.id, { resolve });\n    });\n\n    return await promise;\n  }\n\n  async waitForBatch(params: {\n    id: string;\n    runs: string[];\n    ctx: TaskRunContext;\n  }): Promise<BatchTaskRunExecutionResult> {\n    if (!params.runs.length) {\n      return Promise.resolve({ id: params.id, items: [] });\n    }\n\n    const promise = Promise.all(\n      params.runs.map((runId) => {\n        return new Promise<TaskRunExecutionResult>((resolve, reject) => {\n          const pendingCompletion = this._pendingCompletionNotifications.get(runId);\n\n          if (pendingCompletion) {\n            this._pendingCompletionNotifications.delete(runId);\n\n            resolve(pendingCompletion);\n\n            return;\n          }\n\n          this._taskWaits.set(runId, { resolve });\n        });\n      })\n    );\n\n    const results = await promise;\n\n    return {\n      id: params.id,\n      items: results,\n    };\n  }\n\n  resumeTask(completion: TaskRunExecutionResult, runId: string): void {\n    const wait = this._taskWaits.get(runId);\n\n    if (!wait) {\n      // We need to store the completion in case the task is awaited later\n      this._pendingCompletionNotifications.set(runId, completion);\n\n      return;\n    }\n\n    wait.resolve(completion);\n\n    this._taskWaits.delete(runId);\n  }\n}\n", "import { z } from \"zod\";\nimport { StructuredLogger } from \"./utils/structuredLogger\";\n\nexport class ZodSchemaParsedError extends Error {\n  constructor(\n    public error: z.ZodError,\n    public payload: unknown\n  ) {\n    super(error.message);\n  }\n}\n\nexport type ZodMessageValueSchema<TDiscriminatedUnion extends z.ZodDiscriminatedUnion<any, any>> =\n  | z.ZodFirstPartySchemaTypes\n  | TDiscriminatedUnion;\n\nexport interface ZodMessageCatalogSchema {\n  [key: string]: ZodMessageValueSchema<any>;\n}\n\nexport type ZodMessageHandlers<TCatalogSchema extends ZodMessageCatalogSchema> = Partial<{\n  [K in keyof TCatalogSchema]: (payload: z.infer<TCatalogSchema[K]>) => Promise<any>;\n}>;\n\nexport type ZodMessageHandlerOptions<TMessageCatalog extends ZodMessageCatalogSchema> = {\n  schema: TMessageCatalog;\n  messages?: ZodMessageHandlers<TMessageCatalog>;\n  logger?: StructuredLogger;\n};\n\nexport type MessageFromSchema<\n  K extends keyof TMessageCatalog,\n  TMessageCatalog extends ZodMessageCatalogSchema,\n> = {\n  type: K;\n  payload: z.input<TMessageCatalog[K]>;\n};\n\nexport type MessageFromCatalog<TMessageCatalog extends ZodMessageCatalogSchema> = {\n  [K in keyof TMessageCatalog]: MessageFromSchema<K, TMessageCatalog>;\n}[keyof TMessageCatalog];\n\nexport const ZodMessageSchema = z.object({\n  version: z.literal(\"v1\").default(\"v1\"),\n  type: z.string(),\n  payload: z.unknown(),\n});\n\nexport interface EventEmitterLike {\n  on(eventName: string | symbol, listener: (...args: any[]) => void): this;\n}\n\nexport class ZodMessageHandler<TMessageCatalog extends ZodMessageCatalogSchema> {\n  #schema: TMessageCatalog;\n  #handlers: ZodMessageHandlers<TMessageCatalog> | undefined;\n  #logger: StructuredLogger | Console;\n\n  constructor(options: ZodMessageHandlerOptions<TMessageCatalog>) {\n    this.#schema = options.schema;\n    this.#handlers = options.messages;\n    this.#logger = options.logger ?? console;\n  }\n\n  public async handleMessage(message: unknown): Promise<\n    | {\n        success: true;\n        data: unknown;\n      }\n    | {\n        success: false;\n        error: string;\n      }\n  > {\n    const parsedMessage = this.parseMessage(message);\n\n    if (!parsedMessage.success) {\n      this.#logger.error(parsedMessage.error, { message });\n\n      return {\n        success: false,\n        error: parsedMessage.error,\n      };\n    }\n\n    if (!this.#handlers) {\n      this.#logger.error(\"No handlers provided\", { message });\n\n      return {\n        success: false,\n        error: \"No handlers provided\",\n      };\n    }\n\n    const handler = this.#handlers[parsedMessage.data.type];\n\n    if (!handler) {\n      const error = `No handler for message type: ${String(parsedMessage.data.type)}`;\n\n      this.#logger.error(error, { message });\n\n      return {\n        success: false,\n        error,\n      };\n    }\n\n    const ack = await handler(parsedMessage.data.payload);\n\n    return {\n      success: true,\n      data: ack,\n    };\n  }\n\n  public parseMessage(message: unknown):\n    | {\n        success: true;\n        data: MessageFromCatalog<TMessageCatalog>;\n      }\n    | {\n        success: false;\n        error: string;\n      } {\n    const parsedMessage = ZodMessageSchema.safeParse(message);\n\n    if (!parsedMessage.success) {\n      return {\n        success: false,\n        error: `Failed to parse message: ${JSON.stringify(parsedMessage.error)}`,\n      };\n    }\n\n    const schema = this.#schema[parsedMessage.data.type];\n\n    if (!schema) {\n      return {\n        success: false,\n        error: `Unknown message type: ${parsedMessage.data.type}`,\n      };\n    }\n\n    const parsedPayload = schema.safeParse(parsedMessage.data.payload);\n\n    if (!parsedPayload.success) {\n      return {\n        success: false,\n        error: `Failed to parse message payload: ${JSON.stringify(parsedPayload.error)}`,\n      };\n    }\n\n    return {\n      success: true,\n      data: {\n        type: parsedMessage.data.type,\n        payload: parsedPayload.data,\n      },\n    };\n  }\n\n  public registerHandlers(emitter: EventEmitterLike, logger?: StructuredLogger) {\n    const log = logger ?? console;\n\n    if (!this.#handlers) {\n      log.info(\"No handlers provided\");\n      return;\n    }\n\n    for (const eventName of Object.keys(this.#schema)) {\n      emitter.on(eventName, async (message: any, callback?: any): Promise<void> => {\n        log.info(`handling ${eventName}`, {\n          payload: message,\n          hasCallback: !!callback,\n        });\n\n        let ack: Awaited<ReturnType<ZodMessageHandler<TMessageCatalog>[\"handleMessage\"]>>;\n\n        // FIXME: this only works if the message doesn't have genuine payload prop\n        if (\"payload\" in message) {\n          ack = await this.handleMessage({ type: eventName, ...message });\n        } else {\n          // Handle messages not sent by ZodMessageSender\n          const { version, ...payload } = message;\n          ack = await this.handleMessage({ type: eventName, version, payload });\n        }\n\n        if (callback && typeof callback === \"function\") {\n          if (!ack.success) {\n            // We don't know the callback type, so we can't do anything else - not all callbacks may accept a success prop\n            log.error(\"Failed to handle message, skipping callback\", { message, error: ack.error });\n            return;\n          }\n\n          callback(ack.data);\n        }\n      });\n    }\n  }\n}\n\ntype ZodMessageSenderCallback<TMessageCatalog extends ZodMessageCatalogSchema> = (message: {\n  type: keyof TMessageCatalog;\n  payload: z.infer<TMessageCatalog[keyof TMessageCatalog]>;\n  version: \"v1\";\n}) => Promise<void>;\n\nexport type ZodMessageSenderOptions<TMessageCatalog extends ZodMessageCatalogSchema> = {\n  schema: TMessageCatalog;\n  sender: ZodMessageSenderCallback<TMessageCatalog>;\n};\n\nexport class ZodMessageSender<TMessageCatalog extends ZodMessageCatalogSchema> {\n  #schema: TMessageCatalog;\n  #sender: ZodMessageSenderCallback<TMessageCatalog>;\n\n  constructor(options: ZodMessageSenderOptions<TMessageCatalog>) {\n    this.#schema = options.schema;\n    this.#sender = options.sender;\n  }\n\n  public async send<K extends keyof TMessageCatalog>(\n    type: K,\n    payload: z.input<TMessageCatalog[K]>\n  ) {\n    const schema = this.#schema[type];\n\n    if (!schema) {\n      throw new Error(`Unknown message type: ${type as string}`);\n    }\n\n    const parsedPayload = schema.safeParse(payload);\n\n    if (!parsedPayload.success) {\n      throw new ZodSchemaParsedError(parsedPayload.error, payload);\n    }\n\n    try {\n      await this.#sender({ type, payload, version: \"v1\" });\n    } catch (error) {\n      console.error(\"[ZodMessageSender] Failed to send message\", error);\n    }\n  }\n\n  public async forwardMessage(message: unknown) {\n    const parsedMessage = ZodMessageSchema.safeParse(message);\n\n    if (!parsedMessage.success) {\n      throw new Error(`Failed to parse message: ${JSON.stringify(parsedMessage.error)}`);\n    }\n\n    const schema = this.#schema[parsedMessage.data.type];\n\n    if (!schema) {\n      throw new Error(`Unknown message type: ${parsedMessage.data.type}`);\n    }\n\n    const parsedPayload = schema.safeParse(parsedMessage.data.payload);\n\n    if (!parsedPayload.success) {\n      throw new Error(`Failed to parse message payload: ${JSON.stringify(parsedPayload.error)}`);\n    }\n\n    try {\n      await this.#sender({\n        type: parsedMessage.data.type,\n        payload: parsedPayload.data,\n        version: \"v1\",\n      });\n    } catch (error) {\n      console.error(\"[ZodMessageSender] Failed to forward message\", error);\n    }\n  }\n}\n\nexport type MessageCatalogToSocketIoEvents<TCatalog extends ZodMessageCatalogSchema> = {\n  [K in keyof TCatalog]: (message: z.infer<TCatalog[K]>) => void;\n};\n", "export const version = '2.45.4'\n", "// constants.ts\nimport { RealtimeClientOptions } from '@supabase/realtime-js'\nimport { SupabaseAuthClientOptions } from './types'\nimport { version } from './version'\n\nlet JS_ENV = ''\n// @ts-ignore\nif (typeof Deno !== 'undefined') {\n  JS_ENV = 'deno'\n} else if (typeof document !== 'undefined') {\n  JS_ENV = 'web'\n} else if (typeof navigator !== 'undefined' && navigator.product === 'ReactNative') {\n  JS_ENV = 'react-native'\n} else {\n  JS_ENV = 'node'\n}\n\nexport const DEFAULT_HEADERS = { 'X-Client-Info': `supabase-js-${JS_ENV}/${version}` }\n\nexport const DEFAULT_GLOBAL_OPTIONS = {\n  headers: DEFAULT_HEADERS,\n}\n\nexport const DEFAULT_DB_OPTIONS = {\n  schema: 'public',\n}\n\nexport const DEFAULT_AUTH_OPTIONS: SupabaseAuthClientOptions = {\n  autoRefreshToken: true,\n  persistSession: true,\n  detectSessionInUrl: true,\n  flowType: 'implicit',\n}\n\nexport const DEFAULT_REALTIME_OPTIONS: RealtimeClientOptions = {}\n", "// @ts-ignore\nimport nodeFetch, { Headers as NodeFetchHeaders } from '@supabase/node-fetch'\n\ntype Fetch = typeof fetch\n\nexport const resolveFetch = (customFetch?: Fetch): Fetch => {\n  let _fetch: Fetch\n  if (customFetch) {\n    _fetch = customFetch\n  } else if (typeof fetch === 'undefined') {\n    _fetch = nodeFetch as unknown as Fetch\n  } else {\n    _fetch = fetch\n  }\n  return (...args: Parameters<Fetch>) => _fetch(...args)\n}\n\nexport const resolveHeadersConstructor = () => {\n  if (typeof Headers === 'undefined') {\n    return NodeFetchHeaders\n  }\n\n  return Headers\n}\n\nexport const fetchWithAuth = (\n  supabaseKey: string,\n  getAccessToken: () => Promise<string | null>,\n  customFetch?: Fetch\n): Fetch => {\n  const fetch = resolveFetch(customFetch)\n  const HeadersConstructor = resolveHeadersConstructor()\n\n  return async (input, init) => {\n    const accessToken = (await getAccessToken()) ?? supabaseKey\n    let headers = new HeadersConstructor(init?.headers)\n\n    if (!headers.has('apikey')) {\n      headers.set('apikey', supabaseKey)\n    }\n\n    if (!headers.has('Authorization')) {\n      headers.set('Authorization', `Bearer ${accessToken}`)\n    }\n\n    return fetch(input, { ...init, headers })\n  }\n}\n", "// helpers.ts\nimport { SupabaseClientOptions } from './types'\n\nexport function uuid() {\n  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {\n    var r = (Math.random() * 16) | 0,\n      v = c == 'x' ? r : (r & 0x3) | 0x8\n    return v.toString(16)\n  })\n}\n\nexport function stripTrailingSlash(url: string): string {\n  return url.replace(/\\/$/, '')\n}\n\nexport const isBrowser = () => typeof window !== 'undefined'\n\nexport function applySettingDefaults<\n  Database = any,\n  SchemaName extends string & keyof Database = 'public' extends keyof Database\n    ? 'public'\n    : string & keyof Database\n>(\n  options: SupabaseClientOptions<SchemaName>,\n  defaults: SupabaseClientOptions<any>\n): Required<SupabaseClientOptions<SchemaName>> {\n  const {\n    db: dbOptions,\n    auth: authOptions,\n    realtime: realtimeOptions,\n    global: globalOptions,\n  } = options\n  const {\n    db: DEFAULT_DB_OPTIONS,\n    auth: DEFAULT_AUTH_OPTIONS,\n    realtime: DEFAULT_REALTIME_OPTIONS,\n    global: DEFAULT_GLOBAL_OPTIONS,\n  } = defaults\n\n  const result: Required<SupabaseClientOptions<SchemaName>> = {\n    db: {\n      ...DEFAULT_DB_OPTIONS,\n      ...dbOptions,\n    },\n    auth: {\n      ...DEFAULT_AUTH_OPTIONS,\n      ...authOptions,\n    },\n    realtime: {\n      ...DEFAULT_REALTIME_OPTIONS,\n      ...realtimeOptions,\n    },\n    global: {\n      ...DEFAULT_GLOBAL_OPTIONS,\n      ...globalOptions,\n    },\n    accessToken: async () => '',\n  }\n\n  if (options.accessToken) {\n    result.accessToken = options.accessToken\n  } else {\n    // hack around Required<>\n    delete (result as any).accessToken\n  }\n\n  return result\n}\n", "import { AuthClient } from '@supabase/auth-js'\nimport { SupabaseAuthClientOptions } from './types'\n\nexport class SupabaseAuthClient extends AuthClient {\n  constructor(options: SupabaseAuthClientOptions) {\n    super(options)\n  }\n}\n", "import { FunctionsClient } from '@supabase/functions-js'\nimport { AuthChangeEvent } from '@supabase/auth-js'\nimport {\n  PostgrestClient,\n  PostgrestFilterBuilder,\n  PostgrestQueryBuilder,\n} from '@supabase/postgrest-js'\nimport {\n  RealtimeChannel,\n  RealtimeChannelOptions,\n  RealtimeClient,\n  RealtimeClientOptions,\n} from '@supabase/realtime-js'\nimport { StorageClient as SupabaseStorageClient } from '@supabase/storage-js'\nimport {\n  DEFAULT_GLOBAL_OPTIONS,\n  DEFAULT_DB_OPTIONS,\n  DEFAULT_AUTH_OPTIONS,\n  DEFAULT_REALTIME_OPTIONS,\n} from './lib/constants'\nimport { fetchWithAuth } from './lib/fetch'\nimport { stripTrailingSlash, applySettingDefaults } from './lib/helpers'\nimport { SupabaseAuthClient } from './lib/SupabaseAuthClient'\nimport { Fetch, GenericSchema, SupabaseClientOptions, SupabaseAuthClientOptions } from './lib/types'\n\n/**\n * Supabase Client.\n *\n * An isomorphic Javascript client for interacting with Postgres.\n */\nexport default class SupabaseClient<\n  Database = any,\n  SchemaName extends string & keyof Database = 'public' extends keyof Database\n    ? 'public'\n    : string & keyof Database,\n  Schema extends GenericSchema = Database[SchemaName] extends GenericSchema\n    ? Database[SchemaName]\n    : any\n> {\n  /**\n   * Supabase Auth allows you to create and manage user sessions for access to data that is secured by access policies.\n   */\n  auth: SupabaseAuthClient\n  realtime: RealtimeClient\n\n  protected realtimeUrl: string\n  protected authUrl: string\n  protected storageUrl: string\n  protected functionsUrl: string\n  protected rest: PostgrestClient<Database, SchemaName>\n  protected storageKey: string\n  protected fetch?: Fetch\n  protected changedAccessToken?: string\n  protected accessToken?: () => Promise<string>\n\n  protected headers: Record<string, string>\n\n  /**\n   * Create a new client for use in the browser.\n   * @param supabaseUrl The unique Supabase URL which is supplied when you create a new project in your project dashboard.\n   * @param supabaseKey The unique Supabase Key which is supplied when you create a new project in your project dashboard.\n   * @param options.db.schema You can switch in between schemas. The schema needs to be on the list of exposed schemas inside Supabase.\n   * @param options.auth.autoRefreshToken Set to \"true\" if you want to automatically refresh the token before expiring.\n   * @param options.auth.persistSession Set to \"true\" if you want to automatically save the user session into local storage.\n   * @param options.auth.detectSessionInUrl Set to \"true\" if you want to automatically detects OAuth grants in the URL and signs in the user.\n   * @param options.realtime Options passed along to realtime-js constructor.\n   * @param options.global.fetch A custom fetch implementation.\n   * @param options.global.headers Any additional headers to send with each network request.\n   */\n  constructor(\n    protected supabaseUrl: string,\n    protected supabaseKey: string,\n    options?: SupabaseClientOptions<SchemaName>\n  ) {\n    if (!supabaseUrl) throw new Error('supabaseUrl is required.')\n    if (!supabaseKey) throw new Error('supabaseKey is required.')\n\n    const _supabaseUrl = stripTrailingSlash(supabaseUrl)\n\n    this.realtimeUrl = `${_supabaseUrl}/realtime/v1`.replace(/^http/i, 'ws')\n    this.authUrl = `${_supabaseUrl}/auth/v1`\n    this.storageUrl = `${_supabaseUrl}/storage/v1`\n    this.functionsUrl = `${_supabaseUrl}/functions/v1`\n\n    // default storage key uses the supabase project ref as a namespace\n    const defaultStorageKey = `sb-${new URL(this.authUrl).hostname.split('.')[0]}-auth-token`\n    const DEFAULTS = {\n      db: DEFAULT_DB_OPTIONS,\n      realtime: DEFAULT_REALTIME_OPTIONS,\n      auth: { ...DEFAULT_AUTH_OPTIONS, storageKey: defaultStorageKey },\n      global: DEFAULT_GLOBAL_OPTIONS,\n    }\n\n    const settings = applySettingDefaults(options ?? {}, DEFAULTS)\n\n    this.storageKey = settings.auth.storageKey ?? ''\n    this.headers = settings.global.headers ?? {}\n\n    if (!settings.accessToken) {\n      this.auth = this._initSupabaseAuthClient(\n        settings.auth ?? {},\n        this.headers,\n        settings.global.fetch\n      )\n    } else {\n      this.accessToken = settings.accessToken\n\n      this.auth = new Proxy<SupabaseAuthClient>({} as any, {\n        get: (_, prop) => {\n          throw new Error(\n            `@supabase/supabase-js: Supabase Client is configured with the accessToken option, accessing supabase.auth.${String(\n              prop\n            )} is not possible`\n          )\n        },\n      })\n    }\n\n    this.fetch = fetchWithAuth(supabaseKey, this._getAccessToken.bind(this), settings.global.fetch)\n\n    this.realtime = this._initRealtimeClient({ headers: this.headers, ...settings.realtime })\n    this.rest = new PostgrestClient(`${_supabaseUrl}/rest/v1`, {\n      headers: this.headers,\n      schema: settings.db.schema,\n      fetch: this.fetch,\n    })\n\n    if (!settings.accessToken) {\n      this._listenForAuthEvents()\n    }\n  }\n\n  /**\n   * Supabase Functions allows you to deploy and invoke edge functions.\n   */\n  get functions(): FunctionsClient {\n    return new FunctionsClient(this.functionsUrl, {\n      headers: this.headers,\n      customFetch: this.fetch,\n    })\n  }\n\n  /**\n   * Supabase Storage allows you to manage user-generated content, such as photos or videos.\n   */\n  get storage(): SupabaseStorageClient {\n    return new SupabaseStorageClient(this.storageUrl, this.headers, this.fetch)\n  }\n\n  // NOTE: signatures must be kept in sync with PostgrestClient.from\n  from<\n    TableName extends string & keyof Schema['Tables'],\n    Table extends Schema['Tables'][TableName]\n  >(relation: TableName): PostgrestQueryBuilder<Schema, Table, TableName>\n  from<ViewName extends string & keyof Schema['Views'], View extends Schema['Views'][ViewName]>(\n    relation: ViewName\n  ): PostgrestQueryBuilder<Schema, View, ViewName>\n  /**\n   * Perform a query on a table or a view.\n   *\n   * @param relation - The table or view name to query\n   */\n  from(relation: string): PostgrestQueryBuilder<Schema, any, any> {\n    return this.rest.from(relation)\n  }\n\n  // NOTE: signatures must be kept in sync with PostgrestClient.schema\n  /**\n   * Select a schema to query or perform an function (rpc) call.\n   *\n   * The schema needs to be on the list of exposed schemas inside Supabase.\n   *\n   * @param schema - The schema to query\n   */\n  schema<DynamicSchema extends string & keyof Database>(\n    schema: DynamicSchema\n  ): PostgrestClient<\n    Database,\n    DynamicSchema,\n    Database[DynamicSchema] extends GenericSchema ? Database[DynamicSchema] : any\n  > {\n    return this.rest.schema<DynamicSchema>(schema)\n  }\n\n  // NOTE: signatures must be kept in sync with PostgrestClient.rpc\n  /**\n   * Perform a function call.\n   *\n   * @param fn - The function name to call\n   * @param args - The arguments to pass to the function call\n   * @param options - Named parameters\n   * @param options.head - When set to `true`, `data` will not be returned.\n   * Useful if you only need the count.\n   * @param options.get - When set to `true`, the function will be called with\n   * read-only access mode.\n   * @param options.count - Count algorithm to use to count rows returned by the\n   * function. Only applicable for [set-returning\n   * functions](https://www.postgresql.org/docs/current/functions-srf.html).\n   *\n   * `\"exact\"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the\n   * hood.\n   *\n   * `\"planned\"`: Approximated but fast count algorithm. Uses the Postgres\n   * statistics under the hood.\n   *\n   * `\"estimated\"`: Uses exact count for low numbers and planned count for high\n   * numbers.\n   */\n  rpc<FnName extends string & keyof Schema['Functions'], Fn extends Schema['Functions'][FnName]>(\n    fn: FnName,\n    args: Fn['Args'] = {},\n    options: {\n      head?: boolean\n      get?: boolean\n      count?: 'exact' | 'planned' | 'estimated'\n    } = {}\n  ): PostgrestFilterBuilder<\n    Schema,\n    Fn['Returns'] extends any[]\n      ? Fn['Returns'][number] extends Record<string, unknown>\n        ? Fn['Returns'][number]\n        : never\n      : never,\n    Fn['Returns']\n  > {\n    return this.rest.rpc(fn, args, options)\n  }\n\n  /**\n   * Creates a Realtime channel with Broadcast, Presence, and Postgres Changes.\n   *\n   * @param {string} name - The name of the Realtime channel.\n   * @param {Object} opts - The options to pass to the Realtime channel.\n   *\n   */\n  channel(name: string, opts: RealtimeChannelOptions = { config: {} }): RealtimeChannel {\n    return this.realtime.channel(name, opts)\n  }\n\n  /**\n   * Returns all Realtime channels.\n   */\n  getChannels(): RealtimeChannel[] {\n    return this.realtime.getChannels()\n  }\n\n  /**\n   * Unsubscribes and removes Realtime channel from Realtime client.\n   *\n   * @param {RealtimeChannel} channel - The name of the Realtime channel.\n   *\n   */\n  removeChannel(channel: RealtimeChannel): Promise<'ok' | 'timed out' | 'error'> {\n    return this.realtime.removeChannel(channel)\n  }\n\n  /**\n   * Unsubscribes and removes all Realtime channels from Realtime client.\n   */\n  removeAllChannels(): Promise<('ok' | 'timed out' | 'error')[]> {\n    return this.realtime.removeAllChannels()\n  }\n\n  private async _getAccessToken() {\n    if (this.accessToken) {\n      return await this.accessToken()\n    }\n\n    const { data } = await this.auth.getSession()\n\n    return data.session?.access_token ?? null\n  }\n\n  private _initSupabaseAuthClient(\n    {\n      autoRefreshToken,\n      persistSession,\n      detectSessionInUrl,\n      storage,\n      storageKey,\n      flowType,\n      lock,\n      debug,\n    }: SupabaseAuthClientOptions,\n    headers?: Record<string, string>,\n    fetch?: Fetch\n  ) {\n    const authHeaders = {\n      Authorization: `Bearer ${this.supabaseKey}`,\n      apikey: `${this.supabaseKey}`,\n    }\n    return new SupabaseAuthClient({\n      url: this.authUrl,\n      headers: { ...authHeaders, ...headers },\n      storageKey: storageKey,\n      autoRefreshToken,\n      persistSession,\n      detectSessionInUrl,\n      storage,\n      flowType,\n      lock,\n      debug,\n      fetch,\n      // auth checks if there is a custom authorizaiton header using this flag\n      // so it knows whether to return an error when getUser is called with no session\n      hasCustomAuthorizationHeader: 'Authorization' in this.headers ?? false,\n    })\n  }\n\n  private _initRealtimeClient(options: RealtimeClientOptions) {\n    return new RealtimeClient(this.realtimeUrl, {\n      ...options,\n      params: { ...{ apikey: this.supabaseKey }, ...options?.params },\n    })\n  }\n\n  private _listenForAuthEvents() {\n    let data = this.auth.onAuthStateChange((event, session) => {\n      this._handleTokenChanged(event, 'CLIENT', session?.access_token)\n    })\n    return data\n  }\n\n  private _handleTokenChanged(\n    event: AuthChangeEvent,\n    source: 'CLIENT' | 'STORAGE',\n    token?: string\n  ) {\n    if (\n      (event === 'TOKEN_REFRESHED' || event === 'SIGNED_IN') &&\n      this.changedAccessToken !== token\n    ) {\n      // Token has changed\n      this.realtime.setAuth(token ?? null)\n\n      this.changedAccessToken = token\n    } else if (event === 'SIGNED_OUT') {\n      // Token is removed\n      this.realtime.setAuth(this.supabaseKey)\n      if (source == 'STORAGE') this.auth.signOut()\n      this.changedAccessToken = undefined\n    }\n  }\n}\n", "import SupabaseClient from './SupabaseClient'\nimport type { GenericSchema, SupabaseClientOptions } from './lib/types'\n\nexport * from '@supabase/auth-js'\nexport type { User as AuthUser, Session as AuthSession } from '@supabase/auth-js'\nexport type {\n  PostgrestResponse,\n  PostgrestSingleResponse,\n  PostgrestMaybeSingleResponse,\n  PostgrestError,\n} from '@supabase/postgrest-js'\nexport {\n  FunctionsHttpError,\n  FunctionsFetchError,\n  FunctionsRelayError,\n  FunctionsError,\n  type FunctionInvokeOptions,\n  FunctionRegion,\n} from '@supabase/functions-js'\nexport * from '@supabase/realtime-js'\nexport { default as SupabaseClient } from './SupabaseClient'\nexport type { SupabaseClientOptions, QueryResult, QueryData, QueryError } from './lib/types'\n\n/**\n * Creates a new Supabase Client.\n */\nexport const createClient = <\n  Database = any,\n  SchemaName extends string & keyof Database = 'public' extends keyof Database\n    ? 'public'\n    : string & keyof Database,\n  Schema extends GenericSchema = Database[SchemaName] extends GenericSchema\n    ? Database[SchemaName]\n    : any\n>(\n  supabaseUrl: string,\n  supabaseKey: string,\n  options?: SupabaseClientOptions<SchemaName>\n): SupabaseClient<Database, SchemaName, Schema> => {\n  return new SupabaseClient<Database, SchemaName, Schema>(supabaseUrl, supabaseKey, options)\n}\n", "import { z } from \"zod\";\nimport { fromZodError } from \"zod-validation-error\";\nimport { RetryOptions } from \"../schemas\";\nimport { calculateNextRetryDelay } from \"../utils/retries\";\nimport { ApiConnectionError, ApiError } from \"./errors\";\n\nimport { Attributes, Span } from \"@opentelemetry/api\";\nimport { SemanticInternalAttributes } from \"../semanticInternalAttributes\";\nimport { TriggerTracer } from \"../tracer\";\nimport { accessoryAttributes } from \"../utils/styleAttributes\";\nimport {\n  CursorPage,\n  CursorPageParams,\n  CursorPageResponse,\n  OffsetLimitPage,\n  OffsetLimitPageParams,\n  OffsetLimitPageResponse,\n} from \"./pagination\";\n\nexport const defaultRetryOptions = {\n  maxAttempts: 3,\n  factor: 2,\n  minTimeoutInMs: 1000,\n  maxTimeoutInMs: 60000,\n  randomize: false,\n} satisfies RetryOptions;\n\nexport type ZodFetchOptions = {\n  retry?: RetryOptions;\n  tracer?: TriggerTracer;\n  name?: string;\n  attributes?: Attributes;\n  icon?: string;\n  onResponseBody?: (body: unknown, span: Span) => void;\n};\n\nexport type ApiRequestOptions = Pick<ZodFetchOptions, \"retry\">;\ntype KeysEnum<T> = { [P in keyof Required<T>]: true };\n\n// This is required so that we can determine if a given object matches the ApiRequestOptions\n// type at runtime. While this requires duplication, it is enforced by the TypeScript\n// compiler such that any missing / extraneous keys will cause an error.\nconst requestOptionsKeys: KeysEnum<ApiRequestOptions> = {\n  retry: true,\n};\n\nexport const isRequestOptions = (obj: unknown): obj is ApiRequestOptions => {\n  return (\n    typeof obj === \"object\" &&\n    obj !== null &&\n    !isEmptyObj(obj) &&\n    Object.keys(obj).every((k) => hasOwn(requestOptionsKeys, k))\n  );\n};\n\ninterface FetchCursorPageParams extends CursorPageParams {\n  query?: URLSearchParams;\n}\n\ninterface FetchOffsetLimitPageParams extends OffsetLimitPageParams {\n  query?: URLSearchParams;\n}\n\nexport function zodfetch<TResponseBodySchema extends z.ZodTypeAny>(\n  schema: TResponseBodySchema,\n  url: string,\n  requestInit?: RequestInit,\n  options?: ZodFetchOptions\n): ApiPromise<z.output<TResponseBodySchema>> {\n  return new ApiPromise(_doZodFetch(schema, url, requestInit, options));\n}\n\nexport function zodfetchCursorPage<TItemSchema extends z.ZodTypeAny>(\n  schema: TItemSchema,\n  url: string,\n  params: FetchCursorPageParams,\n  requestInit?: RequestInit,\n  options?: ZodFetchOptions\n) {\n  const query = new URLSearchParams(params.query);\n\n  if (params.limit) {\n    query.set(\"page[size]\", String(params.limit));\n  }\n\n  if (params.after) {\n    query.set(\"page[after]\", params.after);\n  }\n\n  if (params.before) {\n    query.set(\"page[before]\", params.before);\n  }\n\n  const cursorPageSchema = z.object({\n    data: z.array(schema),\n    pagination: z.object({\n      next: z.string().optional(),\n      previous: z.string().optional(),\n    }),\n  });\n\n  const $url = new URL(url);\n  $url.search = query.toString();\n\n  const fetchResult = _doZodFetch(cursorPageSchema, $url.href, requestInit, options);\n\n  return new CursorPagePromise(fetchResult, schema, url, params, requestInit, options);\n}\n\nexport function zodfetchOffsetLimitPage<TItemSchema extends z.ZodTypeAny>(\n  schema: TItemSchema,\n  url: string,\n  params: FetchOffsetLimitPageParams,\n  requestInit?: RequestInit,\n  options?: ZodFetchOptions\n) {\n  const query = new URLSearchParams(params.query);\n\n  if (params.limit) {\n    query.set(\"perPage\", String(params.limit));\n  }\n\n  if (params.page) {\n    query.set(\"page\", String(params.page));\n  }\n\n  const offsetLimitPageSchema = z.object({\n    data: z.array(schema),\n    pagination: z.object({\n      currentPage: z.coerce.number(),\n      totalPages: z.coerce.number(),\n      count: z.coerce.number(),\n    }),\n  });\n\n  const $url = new URL(url);\n  $url.search = query.toString();\n\n  const fetchResult = _doZodFetch(offsetLimitPageSchema, $url.href, requestInit, options);\n\n  return new OffsetLimitPagePromise(fetchResult, schema, url, params, requestInit, options);\n}\n\ntype ZodFetchResult<T> = {\n  data: T;\n  response: Response;\n};\n\ntype PromiseOrValue<T> = T | Promise<T>;\n\nasync function traceZodFetch<T>(\n  params: {\n    url: string;\n    requestInit?: RequestInit;\n    options?: ZodFetchOptions;\n  },\n  callback: (span?: Span) => Promise<T>\n): Promise<T> {\n  if (!params.options?.tracer) {\n    return callback();\n  }\n\n  const url = new URL(params.url);\n  const method = params.requestInit?.method ?? \"GET\";\n  const name = params.options.name ?? `${method} ${url.pathname}`;\n\n  return await params.options.tracer.startActiveSpan(\n    name,\n    async (span) => {\n      return await callback(span);\n    },\n    {\n      attributes: {\n        [SemanticInternalAttributes.STYLE_ICON]: params.options?.icon ?? \"api\",\n        ...params.options.attributes,\n      },\n    }\n  );\n}\n\nasync function _doZodFetch<TResponseBodySchema extends z.ZodTypeAny>(\n  schema: TResponseBodySchema,\n  url: string,\n  requestInit?: PromiseOrValue<RequestInit>,\n  options?: ZodFetchOptions\n): Promise<ZodFetchResult<z.output<TResponseBodySchema>>> {\n  const $requestInit = await requestInit;\n\n  return traceZodFetch({ url, requestInit: $requestInit, options }, async (span) => {\n    const result = await _doZodFetchWithRetries(schema, url, $requestInit, options);\n\n    if (options?.onResponseBody && span) {\n      options.onResponseBody(result.data, span);\n    }\n\n    return result;\n  });\n}\n\nasync function _doZodFetchWithRetries<TResponseBodySchema extends z.ZodTypeAny>(\n  schema: TResponseBodySchema,\n  url: string,\n  requestInit?: RequestInit,\n  options?: ZodFetchOptions,\n  attempt = 1\n): Promise<ZodFetchResult<z.output<TResponseBodySchema>>> {\n  try {\n    const response = await fetch(url, requestInitWithCache(requestInit));\n\n    const responseHeaders = createResponseHeaders(response.headers);\n\n    if (!response.ok) {\n      const retryResult = shouldRetry(response, attempt, options?.retry);\n\n      if (retryResult.retry) {\n        await waitForRetry(url, attempt + 1, retryResult.delay, options, requestInit, response);\n\n        return await _doZodFetchWithRetries(schema, url, requestInit, options, attempt + 1);\n      } else {\n        const errText = await response.text().catch((e) => castToError(e).message);\n        const errJSON = safeJsonParse(errText);\n        const errMessage = errJSON ? undefined : errText;\n\n        throw ApiError.generate(response.status, errJSON, errMessage, responseHeaders);\n      }\n    }\n\n    const jsonBody = await response.json();\n    const parsedResult = schema.safeParse(jsonBody);\n\n    if (parsedResult.success) {\n      return { data: parsedResult.data, response };\n    }\n\n    throw fromZodError(parsedResult.error);\n  } catch (error) {\n    if (error instanceof ApiError) {\n      throw error;\n    }\n\n    if (options?.retry) {\n      const retry = { ...defaultRetryOptions, ...options.retry };\n\n      const delay = calculateNextRetryDelay(retry, attempt);\n\n      if (delay) {\n        await waitForRetry(url, attempt + 1, delay, options, requestInit);\n\n        return await _doZodFetchWithRetries(schema, url, requestInit, options, attempt + 1);\n      }\n    }\n\n    throw new ApiConnectionError({ cause: castToError(error) });\n  }\n}\n\nfunction castToError(err: any): Error {\n  if (err instanceof Error) return err;\n  return new Error(err);\n}\n\ntype ShouldRetryResult =\n  | {\n      retry: false;\n    }\n  | {\n      retry: true;\n      delay: number;\n    };\n\nfunction shouldRetry(\n  response: Response,\n  attempt: number,\n  retryOptions?: RetryOptions\n): ShouldRetryResult {\n  function shouldRetryForOptions(): ShouldRetryResult {\n    const retry = { ...defaultRetryOptions, ...retryOptions };\n\n    const delay = calculateNextRetryDelay(retry, attempt);\n\n    if (delay) {\n      return { retry: true, delay };\n    } else {\n      return { retry: false };\n    }\n  }\n\n  // Note this is not a standard header.\n  const shouldRetryHeader = response.headers.get(\"x-should-retry\");\n\n  // If the server explicitly says whether or not to retry, obey.\n  if (shouldRetryHeader === \"true\") return shouldRetryForOptions();\n  if (shouldRetryHeader === \"false\") return { retry: false };\n\n  // Retry on request timeouts.\n  if (response.status === 408) return shouldRetryForOptions();\n\n  // Retry on lock timeouts.\n  if (response.status === 409) return shouldRetryForOptions();\n\n  // Retry on rate limits.\n  if (response.status === 429) {\n    if (\n      attempt >= (typeof retryOptions?.maxAttempts === \"number\" ? retryOptions?.maxAttempts : 3)\n    ) {\n      return { retry: false };\n    }\n\n    // x-ratelimit-reset is the unix timestamp in milliseconds when the rate limit will reset.\n    const resetAtUnixEpochMs = response.headers.get(\"x-ratelimit-reset\");\n\n    if (resetAtUnixEpochMs) {\n      const resetAtUnixEpoch = parseInt(resetAtUnixEpochMs, 10);\n      const delay = resetAtUnixEpoch - Date.now() + Math.floor(Math.random() * 1000);\n\n      if (delay > 0) {\n        return { retry: true, delay };\n      }\n    }\n\n    return shouldRetryForOptions();\n  }\n\n  // Retry internal errors.\n  if (response.status >= 500) return shouldRetryForOptions();\n\n  return { retry: false };\n}\n\nfunction safeJsonParse(text: string): any {\n  try {\n    return JSON.parse(text);\n  } catch (e) {\n    return undefined;\n  }\n}\n\nfunction createResponseHeaders(headers: Response[\"headers\"]): Record<string, string> {\n  return new Proxy(\n    Object.fromEntries(\n      // @ts-ignore\n      headers.entries()\n    ),\n    {\n      get(target, name) {\n        const key = name.toString();\n        return target[key.toLowerCase()] || target[key];\n      },\n    }\n  );\n}\n\nfunction requestInitWithCache(requestInit?: RequestInit): RequestInit {\n  try {\n    const withCache: RequestInit = {\n      ...requestInit,\n      cache: \"no-cache\",\n    };\n\n    const _ = new Request(\"http://localhost\", withCache);\n\n    return withCache;\n  } catch (error) {\n    return requestInit ?? {};\n  }\n}\n\n/**\n * A subclass of `Promise` providing additional helper methods\n * for interacting with the SDK.\n */\nexport class ApiPromise<T> extends Promise<T> {\n  constructor(private responsePromise: Promise<ZodFetchResult<T>>) {\n    super((resolve) => {\n      // this is maybe a bit weird but this has to be a no-op to not implicitly\n      // parse the response body; instead .then, .catch, .finally are overridden\n      // to parse the response\n      resolve(null as any);\n    });\n  }\n\n  /**\n   * Gets the raw `Response` instance instead of parsing the response\n   * data.\n   *\n   * If you want to parse the response body but still get the `Response`\n   * instance, you can use {@link withResponse()}.\n   */\n  asResponse(): Promise<Response> {\n    return this.responsePromise.then((p) => p.response);\n  }\n\n  /**\n   * Gets the parsed response data and the raw `Response` instance.\n   *\n   * If you just want to get the raw `Response` instance without parsing it,\n   * you can use {@link asResponse()}.\n   */\n  async withResponse(): Promise<{ data: T; response: Response }> {\n    const [data, response] = await Promise.all([this.parse(), this.asResponse()]);\n    return { data, response };\n  }\n\n  private parse(): Promise<T> {\n    return this.responsePromise.then((result) => result.data);\n  }\n\n  override then<TResult1 = T, TResult2 = never>(\n    onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,\n    onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null\n  ): Promise<TResult1 | TResult2> {\n    return this.parse().then(onfulfilled, onrejected);\n  }\n\n  override catch<TResult = never>(\n    onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null\n  ): Promise<T | TResult> {\n    return this.parse().catch(onrejected);\n  }\n\n  override finally(onfinally?: (() => void) | undefined | null): Promise<T> {\n    return this.parse().finally(onfinally);\n  }\n}\n\nexport class CursorPagePromise<TItemSchema extends z.ZodTypeAny>\n  extends ApiPromise<CursorPage<z.output<TItemSchema>>>\n  implements AsyncIterable<z.output<TItemSchema>>\n{\n  constructor(\n    result: Promise<ZodFetchResult<CursorPageResponse<z.output<TItemSchema>>>>,\n    private schema: TItemSchema,\n    private url: string,\n    private params: FetchCursorPageParams,\n    private requestInit?: RequestInit,\n    private options?: ZodFetchOptions\n  ) {\n    super(\n      result.then((result) => ({\n        data: new CursorPage(result.data.data, result.data.pagination, this.#fetchPage.bind(this)),\n        response: result.response,\n      }))\n    );\n  }\n\n  #fetchPage(params: Omit<CursorPageParams, \"limit\">): Promise<CursorPage<z.output<TItemSchema>>> {\n    return zodfetchCursorPage(\n      this.schema,\n      this.url,\n      { ...this.params, ...params },\n      this.requestInit,\n      this.options\n    );\n  }\n\n  /**\n   * Allow auto-paginating iteration on an unawaited list call, eg:\n   *\n   *    for await (const item of client.items.list()) {\n   *      console.log(item)\n   *    }\n   */\n  async *[Symbol.asyncIterator]() {\n    const page = await this;\n    for await (const item of page) {\n      yield item;\n    }\n  }\n}\n\nexport class OffsetLimitPagePromise<TItemSchema extends z.ZodTypeAny>\n  extends ApiPromise<OffsetLimitPage<z.output<TItemSchema>>>\n  implements AsyncIterable<z.output<TItemSchema>>\n{\n  constructor(\n    result: Promise<ZodFetchResult<OffsetLimitPageResponse<z.output<TItemSchema>>>>,\n    private schema: TItemSchema,\n    private url: string,\n    private params: FetchOffsetLimitPageParams,\n    private requestInit?: RequestInit,\n    private options?: ZodFetchOptions\n  ) {\n    super(\n      result.then((result) => ({\n        data: new OffsetLimitPage(\n          result.data.data,\n          result.data.pagination,\n          this.#fetchPage.bind(this)\n        ),\n        response: result.response,\n      }))\n    );\n  }\n\n  #fetchPage(\n    params: Omit<FetchOffsetLimitPageParams, \"limit\">\n  ): Promise<OffsetLimitPage<z.output<TItemSchema>>> {\n    return zodfetchOffsetLimitPage(\n      this.schema,\n      this.url,\n      { ...this.params, ...params },\n      this.requestInit,\n      this.options\n    );\n  }\n\n  /**\n   * Allow auto-paginating iteration on an unawaited list call, eg:\n   *\n   *    for await (const item of client.items.list()) {\n   *      console.log(item)\n   *    }\n   */\n  async *[Symbol.asyncIterator]() {\n    const page = await this;\n    for await (const item of page) {\n      yield item;\n    }\n  }\n}\n\nasync function waitForRetry(\n  url: string,\n  attempt: number,\n  delay: number,\n  options?: ZodFetchOptions,\n  requestInit?: RequestInit,\n  response?: Response\n): Promise<void> {\n  if (options?.tracer) {\n    const method = requestInit?.method ?? \"GET\";\n\n    return options.tracer.startActiveSpan(\n      response ? `wait after ${response.status}` : `wait after error`,\n      async (span) => {\n        await new Promise((resolve) => setTimeout(resolve, delay));\n      },\n      {\n        attributes: {\n          [SemanticInternalAttributes.STYLE_ICON]: \"wait\",\n          ...accessoryAttributes({\n            items: [\n              {\n                text: `retrying ${options?.name ?? method.toUpperCase()} in ${delay}ms`,\n                variant: \"normal\",\n              },\n            ],\n            style: \"codepath\",\n          }),\n        },\n      }\n    );\n  }\n\n  await new Promise((resolve) => setTimeout(resolve, delay));\n}\n\n// https://stackoverflow.com/a/34491287\nexport function isEmptyObj(obj: Object | null | undefined): boolean {\n  if (!obj) return true;\n  for (const _k in obj) return false;\n  return true;\n}\n\n// https://eslint.org/docs/latest/rules/no-prototype-builtins\nexport function hasOwn(obj: Object, key: string): boolean {\n  return Object.prototype.hasOwnProperty.call(obj, key);\n}\n", "import { calculateResetAt as calculateResetAtInternal } from \"../../retry\";\nimport { FetchRetryOptions, type RetryOptions } from \"../schemas\";\n\nexport const defaultRetryOptions = {\n  maxAttempts: 3,\n  factor: 2,\n  minTimeoutInMs: 1000,\n  maxTimeoutInMs: 60000,\n  randomize: true,\n} satisfies RetryOptions;\n\nexport const defaultFetchRetryOptions = {\n  byStatus: {\n    \"429,408,409,5xx\": {\n      strategy: \"backoff\",\n      ...defaultRetryOptions,\n    },\n  },\n  connectionError: defaultRetryOptions,\n  timeout: defaultRetryOptions,\n} satisfies FetchRetryOptions;\n\n/**\n *\n * @param options\n * @param attempt - The current attempt number. If the first attempt has failed, this will be 1.\n * @returns\n */\nexport function calculateNextRetryDelay(options: RetryOptions, attempt: number) {\n  const opts = { ...defaultRetryOptions, ...options };\n\n  if (attempt >= opts.maxAttempts) {\n    return;\n  }\n\n  const { factor, minTimeoutInMs, maxTimeoutInMs, randomize } = opts;\n\n  const random = randomize ? Math.random() + 1 : 1;\n\n  const timeout = Math.min(maxTimeoutInMs, random * minTimeoutInMs * Math.pow(factor, attempt - 1));\n\n  // Round to the nearest integer\n  return Math.round(timeout);\n}\n\nexport function calculateResetAt(\n  resets: string | undefined | null,\n  format:\n    | \"unix_timestamp\"\n    | \"iso_8601\"\n    | \"iso_8601_duration_openai_variant\"\n    | \"unix_timestamp_in_ms\",\n  now: number = Date.now()\n): number | undefined {\n  const resetAt = calculateResetAtInternal(resets, format, new Date(now));\n\n  return resetAt?.getTime();\n}\n", "export type APIHeaders = Record<string, string | null | undefined>;\n\nexport class ApiError extends Error {\n  readonly status: number | undefined;\n  readonly headers: APIHeaders | undefined;\n  readonly error: Object | undefined;\n\n  readonly code: string | null | undefined;\n  readonly param: string | null | undefined;\n  readonly type: string | undefined;\n\n  constructor(\n    status: number | undefined,\n    error: Object | undefined,\n    message: string | undefined,\n    headers: APIHeaders | undefined\n  ) {\n    super(`${ApiError.makeMessage(status, error, message)}`);\n    this.name = \"TriggerApiError\";\n    this.status = status;\n    this.headers = headers;\n\n    const data = error as Record<string, any>;\n    this.error = data;\n    this.code = data?.[\"code\"];\n    this.param = data?.[\"param\"];\n    this.type = data?.[\"type\"];\n  }\n\n  private static makeMessage(status: number | undefined, error: any, message: string | undefined) {\n    const msg = error?.message\n      ? typeof error.message === \"string\"\n        ? error.message\n        : JSON.stringify(error.message)\n      : error\n      ? JSON.stringify(error)\n      : message;\n\n    if (status && msg) {\n      return `${status} ${msg}`;\n    }\n    if (status) {\n      return `${status} status code (no body)`;\n    }\n    if (msg) {\n      return msg;\n    }\n    return \"(no status code or body)\";\n  }\n\n  static generate(\n    status: number | undefined,\n    errorResponse: Object | undefined,\n    message: string | undefined,\n    headers: APIHeaders | undefined\n  ) {\n    if (!status) {\n      return new ApiConnectionError({ cause: castToError(errorResponse) });\n    }\n\n    const error = (errorResponse as Record<string, any>)?.[\"error\"];\n\n    if (status === 400) {\n      return new BadRequestError(status, error, message, headers);\n    }\n\n    if (status === 401) {\n      return new AuthenticationError(status, error, message, headers);\n    }\n\n    if (status === 403) {\n      return new PermissionDeniedError(status, error, message, headers);\n    }\n\n    if (status === 404) {\n      return new NotFoundError(status, error, message, headers);\n    }\n\n    if (status === 409) {\n      return new ConflictError(status, error, message, headers);\n    }\n\n    if (status === 422) {\n      return new UnprocessableEntityError(status, error, message, headers);\n    }\n\n    if (status === 429) {\n      return new RateLimitError(status, error, message, headers);\n    }\n\n    if (status >= 500) {\n      return new InternalServerError(status, error, message, headers);\n    }\n\n    return new ApiError(status, error, message, headers);\n  }\n}\n\nexport class ApiConnectionError extends ApiError {\n  override readonly status: undefined = undefined;\n\n  constructor({ message, cause }: { message?: string; cause?: Error | undefined }) {\n    super(undefined, undefined, message || \"Connection error.\", undefined);\n    // in some environments the 'cause' property is already declared\n    // @ts-ignore\n    if (cause) this.cause = cause;\n  }\n}\n\nexport class BadRequestError extends ApiError {\n  override readonly status: 400 = 400;\n}\n\nexport class AuthenticationError extends ApiError {\n  override readonly status: 401 = 401;\n}\n\nexport class PermissionDeniedError extends ApiError {\n  override readonly status: 403 = 403;\n}\n\nexport class NotFoundError extends ApiError {\n  override readonly status: 404 = 404;\n}\n\nexport class ConflictError extends ApiError {\n  override readonly status: 409 = 409;\n}\n\nexport class UnprocessableEntityError extends ApiError {\n  override readonly status: 422 = 422;\n}\n\nexport class RateLimitError extends ApiError {\n  override readonly status: 429 = 429;\n\n  get millisecondsUntilReset(): number | undefined {\n    // x-ratelimit-reset is the unix timestamp in milliseconds when the rate limit will reset.\n    const resetAtUnixEpochMs = (this.headers ?? {})[\"x-ratelimit-reset\"];\n\n    if (typeof resetAtUnixEpochMs === \"string\") {\n      const resetAtUnixEpoch = parseInt(resetAtUnixEpochMs, 10);\n\n      if (isNaN(resetAtUnixEpoch)) {\n        return;\n      }\n\n      // Add between 0 and 2000ms to the reset time to add jitter\n      return Math.max(resetAtUnixEpoch - Date.now() + Math.floor(Math.random() * 2000), 0);\n    }\n  }\n}\n\nexport class InternalServerError extends ApiError {}\n\nfunction castToError(err: any): Error {\n  if (err instanceof Error) return err;\n  return new Error(err);\n}\n", "export const SemanticInternalAttributes = {\n  ENVIRONMENT_ID: \"ctx.environment.id\",\n  ENVIRONMENT_TYPE: \"ctx.environment.type\",\n  ORGANIZATION_ID: \"ctx.organization.id\",\n  ORGANIZATION_SLUG: \"ctx.organization.slug\",\n  ORGANIZATION_NAME: \"ctx.organization.name\",\n  PROJECT_ID: \"ctx.project.id\",\n  PROJECT_REF: \"ctx.project.ref\",\n  PROJECT_NAME: \"ctx.project.title\",\n  PROJECT_DIR: \"project.dir\",\n  ATTEMPT_ID: \"ctx.attempt.id\",\n  ATTEMPT_NUMBER: \"ctx.attempt.number\",\n  RUN_ID: \"ctx.run.id\",\n  RUN_IS_TEST: \"ctx.run.isTest\",\n  BATCH_ID: \"ctx.batch.id\",\n  TASK_SLUG: \"ctx.task.id\",\n  TASK_PATH: \"ctx.task.filePath\",\n  TASK_EXPORT_NAME: \"ctx.task.exportName\",\n  QUEUE_NAME: \"ctx.queue.name\",\n  QUEUE_ID: \"ctx.queue.id\",\n  MACHINE_PRESET_NAME: \"ctx.machine.name\",\n  MACHINE_PRESET_CPU: \"ctx.machine.cpu\",\n  MACHINE_PRESET_MEMORY: \"ctx.machine.memory\",\n  MACHINE_PRESET_CENTS_PER_MS: \"ctx.machine.centsPerMs\",\n  SPAN_PARTIAL: \"$span.partial\",\n  SPAN_ID: \"$span.span_id\",\n  OUTPUT: \"$output\",\n  OUTPUT_TYPE: \"$mime_type_output\",\n  STYLE: \"$style\",\n  STYLE_ICON: \"$style.icon\",\n  STYLE_VARIANT: \"$style.variant\",\n  STYLE_ACCESSORY: \"$style.accessory\",\n  METADATA: \"$metadata\",\n  TRIGGER: \"$trigger\",\n  PAYLOAD: \"$payload\",\n  PAYLOAD_TYPE: \"$mime_type_payload\",\n  SHOW: \"$show\",\n  SHOW_ACTIONS: \"$show.actions\",\n  WORKER_ID: \"worker.id\",\n  WORKER_VERSION: \"worker.version\",\n  CLI_VERSION: \"cli.version\",\n  SDK_VERSION: \"sdk.version\",\n  SDK_LANGUAGE: \"sdk.language\",\n  RETRY_AT: \"retry.at\",\n  RETRY_DELAY: \"retry.delay\",\n  RETRY_COUNT: \"retry.count\",\n  LINK_TITLE: \"$link.title\",\n  IDEMPOTENCY_KEY: \"ctx.run.idempotencyKey\",\n  USAGE_DURATION_MS: \"$usage.durationMs\",\n  USAGE_COST_IN_CENTS: \"$usage.costInCents\",\n  RATE_LIMIT_LIMIT: \"response.rateLimit.limit\",\n  RATE_LIMIT_REMAINING: \"response.rateLimit.remaining\",\n  RATE_LIMIT_RESET: \"response.rateLimit.reset\",\n};\n", "import { Attributes } from \"@opentelemetry/api\";\n\nexport const NULL_SENTINEL = \"$@null((\";\n\nexport function flattenAttributes(\n  obj: Record<string, unknown> | Array<unknown> | string | boolean | number | null | undefined,\n  prefix?: string\n): Attributes {\n  const result: Attributes = {};\n\n  // Check if obj is null or undefined\n  if (obj === undefined) {\n    return result;\n  }\n\n  if (obj === null) {\n    result[prefix || \"\"] = NULL_SENTINEL;\n    return result;\n  }\n\n  if (typeof obj === \"string\") {\n    result[prefix || \"\"] = obj;\n    return result;\n  }\n\n  if (typeof obj === \"number\") {\n    result[prefix || \"\"] = obj;\n    return result;\n  }\n\n  if (typeof obj === \"boolean\") {\n    result[prefix || \"\"] = obj;\n    return result;\n  }\n\n  for (const [key, value] of Object.entries(obj)) {\n    const newPrefix = `${prefix ? `${prefix}.` : \"\"}${Array.isArray(obj) ? `[${key}]` : key}`;\n    if (Array.isArray(value)) {\n      for (let i = 0; i < value.length; i++) {\n        if (typeof value[i] === \"object\" && value[i] !== null) {\n          // update null check here as well\n          Object.assign(result, flattenAttributes(value[i], `${newPrefix}.[${i}]`));\n        } else {\n          if (value[i] === null) {\n            result[`${newPrefix}.[${i}]`] = NULL_SENTINEL;\n          } else {\n            result[`${newPrefix}.[${i}]`] = value[i];\n          }\n        }\n      }\n    } else if (isRecord(value)) {\n      // update null check here\n      Object.assign(result, flattenAttributes(value, newPrefix));\n    } else {\n      if (typeof value === \"number\" || typeof value === \"string\" || typeof value === \"boolean\") {\n        result[newPrefix] = value;\n      } else if (value === null) {\n        result[newPrefix] = NULL_SENTINEL;\n      }\n    }\n  }\n\n  return result;\n}\n\nfunction isRecord(value: unknown): value is Record<string, unknown> {\n  return value !== null && typeof value === \"object\" && !Array.isArray(value);\n}\n\nexport function unflattenAttributes(\n  obj: Attributes\n): Record<string, unknown> | string | number | boolean | null | undefined {\n  if (typeof obj !== \"object\" || obj === null || Array.isArray(obj)) {\n    return obj;\n  }\n\n  if (\n    typeof obj === \"object\" &&\n    obj !== null &&\n    Object.keys(obj).length === 1 &&\n    Object.keys(obj)[0] === \"\"\n  ) {\n    return rehydrateNull(obj[\"\"]) as any;\n  }\n\n  if (Object.keys(obj).length === 0) {\n    return;\n  }\n\n  const result: Record<string, unknown> = {};\n\n  for (const [key, value] of Object.entries(obj)) {\n    const parts = key.split(\".\").reduce((acc, part) => {\n      if (part.includes(\"[\")) {\n        // Handling nested array indices\n        const subparts = part.split(/\\[|\\]/).filter((p) => p !== \"\");\n        acc.push(...subparts);\n      } else {\n        acc.push(part);\n      }\n      return acc;\n    }, [] as string[]);\n\n    let current: any = result;\n    for (let i = 0; i < parts.length - 1; i++) {\n      const part = parts[i];\n      const nextPart = parts[i + 1];\n      const isArray = /^\\d+$/.test(nextPart);\n      if (isArray && !Array.isArray(current[part])) {\n        current[part] = [];\n      } else if (!isArray && current[part] === undefined) {\n        current[part] = {};\n      }\n      current = current[part];\n    }\n    const lastPart = parts[parts.length - 1];\n    current[lastPart] = rehydrateNull(value);\n  }\n\n  // Convert the result to an array if all top-level keys are numeric indices\n  if (Object.keys(result).every((k) => /^\\d+$/.test(k))) {\n    const maxIndex = Math.max(...Object.keys(result).map((k) => parseInt(k)));\n    const arrayResult = Array(maxIndex + 1);\n    for (const key in result) {\n      arrayResult[parseInt(key)] = result[key];\n    }\n    return arrayResult as any;\n  }\n\n  return result;\n}\n\nexport function primitiveValueOrflattenedAttributes(\n  obj: Record<string, unknown> | Array<unknown> | string | boolean | number | undefined,\n  prefix: string | undefined\n): Attributes | string | number | boolean | undefined {\n  if (\n    typeof obj === \"string\" ||\n    typeof obj === \"number\" ||\n    typeof obj === \"boolean\" ||\n    obj === null ||\n    obj === undefined\n  ) {\n    return obj;\n  }\n\n  const attributes = flattenAttributes(obj, prefix);\n\n  if (\n    prefix !== undefined &&\n    typeof attributes[prefix] !== \"undefined\" &&\n    attributes[prefix] !== null\n  ) {\n    return attributes[prefix] as unknown as Attributes;\n  }\n\n  return attributes;\n}\n\nfunction rehydrateNull(value: any): any {\n  if (value === NULL_SENTINEL) {\n    return null;\n  }\n\n  return value;\n}\n", "import { Attributes } from \"@opentelemetry/api\";\nimport { Accessory } from \"../schemas\";\nimport { flattenAttributes } from \"./flattenAttributes\";\nimport { SemanticInternalAttributes } from \"../semanticInternalAttributes\";\n\nexport function accessoryAttributes(accessory: Accessory): Attributes {\n  return flattenAttributes(accessory, SemanticInternalAttributes.STYLE_ACCESSORY);\n}\n", "export interface CursorPageParams {\n  limit?: number;\n  after?: string;\n  before?: string;\n}\n\nexport interface OffsetLimitPageParams {\n  limit?: number;\n  page?: number;\n}\n\nexport interface PageResponse<Item> {\n  data: Array<Item>;\n}\n\nexport interface CursorPageResponse<Item> extends PageResponse<Item> {\n  pagination: {\n    next?: string;\n    previous?: string;\n  };\n}\n\nexport interface OffsetLimitPageResponse<Item> extends PageResponse<Item> {\n  pagination: {\n    currentPage: number;\n    totalPages: number;\n    count: number;\n  };\n}\n\nexport interface Page<Item> {\n  getPaginatedItems(): Item[];\n  hasNextPage(): boolean;\n  hasPreviousPage(): boolean;\n}\n\nexport class CursorPage<Item> implements CursorPageResponse<Item>, Page<Item>, AsyncIterable<Item> {\n  data: Array<Item>;\n  pagination: { next?: string; previous?: string };\n\n  constructor(\n    data: Array<Item>,\n    pagination: { next?: string; previous?: string },\n    private pageFetcher: (params: Omit<CursorPageParams, \"limit\">) => Promise<CursorPage<Item>>\n  ) {\n    this.data = data;\n    this.pagination = pagination;\n  }\n\n  getPaginatedItems(): Item[] {\n    return this.data ?? [];\n  }\n\n  hasNextPage(): boolean {\n    return !!this.pagination.next;\n  }\n\n  hasPreviousPage(): boolean {\n    return !!this.pagination.previous;\n  }\n\n  getNextPage(): Promise<CursorPage<Item>> {\n    if (!this.pagination.next) {\n      throw new Error(\"No next page available\");\n    }\n\n    return this.pageFetcher({ after: this.pagination.next });\n  }\n\n  getPreviousPage(): Promise<CursorPage<Item>> {\n    if (!this.pagination.previous) {\n      throw new Error(\"No previous page available\");\n    }\n\n    return this.pageFetcher({ before: this.pagination.previous });\n  }\n\n  async *iterPages() {\n    // eslint-disable-next-line @typescript-eslint/no-this-alias\n    let page: CursorPage<Item> = this;\n    yield page;\n    while (page.hasNextPage()) {\n      page = await page.getNextPage();\n      yield page;\n    }\n  }\n\n  async *[Symbol.asyncIterator]() {\n    for await (const page of this.iterPages()) {\n      for (const item of page.getPaginatedItems()) {\n        yield item;\n      }\n    }\n  }\n}\n\nexport class OffsetLimitPage<Item>\n  implements OffsetLimitPageResponse<Item>, Page<Item>, AsyncIterable<Item>\n{\n  data: Array<Item>;\n  pagination: { currentPage: number; totalPages: number; count: number };\n\n  constructor(\n    data: Array<Item>,\n    pagination: { currentPage: number; totalPages: number; count: number },\n    private pageFetcher: (\n      params: Omit<OffsetLimitPageParams, \"limit\">\n    ) => Promise<OffsetLimitPage<Item>>\n  ) {\n    this.data = data;\n    this.pagination = pagination;\n  }\n\n  getPaginatedItems(): Item[] {\n    return this.data ?? [];\n  }\n\n  hasNextPage(): boolean {\n    return this.pagination.currentPage < this.pagination.totalPages;\n  }\n\n  hasPreviousPage(): boolean {\n    return this.pagination.currentPage > 1;\n  }\n\n  getNextPage(): Promise<OffsetLimitPage<Item>> {\n    if (!this.hasNextPage()) {\n      throw new Error(\"No next page available\");\n    }\n\n    return this.pageFetcher({\n      page: this.pagination.currentPage + 1,\n    });\n  }\n\n  getPreviousPage(): Promise<OffsetLimitPage<Item>> {\n    if (!this.hasPreviousPage()) {\n      throw new Error(\"No previous page available\");\n    }\n\n    return this.pageFetcher({\n      page: this.pagination.currentPage - 1,\n    });\n  }\n\n  async *iterPages() {\n    // eslint-disable-next-line @typescript-eslint/no-this-alias\n    let page: OffsetLimitPage<Item> = this;\n    yield page;\n    while (page.hasNextPage()) {\n      page = await page.getNextPage();\n      yield page;\n    }\n  }\n\n  async *[Symbol.asyncIterator]() {\n    for await (const page of this.iterPages()) {\n      for (const item of page.getPaginatedItems()) {\n        yield item;\n      }\n    }\n  }\n}\n", "// src/workers/dev/worker-facade.ts\nimport {\n  clock,\n  taskCatalog\n} from \"@trigger.dev/core/v3\";\nimport {\n  TaskExecutor,\n  DurableClock,\n  getEnvVar,\n  logLevels,\n  OtelTaskLogger,\n  ConsoleInterceptor,\n  usage,\n  DevUsageManager\n} from \"@trigger.dev/core/v3/workers\";\nimport {\n  TaskRunErrorCodes,\n  TriggerTracer,\n  logger,\n  runtime,\n  workerToChildMessages\n} from \"@trigger.dev/core/v3\";\nimport { DevRuntimeManager } from \"@trigger.dev/core/v3/dev\";\nimport {\n  ZodMessageHandler,\n  ZodSchemaParsedError\n} from \"@trigger.dev/core/v3/zodMessageHandler\";\nimport { tracingSDK, otelTracer, otelLogger, sender } from \"/private/tmp/bunx-501-trigger.dev@beta/node_modules/trigger.dev/dist/workers/dev/worker-setup.js\";;\nimport * as importedConfigExports from \"/Users/ashrafelshaer/Desktop/Developer/hr-toolkit-v1/packages/jobs/trigger.config.ts\"; const importedConfig = importedConfigExports.config; const handleError = importedConfigExports.handleError;;\nvar durableClock = new DurableClock();\nclock.setGlobalClock(durableClock);\nusage.setGlobalUsageManager(new DevUsageManager());\nvar tracer = new TriggerTracer({ tracer: otelTracer, logger: otelLogger });\nvar consoleInterceptor = new ConsoleInterceptor(\n  otelLogger,\n  typeof __PROJECT_CONFIG__.enableConsoleLogging === \"boolean\" ? __PROJECT_CONFIG__.enableConsoleLogging : true\n);\nvar devRuntimeManager = new DevRuntimeManager();\nruntime.setGlobalRuntimeManager(devRuntimeManager);\nvar triggerLogLevel = getEnvVar(\"TRIGGER_LOG_LEVEL\");\nvar configLogLevel = triggerLogLevel ? triggerLogLevel : importedConfig ? importedConfig.logLevel : __PROJECT_CONFIG__.logLevel;\nvar otelTaskLogger = new OtelTaskLogger({\n  logger: otelLogger,\n  tracer,\n  level: logLevels.includes(configLogLevel) ? configLogLevel : \"info\"\n});\nlogger.setGlobalTaskLogger(otelTaskLogger);\nvar TaskFileImports = {};\nvar TaskFiles = {};\nimport * as src_trigger_account_deletion_notice from \"./src/trigger/account-deletion-notice.ts\"; TaskFileImports[\"src_trigger_account_deletion_notice\"] = src_trigger_account_deletion_notice; TaskFiles[\"src_trigger_account_deletion_notice\"] = {\"triggerDir\":\"/Users/ashrafelshaer/Desktop/Developer/hr-toolkit-v1/packages/jobs/src/trigger\",\"importPath\":\"src/trigger/account-deletion-notice.ts\",\"importName\":\"src_trigger_account_deletion_notice\",\"filePath\":\"src/trigger/account-deletion-notice.ts\"};\nimport * as src_trigger_delete_unconfirmed_emails from \"./src/trigger/delete-unconfirmed-emails.ts\"; TaskFileImports[\"src_trigger_delete_unconfirmed_emails\"] = src_trigger_delete_unconfirmed_emails; TaskFiles[\"src_trigger_delete_unconfirmed_emails\"] = {\"triggerDir\":\"/Users/ashrafelshaer/Desktop/Developer/hr-toolkit-v1/packages/jobs/src/trigger\",\"importPath\":\"src/trigger/delete-unconfirmed-emails.ts\",\"importName\":\"src_trigger_delete_unconfirmed_emails\",\"filePath\":\"src/trigger/delete-unconfirmed-emails.ts\"};\nimport * as src_trigger_example from \"./src/trigger/example.ts\"; TaskFileImports[\"src_trigger_example\"] = src_trigger_example; TaskFiles[\"src_trigger_example\"] = {\"triggerDir\":\"/Users/ashrafelshaer/Desktop/Developer/hr-toolkit-v1/packages/jobs/src/trigger\",\"importPath\":\"src/trigger/example.ts\",\"importName\":\"src_trigger_example\",\"filePath\":\"src/trigger/example.ts\"};;\n(() => {\n  for (const [importName, taskFile] of Object.entries(TaskFiles)) {\n    const fileImports = TaskFileImports[importName];\n    for (const [exportName, task] of Object.entries(fileImports ?? {})) {\n      if (typeof task === \"object\" && task !== null && \"id\" in task && typeof task.id === \"string\") {\n        if (taskCatalog.taskExists(task.id)) {\n          taskCatalog.registerTaskFileMetadata(task.id, {\n            exportName,\n            filePath: taskFile.filePath\n          });\n        }\n      }\n    }\n  }\n})();\nvar _execution;\nvar _isRunning = false;\nvar handler = new ZodMessageHandler({\n  schema: workerToChildMessages,\n  messages: {\n    EXECUTE_TASK_RUN: async ({ execution, traceContext, metadata }) => {\n      if (_isRunning) {\n        console.error(\"Worker is already running a task\");\n        await sender.send(\"TASK_RUN_COMPLETED\", {\n          execution,\n          result: {\n            ok: false,\n            id: execution.run.id,\n            error: {\n              type: \"INTERNAL_ERROR\",\n              code: TaskRunErrorCodes.TASK_ALREADY_RUNNING\n            },\n            usage: {\n              durationMs: 0\n            }\n          }\n        });\n        return;\n      }\n      process.title = `trigger-dev-worker: ${execution.task.id} ${execution.run.id}`;\n      const task = taskCatalog.getTask(execution.task.id);\n      if (!task) {\n        console.error(`Could not find task ${execution.task.id}`);\n        await sender.send(\"TASK_RUN_COMPLETED\", {\n          execution,\n          result: {\n            ok: false,\n            id: execution.run.id,\n            error: {\n              type: \"INTERNAL_ERROR\",\n              code: TaskRunErrorCodes.COULD_NOT_FIND_EXECUTOR\n            },\n            usage: {\n              durationMs: 0\n            }\n          }\n        });\n        return;\n      }\n      const executor = new TaskExecutor(task, {\n        tracer,\n        tracingSDK,\n        consoleInterceptor,\n        projectConfig: __PROJECT_CONFIG__,\n        importedConfig,\n        handleErrorFn: handleError\n      });\n      try {\n        _execution = execution;\n        _isRunning = true;\n        const measurement = usage.start();\n        const { result } = await executor.execute(execution, metadata, traceContext, measurement);\n        const usageSample = usage.stop(measurement);\n        return sender.send(\"TASK_RUN_COMPLETED\", {\n          execution,\n          result: {\n            ...result,\n            usage: {\n              durationMs: usageSample.cpuTime\n            }\n          }\n        });\n      } finally {\n        _execution = void 0;\n        _isRunning = false;\n      }\n    },\n    TASK_RUN_COMPLETED_NOTIFICATION: async (payload) => {\n      switch (payload.version) {\n        case \"v1\": {\n          devRuntimeManager.resumeTask(payload.completion, payload.execution.run.id);\n          break;\n        }\n        case \"v2\": {\n          devRuntimeManager.resumeTask(payload.completion, payload.completion.id);\n          break;\n        }\n      }\n    },\n    CLEANUP: async ({ flush, kill }) => {\n      if (kill) {\n        await tracingSDK.flush();\n        await sender.send(\"READY_TO_DISPOSE\", void 0);\n      } else {\n        if (flush) {\n          await tracingSDK.flush();\n        }\n      }\n    }\n  }\n});\nprocess.on(\"message\", async (msg) => {\n  await handler.handleMessage(msg);\n});\nvar TASK_METADATA = taskCatalog.getAllTaskMetadata();\nsender.send(\"TASKS_READY\", { tasks: TASK_METADATA }).catch((err) => {\n  if (err instanceof ZodSchemaParsedError) {\n    sender.send(\"TASKS_FAILED_TO_PARSE\", { zodIssues: err.error.issues, tasks: TASK_METADATA });\n  } else {\n    console.error(\"Failed to send TASKS_READY message\", err);\n  }\n});\nprocess.title = \"trigger-dev-worker\";\nasync function asyncHeartbeat(initialDelayInSeconds = 30, intervalInSeconds = 30) {\n  async function _doHeartbeat() {\n    while (true) {\n      if (_isRunning && _execution) {\n        try {\n          await sender.send(\"TASK_HEARTBEAT\", { id: _execution.attempt.id });\n        } catch (err) {\n          console.error(\"Failed to send HEARTBEAT message\", err);\n        }\n      }\n      await new Promise((resolve) => setTimeout(resolve, 1e3 * intervalInSeconds));\n    }\n  }\n  await new Promise((resolve) => setTimeout(resolve, 1e3 * initialDelayInSeconds));\n  return _doHeartbeat();\n}\nasyncHeartbeat().catch((err) => {\n  console.error(\"Failed to start asyncHeartbeat\", err);\n});\n", "// src/workers/dev/worker-setup.ts\nimport { childToWorkerMessages, taskCatalog } from \"@trigger.dev/core/v3\";\nimport {\n  StandardTaskCatalog,\n  TracingSDK\n} from \"@trigger.dev/core/v3/workers\";\nimport { ZodMessageSender } from \"@trigger.dev/core/v3/zodMessageHandler\";\nimport \"source-map-support/register.js\";\n\n// package.json\nvar version = \"3.0.0-beta.56\";\n\n// src/workers/dev/worker-setup.ts\nimport * as setupImportedConfigExports from \"/Users/ashrafelshaer/Desktop/Developer/hr-toolkit-v1/packages/jobs/trigger.config.ts\"; const setupImportedConfig = setupImportedConfigExports.config;;\nvar tracingSDK = new TracingSDK({\n  url: process.env.OTEL_EXPORTER_OTLP_ENDPOINT ?? \"http://0.0.0.0:4318\",\n  instrumentations: setupImportedConfig?.instrumentations ?? [],\n  diagLogLevel: process.env.OTEL_LOG_LEVEL ?? \"none\",\n  forceFlushTimeoutMillis: 5e3\n});\nvar otelTracer = tracingSDK.getTracer(\"trigger-dev-worker\", version);\nvar otelLogger = tracingSDK.getLogger(\"trigger-dev-worker\", version);\nvar sender = new ZodMessageSender({\n  schema: childToWorkerMessages,\n  sender: async (message) => {\n    process.send?.(message);\n  }\n});\ntaskCatalog.setGlobalTaskCatalog(new StandardTaskCatalog());\nexport {\n  otelLogger,\n  otelTracer,\n  sender,\n  tracingSDK\n};\n", "import type { TriggerConfig } from \"@trigger.dev/sdk/v3\";\n\nexport const config: TriggerConfig = {\n  project: \"proj_wlvanvtxvnxlxewmqfbh\",\n  logLevel: \"log\",\n  retries: {\n    enabledInDev: true,\n    default: {\n      maxAttempts: 3,\n      minTimeoutInMs: 1000,\n      maxTimeoutInMs: 10000,\n      factor: 2,\n      randomize: true,\n    },\n  },\n  dependenciesToBundle: [\"\"],\n};\n", "import { render } from \"@react-email/components\";\nimport { createClient } from \"@supabase/supabase-js\";\nimport { envvars, logger, task } from \"@trigger.dev/sdk/v3\";\nimport { renderAccountDeletionsNotice } from \"@v1/email/account-deletions-notice\";\nimport React from \"react\";\nimport { Resend } from \"resend\";\n\nexport const accountDeletionsNotice = task({\n  id: \"account-deletions-notice\",\n  run: async (payload: { id: string }, { ctx }) => {\n    const userId = payload.id;\n    const SUPABASE_URL = await envvars.retrieve(\"SUPABASE_URL\");\n    const SUPABASE_SERVICE_KEY = await envvars.retrieve(\"SUPABASE_SERVICE_KEY\");\n    const RESEND_API_KEY = await envvars.retrieve(\"RESEND_API_KEY\");\n    const resend = new Resend(RESEND_API_KEY.value);\n    const supabase = createClient(\n      SUPABASE_URL.value,\n      SUPABASE_SERVICE_KEY.value,\n    );\n\n    const { data: authUser, error: authUserError } =\n      await supabase.auth.admin.getUserById(userId);\n\n    if (authUserError) {\n      logger.error(\"Error getting user\", { authUserError });\n      throw authUserError;\n    }\n\n    if (authUser.user.email_confirmed_at) {\n      logger.info(\"User already confirmed\", { userId });\n      return;\n    }\n\n    const email = authUser.user.email;\n\n    if (email) {\n      const emailHtml = await renderAccountDeletionsNotice;\n      try {\n        await resend.emails.send({\n          from: \"noreply@hrtoolkit.app\",\n          to: email,\n          subject: \"Account Deletion Notice\",\n          html: emailHtml,\n        });\n        logger.info(\"Account deletion notice email sent\", { email });\n      } catch (emailError) {\n        logger.error(\"Error sending account deletion notice email\", {\n          emailError,\n        });\n      }\n    }\n\n    logger.info(\"Account deletion notice sent successfully\", { userId });\n  },\n});\n", "import { SemanticInternalAttributes } from \"@trigger.dev/core/v3\";\nimport { tracer } from \"./tracer\";\n\nexport type CacheMetadata = {\n  createdTime: number;\n  ttl?: number | null;\n};\n\nexport type CacheEntry<Value = unknown> = {\n  metadata: CacheMetadata;\n  value: Value;\n};\n\nexport type Eventually<Value> = Value | null | undefined | Promise<Value | null | undefined>;\n\nexport type CacheStore<Value = any> = {\n  name?: string;\n  get: (key: string) => Eventually<CacheEntry<Value>>;\n  set: (key: string, value: CacheEntry<Value>) => unknown | Promise<unknown>;\n  delete: (key: string) => unknown | Promise<unknown>;\n};\n\nexport type CacheFunction = <Value>(\n  cacheKey: string,\n  fn: () => Promise<Value> | Value\n) => Promise<Value> | Value;\n\nexport class InMemoryCache<Value = any> {\n  private _cache: Map<string, CacheEntry<Value>> = new Map();\n\n  get(key: string): Eventually<CacheEntry<Value>> {\n    return this._cache.get(key);\n  }\n\n  set(key: string, value: CacheEntry<Value>): unknown {\n    this._cache.set(key, value);\n\n    return undefined;\n  }\n\n  delete(key: string): unknown {\n    this._cache.delete(key);\n\n    return undefined;\n  }\n}\n\n/**\n * Create a cache function that uses the provided store to cache values. Using InMemoryCache is safe because each task run is isolated.\n * @param store\n * @returns\n */\nexport function createCache(store: CacheStore): CacheFunction {\n  return function cache<Value>(\n    cacheKey: string,\n    fn: () => Promise<Value> | Value\n  ): Promise<Value> | Value {\n    return tracer.startActiveSpan(\"cache\", async (span) => {\n      span.setAttribute(\"cache.key\", cacheKey);\n      span.setAttribute(SemanticInternalAttributes.STYLE_ICON, \"device-sd-card\");\n\n      const cacheEntry = await store.get(cacheKey);\n\n      if (cacheEntry) {\n        span.updateName(`cache.hit ${cacheKey}`);\n\n        return cacheEntry.value;\n      }\n\n      span.updateName(`cache.miss ${cacheKey}`);\n\n      const value = await tracer.startActiveSpan(\n        \"cache.getFreshValue\",\n        async (span) => {\n          return await fn();\n        },\n        {\n          attributes: {\n            \"cache.key\": cacheKey,\n            [SemanticInternalAttributes.STYLE_ICON]: \"device-sd-card\",\n          },\n        }\n      );\n\n      await tracer.startActiveSpan(\n        \"cache.set\",\n        async (span) => {\n          await store.set(cacheKey, {\n            value,\n            metadata: {\n              createdTime: Date.now(),\n            },\n          });\n        },\n        {\n          attributes: {\n            \"cache.key\": cacheKey,\n            [SemanticInternalAttributes.STYLE_ICON]: \"device-sd-card\",\n          },\n        }\n      );\n\n      return value;\n    });\n  };\n}\n", "import { TriggerTracer } from \"@trigger.dev/core/v3\";\nimport * as packageJson from \"../../package.json\";\n\nexport const tracer = new TriggerTracer({ name: \"@trigger.dev/sdk\", version: packageJson.version });\n", "{\n  \"name\": \"@trigger.dev/sdk\",\n  \"version\": \"3.0.0-beta.56\",\n  \"description\": \"trigger.dev Node.JS SDK\",\n  \"license\": \"MIT\",\n  \"main\": \"./dist/index.js\",\n  \"types\": \"./dist/index.d.ts\",\n  \"module\": \"./dist/index.mjs\",\n  \"publishConfig\": {\n    \"access\": \"public\"\n  },\n  \"files\": [\n    \"dist\"\n  ],\n  \"exports\": {\n    \".\": {\n      \"import\": {\n        \"types\": \"./dist/index.d.mts\",\n        \"default\": \"./dist/index.mjs\"\n      },\n      \"require\": \"./dist/index.js\",\n      \"types\": \"./dist/index.d.ts\"\n    },\n    \"./v3\": {\n      \"import\": {\n        \"types\": \"./dist/v3/index.d.mts\",\n        \"default\": \"./dist/v3/index.mjs\"\n      },\n      \"require\": \"./dist/v3/index.js\",\n      \"types\": \"./dist/v3/index.d.ts\"\n    },\n    \"./package.json\": \"./package.json\"\n  },\n  \"typesVersions\": {\n    \"*\": {\n      \"v3\": [\n        \"./dist/v3/index.d.ts\"\n      ]\n    }\n  },\n  \"scripts\": {\n    \"clean\": \"rimraf dist\",\n    \"build\": \"npm run clean && npm run build:tsup\",\n    \"build:tsup\": \"tsup --dts-resolve\",\n    \"typecheck\": \"tsc --noEmit\"\n  },\n  \"dependencies\": {\n    \"@opentelemetry/api\": \"^1.8.0\",\n    \"@opentelemetry/api-logs\": \"^0.48.0\",\n    \"@opentelemetry/semantic-conventions\": \"^1.22.0\",\n    \"@trigger.dev/core\": \"workspace:3.0.0-beta.56\",\n    \"@trigger.dev/core-backend\": \"workspace:3.0.0-beta.56\",\n    \"chalk\": \"^5.2.0\",\n    \"cronstrue\": \"^2.21.0\",\n    \"debug\": \"^4.3.4\",\n    \"evt\": \"^2.4.13\",\n    \"get-caller-file\": \"^2.0.5\",\n    \"git-remote-origin-url\": \"^4.0.0\",\n    \"git-repo-info\": \"^2.1.1\",\n    \"slug\": \"^6.0.0\",\n    \"terminal-link\": \"^3.0.0\",\n    \"ulid\": \"^2.3.0\",\n    \"uuid\": \"^9.0.0\",\n    \"ws\": \"^8.11.0\",\n    \"zod\": \"3.22.3\",\n    \"msw\": \"2.2.1\"\n  },\n  \"devDependencies\": {\n    \"@trigger.dev/tsconfig\": \"workspace:*\",\n    \"@trigger.dev/tsup\": \"workspace:*\",\n    \"@types/debug\": \"^4.1.7\",\n    \"@types/node\": \"18\",\n    \"@types/slug\": \"^5.0.3\",\n    \"@types/uuid\": \"^9.0.0\",\n    \"@types/ws\": \"^8.5.3\",\n    \"encoding\": \"^0.1.13\",\n    \"msw\": \"2.2.1\",\n    \"rimraf\": \"^3.0.2\",\n    \"tsup\": \"^8.0.1\",\n    \"typed-emitter\": \"^2.1.0\",\n    \"typescript\": \"^5.3.0\"\n  },\n  \"engines\": {\n    \"node\": \">=18.0.0\"\n  }\n}\n", "import { Attributes, Span, SpanStatusCode, context, trace } from \"@opentelemetry/api\";\nimport {\n  SEMATTRS_HTTP_HOST,\n  SEMATTRS_HTTP_METHOD,\n  SEMATTRS_HTTP_RESPONSE_CONTENT_LENGTH,\n  SEMATTRS_HTTP_SCHEME,\n  SEMATTRS_HTTP_STATUS_CODE,\n  SEMATTRS_HTTP_URL,\n} from \"@opentelemetry/semantic-conventions\";\nimport {\n  FetchRetryByStatusOptions,\n  FetchRetryOptions,\n  FetchRetryStrategy,\n  RetryOptions,\n  SemanticInternalAttributes,\n  accessoryAttributes,\n  calculateNextRetryDelay,\n  calculateResetAt,\n  defaultRetryOptions,\n  eventFilterMatches,\n  flattenAttributes,\n  runtime,\n} from \"@trigger.dev/core/v3\";\nimport { defaultFetchRetryOptions } from \"@trigger.dev/core/v3\";\nimport type { HttpHandler } from \"msw\";\nimport { AsyncLocalStorage } from \"node:async_hooks\";\nimport { tracer } from \"./tracer\";\n\nexport type { RetryOptions };\n\nfunction onThrow<T>(\n  fn: (options: { attempt: number; maxAttempts: number }) => Promise<T>,\n  options: RetryOptions\n): Promise<T> {\n  const opts = {\n    ...defaultRetryOptions,\n    ...options,\n  };\n\n  return tracer.startActiveSpan(\n    `retry.onThrow()`,\n    async (span) => {\n      let attempt = 1;\n\n      while (attempt <= opts.maxAttempts) {\n        const innerSpan = tracer.startSpan(\"retry.fn()\", {\n          attributes: {\n            [SemanticInternalAttributes.STYLE_ICON]: \"function\",\n            ...accessoryAttributes({\n              items: [\n                {\n                  text: `${attempt}/${opts.maxAttempts}`,\n                  variant: \"normal\",\n                },\n              ],\n              style: \"codepath\",\n            }),\n          },\n        });\n\n        const contextWithSpanSet = trace.setSpan(context.active(), innerSpan);\n\n        try {\n          const result = await context.with(contextWithSpanSet, async () => {\n            return fn({ attempt, maxAttempts: opts.maxAttempts });\n          });\n\n          innerSpan.end();\n\n          return result;\n        } catch (e) {\n          if (e instanceof Error || typeof e === \"string\") {\n            innerSpan.recordException(e);\n          } else {\n            innerSpan.recordException(String(e));\n          }\n\n          innerSpan.setStatus({ code: SpanStatusCode.ERROR });\n\n          if (e instanceof Error && e.name === \"AbortTaskRunError\") {\n            innerSpan.end();\n\n            throw e;\n          }\n\n          const nextRetryDelay = calculateNextRetryDelay(opts, attempt);\n\n          if (!nextRetryDelay) {\n            innerSpan.end();\n\n            throw e;\n          }\n\n          innerSpan.setAttribute(\n            SemanticInternalAttributes.RETRY_AT,\n            new Date(Date.now() + nextRetryDelay).toISOString()\n          );\n          innerSpan.setAttribute(SemanticInternalAttributes.RETRY_COUNT, attempt);\n          innerSpan.setAttribute(SemanticInternalAttributes.RETRY_DELAY, `${nextRetryDelay}ms`);\n          innerSpan.end();\n\n          await runtime.waitForDuration(nextRetryDelay);\n        } finally {\n          attempt++;\n        }\n      }\n\n      throw new Error(\"Max attempts reached\");\n    },\n    {\n      attributes: {\n        [SemanticInternalAttributes.STYLE_ICON]: \"arrow-capsule\",\n      },\n    }\n  );\n}\n\nexport interface RetryFetchRequestInit extends RequestInit {\n  retry?: FetchRetryOptions;\n  timeoutInMs?: number;\n}\n\nconst normalizeUrlFromInput = (input: RequestInfo | URL | string): URL => {\n  if (typeof input === \"string\") {\n    return new URL(input);\n  }\n\n  if (input instanceof URL) {\n    return input;\n  }\n\n  return new URL(input.url);\n};\n\nconst normalizeHttpMethod = (input: RequestInfo | URL | string, init?: RequestInit): string => {\n  if (typeof input === \"string\" || input instanceof URL) {\n    return (init?.method || \"GET\").toUpperCase();\n  }\n\n  return (input.method ?? init?.method ?? \"GET\").toUpperCase();\n};\n\nconst fetchHttpHandlerStorage = new AsyncLocalStorage<Array<HttpHandler>>();\n\nconst fetchWithInterceptors = async (\n  input: RequestInfo | URL,\n  init?: RequestInit\n): Promise<Response> => {\n  const handlers = fetchHttpHandlerStorage.getStore();\n\n  if (handlers) {\n    try {\n      const { getResponse } = await import(\"msw\");\n\n      const request = new Request(input, init);\n\n      const response = await getResponse(handlers, request);\n\n      if (response) {\n        return response;\n      }\n    } catch (e) {\n      // Do nothing\n      return fetch(input, init);\n    }\n  }\n\n  return fetch(input, init);\n};\n\nclass FetchErrorWithSpan extends Error {\n  constructor(\n    public readonly originalError: unknown,\n    public readonly span: Span\n  ) {\n    super(\"Fetch error\");\n  }\n}\n\nconst MAX_ATTEMPTS = 10;\n\nasync function retryFetch(\n  input: RequestInfo | URL,\n  init?: RetryFetchRequestInit | undefined\n): Promise<Response> {\n  return tracer.startActiveSpan(\n    \"retry.fetch()\",\n    async (span) => {\n      let attempt = 1;\n\n      while (true) {\n        try {\n          const abortController = new AbortController();\n\n          const timeoutId = init?.timeoutInMs\n            ? setTimeout(\n                () => {\n                  abortController.abort();\n                },\n                init?.timeoutInMs\n              )\n            : undefined;\n\n          init?.signal?.addEventListener(\"abort\", () => {\n            abortController.abort();\n          });\n\n          const [response, span] = await doFetchRequest(\n            input,\n            { ...(init ?? {}), signal: abortController.signal },\n            attempt\n          );\n\n          if (timeoutId) {\n            clearTimeout(timeoutId);\n          }\n\n          if (response.ok) {\n            span.setAttributes(createFetchResponseAttributes(response));\n\n            span.end();\n\n            return response;\n          }\n\n          const nextRetry = await calculateRetryDelayForResponse(\n            resolveDefaults(init?.retry, \"byStatus\", defaultFetchRetryOptions.byStatus),\n            response,\n            attempt\n          );\n\n          if (!nextRetry) {\n            span.setAttributes(createFetchResponseAttributes(response));\n\n            span.end();\n\n            return response;\n          }\n\n          if (attempt >= MAX_ATTEMPTS) {\n            span.setAttributes(createFetchResponseAttributes(response));\n\n            span.end();\n\n            return response;\n          }\n\n          if (nextRetry.type === \"delay\") {\n            span.setAttribute(\n              SemanticInternalAttributes.RETRY_AT,\n              new Date(Date.now() + nextRetry.value).toISOString()\n            );\n            span.setAttribute(SemanticInternalAttributes.RETRY_COUNT, attempt);\n            span.setAttribute(SemanticInternalAttributes.RETRY_DELAY, `${nextRetry.value}ms`);\n\n            span.end();\n\n            await runtime.waitForDuration(nextRetry.value);\n          } else {\n            const now = Date.now();\n            const nextRetryDate = new Date(nextRetry.value);\n            const isInFuture = nextRetryDate.getTime() > now;\n\n            span.setAttribute(\n              SemanticInternalAttributes.RETRY_AT,\n              new Date(nextRetry.value).toISOString()\n            );\n            span.setAttribute(SemanticInternalAttributes.RETRY_COUNT, attempt);\n\n            if (isInFuture) {\n              span.setAttribute(\n                SemanticInternalAttributes.RETRY_DELAY,\n                `${nextRetry.value - now}ms`\n              );\n            }\n\n            span.end();\n\n            await runtime.waitUntil(new Date(nextRetry.value));\n          }\n        } catch (e) {\n          if (e instanceof FetchErrorWithSpan && e.originalError instanceof Error) {\n            if (e.originalError.name === \"AbortError\") {\n              const nextRetryDelay = calculateNextRetryDelay(\n                resolveDefaults(init?.retry, \"timeout\", defaultFetchRetryOptions.timeout),\n                attempt\n              );\n\n              if (!nextRetryDelay) {\n                e.span.end();\n                throw e;\n              }\n\n              if (attempt >= MAX_ATTEMPTS) {\n                e.span.end();\n                throw e;\n              }\n\n              e.span.setAttribute(\n                SemanticInternalAttributes.RETRY_AT,\n                new Date(Date.now() + nextRetryDelay).toISOString()\n              );\n              e.span.setAttribute(SemanticInternalAttributes.RETRY_COUNT, attempt);\n              e.span.setAttribute(SemanticInternalAttributes.RETRY_DELAY, `${nextRetryDelay}ms`);\n\n              e.span.end();\n\n              await runtime.waitForDuration(nextRetryDelay);\n\n              continue; // Move to the next attempt\n            } else if (\n              e.originalError.name === \"TypeError\" &&\n              \"cause\" in e.originalError &&\n              e.originalError.cause instanceof Error\n            ) {\n              const nextRetryDelay = calculateNextRetryDelay(\n                resolveDefaults(\n                  init?.retry,\n                  \"connectionError\",\n                  defaultFetchRetryOptions.connectionError\n                ),\n                attempt\n              );\n\n              if (!nextRetryDelay) {\n                e.span.end();\n                throw e;\n              }\n\n              if (attempt >= MAX_ATTEMPTS) {\n                e.span.end();\n                throw e;\n              }\n\n              e.span.setAttribute(\n                SemanticInternalAttributes.RETRY_AT,\n                new Date(Date.now() + nextRetryDelay).toISOString()\n              );\n              e.span.setAttribute(SemanticInternalAttributes.RETRY_COUNT, attempt);\n              e.span.setAttribute(SemanticInternalAttributes.RETRY_DELAY, `${nextRetryDelay}ms`);\n\n              e.span.end();\n\n              await runtime.waitForDuration(nextRetryDelay);\n\n              continue; // Move to the next attempt\n            }\n          }\n\n          if (e instanceof FetchErrorWithSpan) {\n            e.span.end();\n          }\n\n          throw e;\n        } finally {\n          attempt++;\n        }\n      }\n    },\n    {\n      attributes: {\n        [SemanticInternalAttributes.STYLE_ICON]: \"arrow-capsule\",\n        ...createFetchAttributes(input, init),\n        ...createFetchRetryOptionsAttributes(init?.retry),\n      },\n    }\n  );\n}\n\nconst doFetchRequest = async (\n  input: RequestInfo | URL | string,\n  init?: RequestInit,\n  attemptCount: number = 0\n): Promise<[Response, Span]> => {\n  const httpMethod = normalizeHttpMethod(input, init);\n\n  const span = tracer.startSpan(`HTTP ${httpMethod}`, {\n    attributes: {\n      [SemanticInternalAttributes.STYLE_ICON]: \"world\",\n      ...(attemptCount > 1 ? { [\"http.request.resend_count\"]: attemptCount - 1 } : {}),\n      ...createFetchAttributes(input, init),\n    },\n  });\n\n  try {\n    const response = await fetchWithInterceptors(input, {\n      ...init,\n      headers: {\n        ...init?.headers,\n        \"x-retry-count\": attemptCount.toString(),\n      },\n    });\n\n    span.setAttributes(createFetchResponseAttributes(response));\n\n    if (!response.ok) {\n      span.recordException(`${response.status}: ${response.statusText}`);\n      span.setStatus({\n        code: SpanStatusCode.ERROR,\n        message: `${response.status}: ${response.statusText}`,\n      });\n    }\n\n    return [response, span];\n  } catch (e) {\n    if (typeof e === \"string\" || e instanceof Error) {\n      span.recordException(e);\n    }\n\n    span.setStatus({ code: SpanStatusCode.ERROR });\n    span.setAttribute(SEMATTRS_HTTP_STATUS_CODE, 0);\n    span.setAttribute(\"http.status_text\", \"This operation was aborted.\");\n\n    throw new FetchErrorWithSpan(e, span);\n  }\n};\n\nconst calculateRetryDelayForResponse = async (\n  retry: FetchRetryByStatusOptions | undefined,\n  response: Response,\n  attemptCount: number\n): Promise<{ type: \"delay\"; value: number } | { type: \"timestamp\"; value: number } | undefined> => {\n  if (!retry) {\n    return;\n  }\n\n  const strategy = await getRetryStrategyForResponse(response, retry);\n\n  if (!strategy) {\n    return;\n  }\n\n  switch (strategy.strategy) {\n    case \"backoff\": {\n      const value = calculateNextRetryDelay({ ...defaultRetryOptions, ...strategy }, attemptCount);\n\n      if (value) {\n        return { type: \"delay\", value };\n      }\n\n      break;\n    }\n    case \"headers\": {\n      const resetAt = response.headers.get(strategy.resetHeader);\n\n      if (typeof resetAt === \"string\") {\n        const resetTimestamp = calculateResetAt(\n          resetAt,\n          strategy.resetFormat ?? \"unix_timestamp_in_ms\"\n        );\n\n        if (resetTimestamp) {\n          return { type: \"timestamp\", value: resetTimestamp };\n        }\n      }\n\n      break;\n    }\n  }\n};\n\nconst getRetryStrategyForResponse = async (\n  response: Response,\n  retry: FetchRetryByStatusOptions\n): Promise<FetchRetryStrategy | undefined> => {\n  const statusCodes = Object.keys(retry);\n  const clonedResponse = response.clone();\n\n  for (let i = 0; i < statusCodes.length; i++) {\n    const statusRange = statusCodes[i];\n    const strategy = retry[statusRange];\n\n    if (isStatusCodeInRange(response.status, statusRange)) {\n      if (strategy.bodyFilter) {\n        const body = safeJsonParse(await clonedResponse.text());\n\n        if (!body) {\n          continue;\n        }\n\n        if (eventFilterMatches(body, strategy.bodyFilter)) {\n          return strategy;\n        } else {\n          continue;\n        }\n      }\n\n      return strategy;\n    }\n  }\n};\n\n/**\n * Checks if a given status code falls within a given range.\n * The range can be a single status code (e.g. \"200\"),\n * a range of status codes (e.g. \"500-599\"),\n * a range of status codes with a wildcard (e.g. \"4xx\" for any 4xx status code),\n * or a list of status codes separated by commas (e.g. \"401,403,404,409-412,5xx\").\n * Returns `true` if the status code falls within the range, and `false` otherwise.\n */\nconst isStatusCodeInRange = (statusCode: number, statusRange: string): boolean => {\n  if (statusRange === \"all\") {\n    return true;\n  }\n\n  if (statusRange.includes(\",\")) {\n    const statusCodes = statusRange.split(\",\").map((s) => s.trim());\n\n    return statusCodes.some((s) => isStatusCodeInRange(statusCode, s));\n  }\n\n  const [start, end] = statusRange.split(\"-\");\n\n  if (end) {\n    return statusCode >= parseInt(start, 10) && statusCode <= parseInt(end, 10);\n  }\n\n  if (start.endsWith(\"xx\")) {\n    const prefix = start.slice(0, -2);\n    const statusCodePrefix = Math.floor(statusCode / 100).toString();\n    return statusCodePrefix === prefix;\n  }\n\n  const statusCodeString = statusCode.toString();\n  const rangePrefix = start.slice(0, -1);\n\n  if (start.endsWith(\"x\") && statusCodeString.startsWith(rangePrefix)) {\n    return true;\n  }\n\n  return statusCode === parseInt(start, 10);\n};\n\nconst createAttributesFromHeaders = (headers: Headers): Attributes => {\n  const attributes: Attributes = {};\n\n  const normalizedHeaderKey = (key: string) => {\n    return key.toLowerCase();\n  };\n\n  headers.forEach((value, key) => {\n    attributes[`http.response.header.${normalizedHeaderKey(key)}`] = value;\n  });\n\n  return attributes;\n};\n\nconst safeJsonParse = (json: string): unknown => {\n  try {\n    return JSON.parse(json);\n  } catch (e) {\n    return null;\n  }\n};\n\nconst interceptFetch = (...handlers: Array<HttpHandler>) => {\n  return {\n    run: async <T>(fn: (...args: any[]) => Promise<T>): Promise<T> => {\n      const current = fetchHttpHandlerStorage.getStore();\n\n      if (current) {\n        current.push(...handlers);\n        return fn();\n      } else {\n        return fetchHttpHandlerStorage.run(handlers, fn);\n      }\n    },\n  };\n};\n\n// This function will resolve the defaults of a property within an options object.\n// If the options object is undefined, it will return the defaults for that property (passed in as the 3rd arg).\n// if the options object is defined, and the property exists, then it will return the defaults if the value of the property is undefined or null\nconst resolveDefaults = <\n  TObject extends Record<string, unknown>,\n  K extends keyof TObject,\n  TValue extends TObject[K],\n>(\n  obj: TObject | undefined,\n  key: K,\n  defaults: TValue\n): TValue => {\n  if (!obj) {\n    return defaults;\n  }\n\n  if (obj[key] === undefined || obj[key] === null) {\n    return defaults;\n  }\n\n  return obj[key] as TValue;\n};\n\nconst createFetchAttributes = (\n  input: RequestInfo | URL,\n  init?: RetryFetchRequestInit | undefined\n): Attributes => {\n  const url = normalizeUrlFromInput(input);\n  const httpMethod = normalizeHttpMethod(input, init);\n\n  return {\n    [SEMATTRS_HTTP_METHOD]: httpMethod,\n    [SEMATTRS_HTTP_URL]: url.href,\n    [SEMATTRS_HTTP_HOST]: url.hostname,\n    [\"server.host\"]: url.hostname,\n    [\"server.port\"]: url.port,\n    [SEMATTRS_HTTP_SCHEME]: url.protocol.replace(\":\", \"\"),\n    ...accessoryAttributes({\n      items: [\n        {\n          text: url.hostname,\n          variant: \"normal\",\n        },\n      ],\n      style: \"codepath\",\n    }),\n  };\n};\n\nconst createFetchResponseAttributes = (response: Response): Attributes => {\n  return {\n    [SEMATTRS_HTTP_STATUS_CODE]: response.status,\n    \"http.status_text\": response.statusText,\n    [SEMATTRS_HTTP_RESPONSE_CONTENT_LENGTH]: response.headers.get(\"content-length\") || \"0\",\n    ...createAttributesFromHeaders(response.headers),\n  };\n};\n\nconst createFetchRetryOptionsAttributes = (retry?: FetchRetryOptions): Attributes => {\n  const byStatus = resolveDefaults(retry, \"byStatus\", defaultFetchRetryOptions.byStatus);\n  const connectionError = resolveDefaults(\n    retry,\n    \"connectionError\",\n    defaultFetchRetryOptions.connectionError\n  );\n  const timeout = resolveDefaults(retry, \"timeout\", defaultFetchRetryOptions.timeout);\n\n  return {\n    ...flattenAttributes(byStatus, \"retry.byStatus\"),\n    ...flattenAttributes(connectionError, \"retry.connectionError\"),\n    ...flattenAttributes(timeout, \"retry.timeout\"),\n  };\n};\n\nexport const retry = {\n  onThrow,\n  fetch: retryFetch,\n  interceptFetch,\n};\n", "import { SpanKind } from \"@opentelemetry/api\";\nimport {\n  SEMATTRS_MESSAGING_DESTINATION,\n  SEMATTRS_MESSAGING_OPERATION,\n  SEMATTRS_MESSAGING_SYSTEM,\n} from \"@opentelemetry/semantic-conventions\";\nimport {\n  ApiRequestOptions,\n  BatchTaskRunExecutionResult,\n  FailureFnParams,\n  HandleErrorFnParams,\n  HandleErrorResult,\n  InitFnParams,\n  InitOutput,\n  MachineCpu,\n  MachineMemory,\n  MiddlewareFnParams,\n  QueueOptions,\n  RetryOptions,\n  RunFnParams,\n  RunTags,\n  SemanticInternalAttributes,\n  StartFnParams,\n  SuccessFnParams,\n  TaskRunContext,\n  TaskRunExecutionResult,\n  accessoryAttributes,\n  apiClientManager,\n  conditionallyImportPacket,\n  createErrorTaskError,\n  defaultRetryOptions,\n  logger,\n  parsePacket,\n  runtime,\n  stringifyIO,\n  taskCatalog,\n  taskContext,\n} from \"@trigger.dev/core/v3\";\nimport * as packageJson from \"../../package.json\";\nimport { tracer } from \"./tracer\";\nimport { PollOptions, RetrieveRunResult, runs } from \"./runs\";\nimport { IdempotencyKey, idempotencyKeys, isIdempotencyKey } from \"./idempotencyKeys\";\n\nexport type Context = TaskRunContext;\n\ntype RequireOne<T, K extends keyof T> = {\n  [X in Exclude<keyof T, K>]?: T[X];\n} & {\n  [P in K]-?: T[P];\n};\n\nexport type Queue = RequireOne<QueueOptions, \"name\">;\n\nexport function queue(options: { name: string } & QueueOptions): Queue {\n  return options;\n}\n\nexport type TaskOptions<\n  TIdentifier extends string,\n  TPayload = void,\n  TOutput = unknown,\n  TInitOutput extends InitOutput = any,\n> = {\n  /** An id for your task. This must be unique inside your project and not change between versions.  */\n  id: TIdentifier;\n  /** The retry settings when an uncaught error is thrown.\n   *\n   * If omitted it will use the values in your `trigger.config.ts` file.\n   * \n   * @example\n   * \n   * ```\n   * export const taskWithRetries = task({\n      id: \"task-with-retries\",\n      retry: {\n        maxAttempts: 10,\n        factor: 1.8,\n        minTimeoutInMs: 500,\n        maxTimeoutInMs: 30_000,\n        randomize: false,\n      },\n      run: async ({ payload, ctx }) => {\n        //...\n      },\n    });\n   * ```\n   * */\n  retry?: RetryOptions;\n  /** Used to configure what should happen when more than one run is triggered at the same time.\n   * \n   * @example \n   * one at a time execution\n   * \n   * ```ts\n   * export const oneAtATime = task({\n      id: \"one-at-a-time\",\n      queue: {\n        concurrencyLimit: 1,\n      },\n      run: async ({ payload, ctx }) => {\n        //...\n      },\n    });\n   * ```\n   */\n  queue?: QueueOptions;\n  /** Configure the spec of the machine you want your task to run on.\n   * \n   * @example\n   * \n   * ```ts\n   * export const heavyTask = task({\n      id: \"heavy-task\",\n      machine: {\n        cpu: 2,\n        memory: 4,\n      },\n      run: async ({ payload, ctx }) => {\n        //...\n      },\n    });\n   * ```\n  */\n  machine?: {\n    /** vCPUs. The default is 0.5.\n     *\n     * Possible values:\n     * - 0.25\n     * - 0.5\n     * - 1\n     * - 2\n     * - 4\n     * @deprecated use preset instead\n     */\n    cpu?: MachineCpu;\n    /** In GBs of RAM. The default is 1.\n     *\n     * Possible values:\n     * - 0.25\n     * - 0.5\n     * - 1\n     * - 2\n     * - 4\n     * - 8\n     * * @deprecated use preset instead\n     */\n    memory?: MachineMemory;\n\n    /** Preset to use for the machine. Defaults to small-1x */\n    preset?:\n      | \"micro\"\n      | \"small-1x\"\n      | \"small-2x\"\n      | \"medium-1x\"\n      | \"medium-2x\"\n      | \"large-1x\"\n      | \"large-2x\";\n  };\n\n  /** This gets called when a task is triggered. It's where you put the code you want to execute.\n   *\n   * @param payload - The payload that is passed to your task when it's triggered. This must be JSON serializable.\n   * @param params - Metadata about the run.\n   */\n  run: (payload: TPayload, params: RunFnParams<TInitOutput>) => Promise<TOutput>;\n\n  /**\n   * init is called before the run function is called. It's useful for setting up any global state.\n   */\n  init?: (payload: TPayload, params: InitFnParams) => Promise<TInitOutput>;\n\n  /**\n   * cleanup is called after the run function has completed.\n   */\n  cleanup?: (payload: TPayload, params: RunFnParams<TInitOutput>) => Promise<void>;\n\n  /**\n   * handleError is called when the run function throws an error. It can be used to modify the error or return new retry options.\n   */\n  handleError?: (\n    payload: TPayload,\n    error: unknown,\n    params: HandleErrorFnParams<TInitOutput>\n  ) => HandleErrorResult;\n\n  /**\n   * middleware allows you to run code \"around\" the run function. This can be useful for logging, metrics, or other cross-cutting concerns.\n   *\n   * When writing middleware, you should always call `next()` to continue the execution of the task:\n   *\n   * ```ts\n   * export const middlewareTask = task({\n   *  id: \"middleware-task\",\n   *  middleware: async (payload, { ctx, next }) => {\n   *   console.log(\"Before run\");\n   *   await next();\n   *   console.log(\"After run\");\n   *  },\n   *  run: async (payload, { ctx }) => {}\n   * });\n   * ```\n   */\n  middleware?: (payload: TPayload, params: MiddlewareFnParams) => Promise<void>;\n\n  /**\n   * onStart is called the first time a task is executed in a run (not before every retry)\n   */\n  onStart?: (payload: TPayload, params: StartFnParams) => Promise<void>;\n\n  /**\n   * onSuccess is called after the run function has successfully completed.\n   */\n  onSuccess?: (\n    payload: TPayload,\n    output: TOutput,\n    params: SuccessFnParams<TInitOutput>\n  ) => Promise<void>;\n\n  /**\n   * onFailure is called after a task run has failed (meaning the run function threw an error and won't be retried anymore)\n   */\n  onFailure?: (\n    payload: TPayload,\n    error: unknown,\n    params: FailureFnParams<TInitOutput>\n  ) => Promise<void>;\n};\n\ndeclare const __output: unique symbol;\ntype BrandOutput<B> = { [__output]: B };\nexport type BrandedOutput<T, B> = T & BrandOutput<B>;\n\nexport type RunHandle<TOutput> = BrandedOutput<\n  {\n    id: string;\n  },\n  TOutput\n>;\n\n/**\n * A BatchRunHandle can be used to retrieve the runs of a batch trigger in a typesafe manner.\n */\nexport type BatchRunHandle<TOutput> = BrandedOutput<\n  {\n    batchId: string;\n    runs: Array<RunHandle<TOutput>>;\n  },\n  TOutput\n>;\n\nexport type RunHandleOutput<TRunHandle> = TRunHandle extends RunHandle<infer TOutput>\n  ? TOutput\n  : never;\n\nexport type TaskRunResult<TOutput = any> =\n  | {\n      ok: true;\n      id: string;\n      output: TOutput;\n    }\n  | {\n      ok: false;\n      id: string;\n      error: unknown;\n    };\n\nexport type BatchResult<TOutput = any> = {\n  id: string;\n  runs: TaskRunResult<TOutput>[];\n};\n\nexport type BatchItem<TInput> = TInput extends void\n  ? { payload?: TInput; options?: TaskRunOptions }\n  : { payload: TInput; options?: TaskRunOptions };\n\nexport interface Task<TIdentifier extends string, TInput = void, TOutput = any> {\n  /**\n   * The id of the task.\n   */\n  id: TIdentifier;\n  /**\n   * Trigger a task with the given payload, and continue without waiting for the result. If you want to wait for the result, use `triggerAndWait`. Returns the id of the triggered task run.\n   * @param payload\n   * @param options\n   * @returns RunHandle\n   * - `id` - The id of the triggered task run.\n   */\n  trigger: (payload: TInput, options?: TaskRunOptions) => Promise<RunHandle<TOutput>>;\n\n  /**\n   * Batch trigger multiple task runs with the given payloads, and continue without waiting for the results. If you want to wait for the results, use `batchTriggerAndWait`. Returns the id of the triggered batch.\n   * @param items\n   * @returns InvokeBatchHandle\n   * - `batchId` - The id of the triggered batch.\n   * - `runs` - The ids of the triggered task runs.\n   */\n  batchTrigger: (items: Array<BatchItem<TInput>>) => Promise<BatchRunHandle<TOutput>>;\n\n  /**\n   * Trigger a task with the given payload, and wait for the result. Returns the result of the task run\n   * @param payload\n   * @param options - Options for the task run\n   * @returns TaskRunResult\n   * @example\n   * ```\n   * const result = await task.triggerAndWait({ foo: \"bar\" });\n   *\n   * if (result.ok) {\n   *  console.log(result.output);\n   * } else {\n   *  console.error(result.error);\n   * }\n   * ```\n   */\n  triggerAndWait: (payload: TInput, options?: TaskRunOptions) => Promise<TaskRunResult<TOutput>>;\n\n  /**\n   * Batch trigger multiple task runs with the given payloads, and wait for the results. Returns the results of the task runs.\n   * @param items\n   * @returns BatchResult\n   * @example\n   * ```\n   * const result = await task.batchTriggerAndWait([\n   *  { payload: { foo: \"bar\" } },\n   *  { payload: { foo: \"baz\" } },\n   * ]);\n   *\n   * for (const run of result.runs) {\n   *  if (run.ok) {\n   *    console.log(run.output);\n   *  } else {\n   *    console.error(run.error);\n   *  }\n   * }\n   * ```\n   */\n  batchTriggerAndWait: (items: Array<BatchItem<TInput>>) => Promise<BatchResult<TOutput>>;\n}\n\nexport type AnyTask = Task<string, any, any>;\n\nexport type TaskPayload<TTask extends AnyTask> = TTask extends Task<string, infer TInput, any>\n  ? TInput\n  : never;\n\nexport type TaskOutput<TTask extends AnyTask> = TTask extends Task<string, any, infer TOutput>\n  ? TOutput\n  : never;\n\nexport type TaskOutputHandle<TTask extends AnyTask> = TTask extends Task<string, any, infer TOutput>\n  ? RunHandle<TOutput>\n  : never;\n\nexport type TaskBatchOutputHandle<TTask extends AnyTask> = TTask extends Task<\n  string,\n  any,\n  infer TOutput\n>\n  ? BatchRunHandle<TOutput>\n  : never;\n\nexport type TaskIdentifier<TTask extends AnyTask> = TTask extends Task<infer TIdentifier, any, any>\n  ? TIdentifier\n  : never;\n\nexport type TaskRunOptions = {\n  /**\n   * A unique key that can be used to ensure that a task is only triggered once per key.\n   *\n   * You can use `idempotencyKeys.create` to create an idempotency key first, and then pass it to the task options.\n   *\n   * @example\n   *\n   * ```typescript\n   * import { idempotencyKeys, task } from \"@trigger.dev/sdk/v3\";\n   *\n   * export const myTask = task({\n   *  id: \"my-task\",\n   *  run: async (payload: any) => {\n   *   // scoped to the task run by default\n   *   const idempotencyKey = await idempotencyKeys.create(\"my-task-key\");\n   *\n   *   // Use the idempotency key when triggering child tasks\n   *   await childTask.triggerAndWait(payload, { idempotencyKey });\n   *\n   *   // scoped globally, does not include the task run ID\n   *   const globalIdempotencyKey = await idempotencyKeys.create(\"my-task-key\", { scope: \"global\" });\n   *\n   *   await childTask.triggerAndWait(payload, { idempotencyKey: globalIdempotencyKey });\n   *\n   *   // You can also pass a string directly, which is the same as a global idempotency key\n   *   await childTask.triggerAndWait(payload, { idempotencyKey: \"my-very-unique-key\" });\n   *  }\n   * });\n   * ```\n   *\n   * When triggering a task inside another task, we automatically inject the run ID into the key material.\n   *\n   * If you are triggering a task from your backend, ensure you include some sufficiently unique key material to prevent collisions.\n   *\n   * @example\n   *\n   * ```typescript\n   * import { idempotencyKeys, tasks } from \"@trigger.dev/sdk/v3\";\n   *\n   * // Somewhere in your backend\n   * const idempotencyKey = await idempotenceKeys.create([\"my-task-trigger\", \"user-123\"]);\n   * await tasks.trigger(\"my-task\", { foo: \"bar\" }, { idempotencyKey });\n   * ```\n   *\n   */\n  idempotencyKey?: IdempotencyKey | string | string[];\n  maxAttempts?: number;\n  queue?: TaskRunConcurrencyOptions;\n  concurrencyKey?: string;\n  /**\n   * The delay before the task is executed. This can be a string like \"1h\" or a Date object.\n   *\n   * @example\n   * \"1h\" - 1 hour\n   * \"30d\" - 30 days\n   * \"15m\" - 15 minutes\n   * \"2w\" - 2 weeks\n   * \"60s\" - 60 seconds\n   * new Date(\"2025-01-01T00:00:00Z\")\n   */\n  delay?: string | Date;\n\n  /**\n   * Set a time-to-live for this run. If the run is not executed within this time, it will be removed from the queue and never execute.\n   *\n   * @example\n   *\n   * ```ts\n   * await myTask.trigger({ foo: \"bar\" }, { ttl: \"1h\" });\n   * await myTask.trigger({ foo: \"bar\" }, { ttl: 60 * 60 }); // 1 hour\n   * ```\n   *\n   * The minimum value is 1 second. Setting the `ttl` to `0` will disable the TTL and the run will never expire.\n   *\n   * **Note:** Runs in development have a default `ttl` of 10 minutes. You can override this by setting the `ttl` option.\n   */\n  ttl?: string | number;\n\n  /**\n   * Tags to attach to the run. Tags can be used to filter runs in the dashboard and using the SDK.\n   *\n   * You can set up to 5 tags per run, they must be less than 64 characters each.\n   *\n   * We recommend prefixing tags with a namespace using an underscore or colon, like `user_1234567` or `org:9876543`.\n   *\n   * @example\n   *\n   * ```ts\n   * await myTask.trigger({ foo: \"bar\" }, { tags: [\"user:1234567\", \"org:9876543\"] });\n   * ```\n   */\n  tags?: RunTags;\n};\n\ntype TaskRunConcurrencyOptions = Queue;\n\nexport type Prettify<T> = {\n  [K in keyof T]: T[K];\n} & {};\n\nexport type DynamicBaseOptions = {\n  id: string;\n};\n\nexport function createTask<\n  TIdentifier extends string,\n  TInput = void,\n  TOutput = unknown,\n  TInitOutput extends InitOutput = any,\n>(\n  params: TaskOptions<TIdentifier, TInput, TOutput, TInitOutput>\n): Task<TIdentifier, TInput, TOutput> {\n  const customQueue = params.queue\n    ? queue({\n        name: params.queue?.name ?? `task/${params.id}`,\n        ...params.queue,\n      })\n    : undefined;\n\n  const task: Task<TIdentifier, TInput, TOutput> = {\n    id: params.id,\n    trigger: async (payload, options) => {\n      const taskMetadata = taskCatalog.getTaskMetadata(params.id);\n\n      return await trigger_internal<TInput, TOutput>(\n        taskMetadata && taskMetadata.exportName\n          ? `${taskMetadata.exportName}.trigger()`\n          : `trigger()`,\n        params.id,\n        payload,\n        {\n          queue: customQueue,\n          ...options,\n        }\n      );\n    },\n    batchTrigger: async (items) => {\n      const taskMetadata = taskCatalog.getTaskMetadata(params.id);\n\n      return await batchTrigger_internal<TInput, TOutput>(\n        taskMetadata && taskMetadata.exportName\n          ? `${taskMetadata.exportName}.batchTrigger()`\n          : `batchTrigger()`,\n        params.id,\n        items,\n        undefined,\n        customQueue\n      );\n    },\n    triggerAndWait: async (payload, options) => {\n      const taskMetadata = taskCatalog.getTaskMetadata(params.id);\n\n      return await triggerAndWait_internal<TInput, TOutput>(\n        taskMetadata && taskMetadata.exportName\n          ? `${taskMetadata.exportName}.triggerAndWait()`\n          : `triggerAndWait()`,\n        params.id,\n        payload,\n        {\n          queue: customQueue,\n          ...options,\n        }\n      );\n    },\n    batchTriggerAndWait: async (items) => {\n      const taskMetadata = taskCatalog.getTaskMetadata(params.id);\n\n      return await batchTriggerAndWait_internal<TInput, TOutput>(\n        taskMetadata && taskMetadata.exportName\n          ? `${taskMetadata.exportName}.batchTriggerAndWait()`\n          : `batchTriggerAndWait()`,\n        params.id,\n        items,\n        undefined,\n        customQueue\n      );\n    },\n  };\n\n  taskCatalog.registerTaskMetadata({\n    id: params.id,\n    packageVersion: packageJson.version,\n    queue: params.queue,\n    retry: params.retry ? { ...defaultRetryOptions, ...params.retry } : undefined,\n    machine: params.machine,\n    fns: {\n      run: params.run,\n      init: params.init,\n      cleanup: params.cleanup,\n      middleware: params.middleware,\n      handleError: params.handleError,\n      onSuccess: params.onSuccess,\n      onFailure: params.onFailure,\n      onStart: params.onStart,\n    },\n  });\n\n  return task;\n}\n\n/**\n * Trigger a task by its identifier with the given payload. Returns a typesafe `RunHandle`.\n *\n * @example\n *\n * ```ts\n * import { tasks, runs } from \"@trigger.dev/sdk/v3\";\n * import type { myTask } from \"./myTasks\"; // Import just the type of the task\n *\n * const handle = await tasks.trigger<typeof myTask>(\"my-task\", { foo: \"bar\" }); // The id and payload are fully typesafe\n * const run = await runs.retrieve(handle);\n * console.log(run.output) // The output is also fully typed\n * ```\n *\n * @returns {RunHandle} An object with the `id` of the run. Can be used to retrieve the completed run output in a typesafe manner.\n */\nexport async function trigger<TTask extends AnyTask>(\n  id: TaskIdentifier<TTask>,\n  payload: TaskPayload<TTask>,\n  options?: TaskRunOptions,\n  requestOptions?: ApiRequestOptions\n): Promise<RunHandle<TaskOutput<TTask>>> {\n  return await trigger_internal<TaskPayload<TTask>, TaskOutput<TTask>>(\n    \"tasks.trigger()\",\n    id,\n    payload,\n    options,\n    requestOptions\n  );\n}\n\n/**\n * Trigger a task with the given payload, and wait for the result. Returns the result of the task run\n * @param id - The id of the task to trigger\n * @param payload\n * @param options - Options for the task run\n * @returns TaskRunResult\n * @example\n * ```ts\n * import { tasks } from \"@trigger.dev/sdk/v3\";\n * const result = await tasks.triggerAndWait(\"my-task\", { foo: \"bar\" });\n *\n * if (result.ok) {\n *  console.log(result.output);\n * } else {\n *  console.error(result.error);\n * }\n * ```\n */\nexport async function triggerAndWait<TTask extends AnyTask>(\n  id: TaskIdentifier<TTask>,\n  payload: TaskPayload<TTask>,\n  options?: TaskRunOptions,\n  requestOptions?: ApiRequestOptions\n): Promise<TaskRunResult<TaskOutput<TTask>>> {\n  return await triggerAndWait_internal<TaskPayload<TTask>, TaskOutput<TTask>>(\n    \"tasks.triggerAndWait()\",\n    id,\n    payload,\n    options,\n    requestOptions\n  );\n}\n\n/**\n * Batch trigger multiple task runs with the given payloads, and wait for the results. Returns the results of the task runs.\n * @param id - The id of the task to trigger\n * @param items\n * @returns BatchResult\n * @example\n *\n * ```ts\n * import { tasks } from \"@trigger.dev/sdk/v3\";\n *\n * const result = await tasks.batchTriggerAndWait(\"my-task\", [\n *  { payload: { foo: \"bar\" } },\n *  { payload: { foo: \"baz\" } },\n * ]);\n *\n * for (const run of result.runs) {\n *  if (run.ok) {\n *    console.log(run.output);\n *  } else {\n *    console.error(run.error);\n *  }\n * }\n * ```\n */\nexport async function batchTriggerAndWait<TTask extends AnyTask>(\n  id: TaskIdentifier<TTask>,\n  items: Array<BatchItem<TaskPayload<TTask>>>,\n  requestOptions?: ApiRequestOptions\n): Promise<BatchResult<TaskOutput<TTask>>> {\n  return await batchTriggerAndWait_internal<TaskPayload<TTask>, TaskOutput<TTask>>(\n    \"tasks.batchTriggerAndWait()\",\n    id,\n    items,\n    requestOptions\n  );\n}\n\n/**\n * Trigger a task by its identifier with the given payload and poll until the run is completed.\n *\n * @example\n *\n * ```ts\n * import { tasks, runs } from \"@trigger.dev/sdk/v3\";\n * import type { myTask } from \"./myTasks\"; // Import just the type of the task\n *\n * const run = await tasks.triggerAndPoll<typeof myTask>(\"my-task\", { foo: \"bar\" }); // The id and payload are fully typesafe\n * console.log(run.output) // The output is also fully typed\n * ```\n *\n * @returns {Run} The completed run, either successful or failed.\n */\nexport async function triggerAndPoll<TTask extends AnyTask>(\n  id: TaskIdentifier<TTask>,\n  payload: TaskPayload<TTask>,\n  options?: TaskRunOptions & PollOptions,\n  requestOptions?: ApiRequestOptions\n): Promise<RetrieveRunResult<RunHandle<TaskOutput<TTask>>>> {\n  const handle = await trigger(id, payload, options, requestOptions);\n\n  return runs.poll(handle, options, requestOptions);\n}\n\nexport async function batchTrigger<TTask extends AnyTask>(\n  id: TaskIdentifier<TTask>,\n  items: Array<BatchItem<TaskPayload<TTask>>>,\n  requestOptions?: ApiRequestOptions\n): Promise<BatchRunHandle<TaskOutput<TTask>>> {\n  return await batchTrigger_internal<TaskPayload<TTask>, TaskOutput<TTask>>(\n    \"tasks.batchTrigger()\",\n    id,\n    items,\n    requestOptions\n  );\n}\n\nasync function trigger_internal<TPayload, TOutput>(\n  name: string,\n  id: string,\n  payload: TPayload,\n  options?: TaskRunOptions,\n  requestOptions?: ApiRequestOptions\n): Promise<RunHandle<TOutput>> {\n  const apiClient = apiClientManager.client;\n\n  if (!apiClient) {\n    throw apiClientMissingError();\n  }\n\n  const payloadPacket = await stringifyIO(payload);\n\n  const handle = await apiClient.triggerTask(\n    id,\n    {\n      payload: payloadPacket.data,\n      options: {\n        queue: options?.queue,\n        concurrencyKey: options?.concurrencyKey,\n        test: taskContext.ctx?.run.isTest,\n        payloadType: payloadPacket.dataType,\n        idempotencyKey: await makeKey(options?.idempotencyKey),\n        delay: options?.delay,\n        ttl: options?.ttl,\n        tags: options?.tags,\n        maxAttempts: options?.maxAttempts,\n      },\n    },\n    {\n      spanParentAsLink: true,\n    },\n    {\n      name,\n      tracer,\n      icon: \"trigger\",\n      attributes: {\n        [SEMATTRS_MESSAGING_OPERATION]: \"publish\",\n        [\"messaging.client_id\"]: taskContext.worker?.id,\n        [SEMATTRS_MESSAGING_SYSTEM]: \"trigger.dev\",\n        ...accessoryAttributes({\n          items: [\n            {\n              text: id,\n              variant: \"normal\",\n            },\n          ],\n          style: \"codepath\",\n        }),\n      },\n      onResponseBody: (body, span) => {\n        body &&\n          typeof body === \"object\" &&\n          !Array.isArray(body) &&\n          \"id\" in body &&\n          typeof body.id === \"string\" &&\n          span.setAttribute(\"messaging.message.id\", body.id);\n      },\n      ...requestOptions,\n    }\n  );\n\n  return handle as RunHandle<TOutput>;\n}\n\nasync function batchTrigger_internal<TPayload, TOutput>(\n  name: string,\n  id: string,\n  items: Array<BatchItem<TPayload>>,\n  requestOptions?: ApiRequestOptions,\n  queue?: QueueOptions\n): Promise<BatchRunHandle<TOutput>> {\n  const apiClient = apiClientManager.client;\n\n  if (!apiClient) {\n    throw apiClientMissingError();\n  }\n\n  const response = await apiClient.batchTriggerTask(\n    id,\n    {\n      items: await Promise.all(\n        items.map(async (item) => {\n          const payloadPacket = await stringifyIO(item.payload);\n\n          return {\n            payload: payloadPacket.data,\n            options: {\n              queue: item.options?.queue ?? queue,\n              concurrencyKey: item.options?.concurrencyKey,\n              test: taskContext.ctx?.run.isTest,\n              payloadType: payloadPacket.dataType,\n              idempotencyKey: await makeKey(item.options?.idempotencyKey),\n              delay: item.options?.delay,\n              ttl: item.options?.ttl,\n              tags: item.options?.tags,\n              maxAttempts: item.options?.maxAttempts,\n            },\n          };\n        })\n      ),\n    },\n    { spanParentAsLink: true },\n    {\n      name,\n      tracer,\n      icon: \"trigger\",\n      attributes: {\n        [SEMATTRS_MESSAGING_OPERATION]: \"publish\",\n        [\"messaging.client_id\"]: taskContext.worker?.id,\n        [SEMATTRS_MESSAGING_SYSTEM]: \"trigger.dev\",\n        ...accessoryAttributes({\n          items: [\n            {\n              text: id,\n              variant: \"normal\",\n            },\n          ],\n          style: \"codepath\",\n        }),\n      },\n      ...requestOptions,\n    }\n  );\n\n  const handle = {\n    batchId: response.batchId,\n    runs: response.runs.map((id) => ({ id })),\n  };\n\n  return handle as BatchRunHandle<TOutput>;\n}\n\nasync function triggerAndWait_internal<TPayload, TOutput>(\n  name: string,\n  id: string,\n  payload: TPayload,\n  options?: TaskRunOptions,\n  requestOptions?: ApiRequestOptions\n): Promise<TaskRunResult<TOutput>> {\n  const ctx = taskContext.ctx;\n\n  if (!ctx) {\n    throw new Error(\"triggerAndWait can only be used from inside a task.run()\");\n  }\n\n  const apiClient = apiClientManager.client;\n\n  if (!apiClient) {\n    throw apiClientMissingError();\n  }\n\n  const payloadPacket = await stringifyIO(payload);\n\n  return await tracer.startActiveSpan(\n    name,\n    async (span) => {\n      const response = await apiClient.triggerTask(\n        id,\n        {\n          payload: payloadPacket.data,\n          options: {\n            dependentAttempt: ctx.attempt.id,\n            lockToVersion: taskContext.worker?.version, // Lock to current version because we're waiting for it to finish\n            queue: options?.queue,\n            concurrencyKey: options?.concurrencyKey,\n            test: taskContext.ctx?.run.isTest,\n            payloadType: payloadPacket.dataType,\n            idempotencyKey: await makeKey(options?.idempotencyKey),\n            delay: options?.delay,\n            ttl: options?.ttl,\n            tags: options?.tags,\n            maxAttempts: options?.maxAttempts,\n          },\n        },\n        {},\n        requestOptions\n      );\n\n      span.setAttribute(\"messaging.message.id\", response.id);\n\n      if (options?.idempotencyKey) {\n        // If an idempotency key is provided, we can check if the result is already available\n        const result = await apiClient.getRunResult(response.id);\n\n        if (result) {\n          logger.log(\n            `Result reused from previous task run with idempotency key '${options.idempotencyKey}'.`,\n            {\n              runId: response.id,\n              idempotencyKey: options.idempotencyKey,\n            }\n          );\n\n          return await handleTaskRunExecutionResult<TOutput>(result);\n        }\n      }\n\n      const result = await runtime.waitForTask({\n        id: response.id,\n        ctx,\n      });\n\n      return await handleTaskRunExecutionResult<TOutput>(result);\n    },\n    {\n      kind: SpanKind.PRODUCER,\n      attributes: {\n        [SemanticInternalAttributes.STYLE_ICON]: \"trigger\",\n        [SEMATTRS_MESSAGING_OPERATION]: \"publish\",\n        [\"messaging.client_id\"]: taskContext.worker?.id,\n        [SEMATTRS_MESSAGING_DESTINATION]: id,\n        [SEMATTRS_MESSAGING_SYSTEM]: \"trigger.dev\",\n        ...accessoryAttributes({\n          items: [\n            {\n              text: id,\n              variant: \"normal\",\n            },\n          ],\n          style: \"codepath\",\n        }),\n      },\n    }\n  );\n}\n\nasync function batchTriggerAndWait_internal<TPayload, TOutput>(\n  name: string,\n  id: string,\n  items: Array<BatchItem<TPayload>>,\n  requestOptions?: ApiRequestOptions,\n  queue?: QueueOptions\n): Promise<BatchResult<TOutput>> {\n  const ctx = taskContext.ctx;\n\n  if (!ctx) {\n    throw new Error(\"batchTriggerAndWait can only be used from inside a task.run()\");\n  }\n\n  const apiClient = apiClientManager.client;\n\n  if (!apiClient) {\n    throw apiClientMissingError();\n  }\n\n  return await tracer.startActiveSpan(\n    name,\n    async (span) => {\n      const response = await apiClient.batchTriggerTask(\n        id,\n        {\n          items: await Promise.all(\n            items.map(async (item) => {\n              const payloadPacket = await stringifyIO(item.payload);\n\n              return {\n                payload: payloadPacket.data,\n                options: {\n                  lockToVersion: taskContext.worker?.version,\n                  queue: item.options?.queue ?? queue,\n                  concurrencyKey: item.options?.concurrencyKey,\n                  test: taskContext.ctx?.run.isTest,\n                  payloadType: payloadPacket.dataType,\n                  idempotencyKey: await makeKey(item.options?.idempotencyKey),\n                  delay: item.options?.delay,\n                  ttl: item.options?.ttl,\n                  tags: item.options?.tags,\n                  maxAttempts: item.options?.maxAttempts,\n                },\n              };\n            })\n          ),\n          dependentAttempt: ctx.attempt.id,\n        },\n        {},\n        requestOptions\n      );\n\n      span.setAttribute(\"messaging.message.id\", response.batchId);\n\n      const getBatchResults = async (): Promise<BatchTaskRunExecutionResult> => {\n        // We need to check if the results are already available, but only if any of the items options has an idempotency key\n        const hasIdempotencyKey = items.some((item) => item.options?.idempotencyKey);\n\n        if (hasIdempotencyKey) {\n          const results = await apiClient.getBatchResults(response.batchId);\n\n          if (results) {\n            return results;\n          }\n        }\n\n        return {\n          id: response.batchId,\n          items: [],\n        };\n      };\n\n      const existingResults = await getBatchResults();\n\n      const incompleteRuns = response.runs.filter(\n        (runId) => !existingResults.items.some((item) => item.id === runId)\n      );\n\n      if (incompleteRuns.length === 0) {\n        logger.log(\n          `Results reused from previous task runs because of the provided idempotency keys.`\n        );\n\n        // All runs are already completed\n        const runs = await handleBatchTaskRunExecutionResult<TOutput>(existingResults.items);\n\n        return {\n          id: existingResults.id,\n          runs,\n        };\n      }\n\n      const result = await runtime.waitForBatch({\n        id: response.batchId,\n        runs: incompleteRuns,\n        ctx,\n      });\n\n      // Combine the already completed runs with the newly completed runs, ordered by the original order\n      const combinedItems: BatchTaskRunExecutionResult[\"items\"] = [];\n\n      for (const runId of response.runs) {\n        const existingItem = existingResults.items.find((item) => item.id === runId);\n\n        if (existingItem) {\n          combinedItems.push(existingItem);\n        } else {\n          const newItem = result.items.find((item) => item.id === runId);\n\n          if (newItem) {\n            combinedItems.push(newItem);\n          }\n        }\n      }\n\n      const runs = await handleBatchTaskRunExecutionResult<TOutput>(combinedItems);\n\n      return {\n        id: result.id,\n        runs,\n      };\n    },\n    {\n      kind: SpanKind.PRODUCER,\n      attributes: {\n        [SemanticInternalAttributes.STYLE_ICON]: \"trigger\",\n        [\"messaging.batch.message_count\"]: items.length,\n        [SEMATTRS_MESSAGING_OPERATION]: \"publish\",\n        [\"messaging.client_id\"]: taskContext.worker?.id,\n        [SEMATTRS_MESSAGING_DESTINATION]: id,\n        [SEMATTRS_MESSAGING_SYSTEM]: \"trigger.dev\",\n        ...accessoryAttributes({\n          items: [\n            {\n              text: id,\n              variant: \"normal\",\n            },\n          ],\n          style: \"codepath\",\n        }),\n      },\n    }\n  );\n}\n\nasync function handleBatchTaskRunExecutionResult<TOutput>(\n  items: Array<TaskRunExecutionResult>\n): Promise<Array<TaskRunResult<TOutput>>> {\n  const someObjectStoreOutputs = items.some(\n    (item) => item.ok && item.outputType === \"application/store\"\n  );\n\n  if (!someObjectStoreOutputs) {\n    const results = await Promise.all(\n      items.map(async (item) => {\n        return await handleTaskRunExecutionResult<TOutput>(item);\n      })\n    );\n\n    return results;\n  }\n\n  return await tracer.startActiveSpan(\n    \"store.downloadPayloads\",\n    async (span) => {\n      const results = await Promise.all(\n        items.map(async (item) => {\n          return await handleTaskRunExecutionResult<TOutput>(item);\n        })\n      );\n\n      return results;\n    },\n    {\n      kind: SpanKind.INTERNAL,\n      [SemanticInternalAttributes.STYLE_ICON]: \"cloud-download\",\n    }\n  );\n}\n\nasync function handleTaskRunExecutionResult<TOutput>(\n  execution: TaskRunExecutionResult\n): Promise<TaskRunResult<TOutput>> {\n  if (execution.ok) {\n    const outputPacket = { data: execution.output, dataType: execution.outputType };\n    const importedPacket = await conditionallyImportPacket(outputPacket, tracer);\n\n    return {\n      ok: true,\n      id: execution.id,\n      output: await parsePacket(importedPacket),\n    };\n  } else {\n    return {\n      ok: false,\n      id: execution.id,\n      error: createErrorTaskError(execution.error),\n    };\n  }\n}\n\nexport function apiClientMissingError() {\n  const hasBaseUrl = !!apiClientManager.baseURL;\n  const hasAccessToken = !!apiClientManager.accessToken;\n  if (!hasBaseUrl && !hasAccessToken) {\n    return `You need to set the TRIGGER_API_URL and TRIGGER_SECRET_KEY environment variables.`;\n  } else if (!hasBaseUrl) {\n    return `You need to set the TRIGGER_API_URL environment variable.`;\n  } else if (!hasAccessToken) {\n    return `You need to set the TRIGGER_SECRET_KEY environment variable.`;\n  }\n\n  return `Unknown error`;\n}\n\nasync function makeKey(\n  idempotencyKey?: IdempotencyKey | string | string[]\n): Promise<IdempotencyKey | undefined> {\n  if (!idempotencyKey) {\n    return;\n  }\n\n  if (isIdempotencyKey(idempotencyKey)) {\n    return idempotencyKey;\n  }\n\n  return await idempotencyKeys.create(idempotencyKey, { scope: \"global\" });\n}\n", "import type {\n  ApiRequestOptions,\n  ListProjectRunsQueryParams,\n  ListRunsQueryParams,\n  RescheduleRunRequestBody,\n} from \"@trigger.dev/core/v3\";\nimport {\n  ApiPromise,\n  CanceledRunResponse,\n  CursorPagePromise,\n  ListRunResponseItem,\n  ReplayRunResponse,\n  RetrieveRunResponse,\n  accessoryAttributes,\n  apiClientManager,\n  flattenAttributes,\n  isRequestOptions,\n  mergeRequestOptions,\n} from \"@trigger.dev/core/v3\";\nimport { AnyTask, Prettify, RunHandle, Task, apiClientMissingError } from \"./shared\";\nimport { tracer } from \"./tracer\";\n\nexport type RetrieveRunResult<TRunId> = Prettify<\n  TRunId extends RunHandle<infer TOutput>\n    ? Omit<RetrieveRunResponse, \"output\"> & { output?: TOutput }\n    : TRunId extends Task<string, any, infer TTaskOutput>\n    ? Omit<RetrieveRunResponse, \"output\"> & { output?: TTaskOutput }\n    : TRunId extends string\n    ? RetrieveRunResponse\n    : never\n>;\n\nexport const runs = {\n  replay: replayRun,\n  cancel: cancelRun,\n  retrieve: retrieveRun,\n  list: listRuns,\n  reschedule: rescheduleRun,\n  poll,\n};\n\nexport type ListRunsItem = ListRunResponseItem;\n\nfunction listRuns(\n  projectRef: string,\n  params?: ListProjectRunsQueryParams,\n  requestOptions?: ApiRequestOptions\n): CursorPagePromise<typeof ListRunResponseItem>;\nfunction listRuns(\n  params?: ListRunsQueryParams,\n  requestOptions?: ApiRequestOptions\n): CursorPagePromise<typeof ListRunResponseItem>;\nfunction listRuns(\n  paramsOrProjectRef?: ListRunsQueryParams | string,\n  paramsOrOptions?: ListRunsQueryParams | ListProjectRunsQueryParams | ApiRequestOptions,\n  requestOptions?: ApiRequestOptions\n): CursorPagePromise<typeof ListRunResponseItem> {\n  const apiClient = apiClientManager.client;\n\n  if (!apiClient) {\n    throw apiClientMissingError();\n  }\n\n  const $requestOptions = listRunsRequestOptions(\n    paramsOrProjectRef,\n    paramsOrOptions,\n    requestOptions\n  );\n\n  if (typeof paramsOrProjectRef === \"string\") {\n    if (isRequestOptions(paramsOrOptions)) {\n      return apiClient.listProjectRuns(paramsOrProjectRef, {}, $requestOptions);\n    } else {\n      return apiClient.listProjectRuns(paramsOrProjectRef, paramsOrOptions, $requestOptions);\n    }\n  }\n\n  return apiClient.listRuns(paramsOrProjectRef, $requestOptions);\n}\n\nfunction listRunsRequestOptions(\n  paramsOrProjectRef?: ListRunsQueryParams | string,\n  paramsOrOptions?: ListRunsQueryParams | ListProjectRunsQueryParams | ApiRequestOptions,\n  requestOptions?: ApiRequestOptions\n): ApiRequestOptions {\n  if (typeof paramsOrProjectRef === \"string\") {\n    if (isRequestOptions(paramsOrOptions)) {\n      return mergeRequestOptions(\n        {\n          tracer,\n          name: \"runs.list()\",\n          icon: \"runs\",\n          attributes: {\n            projectRef: paramsOrProjectRef,\n            ...accessoryAttributes({\n              items: [\n                {\n                  text: paramsOrProjectRef,\n                  variant: \"normal\",\n                },\n              ],\n              style: \"codepath\",\n            }),\n          },\n        },\n        paramsOrOptions\n      );\n    } else {\n      return mergeRequestOptions(\n        {\n          tracer,\n          name: \"runs.list()\",\n          icon: \"runs\",\n          attributes: {\n            projectRef: paramsOrProjectRef,\n            ...flattenAttributes(paramsOrOptions as Record<string, unknown>, \"queryParams\"),\n            ...accessoryAttributes({\n              items: [\n                {\n                  text: paramsOrProjectRef,\n                  variant: \"normal\",\n                },\n              ],\n              style: \"codepath\",\n            }),\n          },\n        },\n        requestOptions\n      );\n    }\n  }\n\n  return mergeRequestOptions(\n    {\n      tracer,\n      name: \"runs.list()\",\n      icon: \"runs\",\n      attributes: {\n        ...flattenAttributes(paramsOrProjectRef as Record<string, unknown>, \"queryParams\"),\n      },\n    },\n    isRequestOptions(paramsOrOptions) ? paramsOrOptions : requestOptions\n  );\n}\n\n// Extract out the expected type of the id, can be either a string or a RunHandle\ntype RunId<TRunId> = TRunId extends RunHandle<any>\n  ? TRunId\n  : TRunId extends AnyTask\n  ? string\n  : TRunId extends string\n  ? TRunId\n  : never;\n\nfunction retrieveRun<TRunId extends RunHandle<any> | AnyTask | string>(\n  runId: RunId<TRunId>,\n  requestOptions?: ApiRequestOptions\n): ApiPromise<RetrieveRunResult<TRunId>> {\n  const apiClient = apiClientManager.client;\n\n  if (!apiClient) {\n    throw apiClientMissingError();\n  }\n\n  const $requestOptions = mergeRequestOptions(\n    {\n      tracer,\n      name: \"runs.retrieve()\",\n      icon: \"runs\",\n      attributes: {\n        runId: typeof runId === \"string\" ? runId : runId.id,\n        ...accessoryAttributes({\n          items: [\n            {\n              text: typeof runId === \"string\" ? runId : runId.id,\n              variant: \"normal\",\n            },\n          ],\n          style: \"codepath\",\n        }),\n      },\n    },\n    requestOptions\n  );\n\n  if (typeof runId === \"string\") {\n    return apiClient.retrieveRun(runId, $requestOptions) as ApiPromise<RetrieveRunResult<TRunId>>;\n  } else {\n    return apiClient.retrieveRun(runId.id, $requestOptions) as ApiPromise<\n      RetrieveRunResult<TRunId>\n    >;\n  }\n}\n\nfunction replayRun(\n  runId: string,\n  requestOptions?: ApiRequestOptions\n): ApiPromise<ReplayRunResponse> {\n  const apiClient = apiClientManager.client;\n\n  if (!apiClient) {\n    throw apiClientMissingError();\n  }\n\n  const $requestOptions = mergeRequestOptions(\n    {\n      tracer,\n      name: \"runs.replay()\",\n      icon: \"runs\",\n      attributes: {\n        runId,\n        ...accessoryAttributes({\n          items: [\n            {\n              text: runId,\n              variant: \"normal\",\n            },\n          ],\n          style: \"codepath\",\n        }),\n      },\n    },\n    requestOptions\n  );\n\n  return apiClient.replayRun(runId, $requestOptions);\n}\n\nfunction cancelRun(\n  runId: string,\n  requestOptions?: ApiRequestOptions\n): ApiPromise<CanceledRunResponse> {\n  const apiClient = apiClientManager.client;\n\n  if (!apiClient) {\n    throw apiClientMissingError();\n  }\n\n  const $requestOptions = mergeRequestOptions(\n    {\n      tracer,\n      name: \"runs.cancel()\",\n      icon: \"runs\",\n      attributes: {\n        runId,\n        ...accessoryAttributes({\n          items: [\n            {\n              text: runId,\n              variant: \"normal\",\n            },\n          ],\n          style: \"codepath\",\n        }),\n      },\n    },\n    requestOptions\n  );\n\n  return apiClient.cancelRun(runId, $requestOptions);\n}\n\nfunction rescheduleRun(\n  runId: string,\n  body: RescheduleRunRequestBody,\n  requestOptions?: ApiRequestOptions\n): ApiPromise<RetrieveRunResponse> {\n  const apiClient = apiClientManager.client;\n\n  if (!apiClient) {\n    throw apiClientMissingError();\n  }\n\n  const $requestOptions = mergeRequestOptions(\n    {\n      tracer,\n      name: \"runs.reschedule()\",\n      icon: \"runs\",\n      attributes: {\n        runId,\n        ...accessoryAttributes({\n          items: [\n            {\n              text: runId,\n              variant: \"normal\",\n            },\n          ],\n          style: \"codepath\",\n        }),\n      },\n    },\n    requestOptions\n  );\n\n  return apiClient.rescheduleRun(runId, body, $requestOptions);\n}\n\nexport type PollOptions = { pollIntervalMs?: number };\n\nconst MAX_POLL_ATTEMPTS = 500;\n\nasync function poll<TRunId extends RunHandle<any> | AnyTask | string>(\n  runId: RunId<TRunId>,\n  options?: { pollIntervalMs?: number },\n  requestOptions?: ApiRequestOptions\n) {\n  let attempts = 0;\n\n  while (attempts++ < MAX_POLL_ATTEMPTS) {\n    const run = await runs.retrieve(runId, requestOptions);\n\n    if (run.isCompleted) {\n      return run;\n    }\n\n    await new Promise((resolve) => setTimeout(resolve, options?.pollIntervalMs ?? 1000));\n  }\n\n  throw new Error(\n    `Run ${\n      typeof runId === \"string\" ? runId : runId.id\n    } did not complete after ${MAX_POLL_ATTEMPTS} attempts`\n  );\n}\n", "import { taskContext } from \"@trigger.dev/core/v3\";\n\nexport const idempotencyKeys = {\n  create: createIdempotencyKey,\n};\n\ndeclare const __brand: unique symbol;\ntype Brand<B> = { [__brand]: B };\ntype Branded<T, B> = T & Brand<B>;\n\nexport type IdempotencyKey = Branded<string, \"IdempotencyKey\">;\n\nexport function isIdempotencyKey(\n  value: string | string[] | IdempotencyKey\n): value is IdempotencyKey {\n  // Cannot check the brand at runtime because it doesn't exist (it's a TypeScript-only construct)\n  return typeof value === \"string\" && value.length === 64;\n}\n\n/**\n * Creates a deterministic idempotency key based on the provided key material.\n *\n * If running inside a task, the task run ID is automatically included in the key material, giving you a unique key per task run.\n * This ensures that a given child task is only triggered once per task run, even if the parent task is retried.\n *\n * @param {string | string[]} key The key material to create the idempotency key from.\n * @param {object} [options] Additional options.\n * @param {\"run\" | \"attempt\" | \"global\"} [options.scope=\"run\"] The scope of the idempotency key.\n *\n * @returns {Promise<IdempotencyKey>} The idempotency key as a branded string.\n *\n * @example\n *\n * ```typescript\n * import { idempotencyKeys, task } from \"@trigger.dev/sdk/v3\";\n *\n * export const myTask = task({\n *  id: \"my-task\",\n *  run: async (payload: any) => {\n *   const idempotencyKey = await idempotencyKeys.create(\"my-task-key\");\n *\n *   // Use the idempotency key when triggering child tasks\n *   await childTask.triggerAndWait(payload, { idempotencyKey });\n *  }\n * });\n * ```\n *\n * You can also use the `scope` parameter to create a key that is unique per task run, task run attempts (retries of the same run), or globally:\n *\n * ```typescript\n *  await idempotencyKeys.create(\"my-task-key\", { scope: \"attempt\" }); // Creates a key that is unique per task run attempt\n *  await idempotencyKeys.create(\"my-task-key\", { scope: \"global\" }); // Skips including the task run ID\n * ```\n */\nasync function createIdempotencyKey(\n  key: string | string[],\n  options?: { scope?: \"run\" | \"attempt\" | \"global\" }\n): Promise<IdempotencyKey> {\n  const idempotencyKey = await generateIdempotencyKey(\n    [...(Array.isArray(key) ? key : [key])].concat(injectScope(options?.scope ?? \"run\"))\n  );\n\n  return idempotencyKey as IdempotencyKey;\n}\n\nfunction injectScope(scope: \"run\" | \"attempt\" | \"global\"): string[] {\n  switch (scope) {\n    case \"run\": {\n      if (taskContext?.ctx) {\n        return [taskContext.ctx.run.id];\n      }\n    }\n    case \"attempt\": {\n      if (taskContext?.ctx) {\n        return [taskContext.ctx.attempt.id];\n      }\n    }\n  }\n\n  return [];\n}\n\nasync function generateIdempotencyKey(keyMaterial: string[]) {\n  const hash = await crypto.subtle.digest(\n    \"SHA-256\",\n    new TextEncoder().encode(keyMaterial.join(\"-\"))\n  );\n\n  // Return a hex string, using cross-runtime compatible methods\n  return Array.from(new Uint8Array(hash))\n    .map((byte) => byte.toString(16).padStart(2, \"0\"))\n    .join(\"\");\n}\n", "import { InitOutput } from \"@trigger.dev/core/v3\";\nimport {\n  batchTrigger,\n  batchTriggerAndWait,\n  createTask,\n  trigger,\n  triggerAndPoll,\n  triggerAndWait,\n} from \"./shared\";\n\nimport type {\n  TaskOptions,\n  Task,\n  Queue,\n  RunHandle,\n  BatchRunHandle,\n  TaskRunResult,\n  BatchResult,\n  BatchItem,\n  TaskPayload,\n  TaskOutput,\n  TaskIdentifier,\n  TaskRunOptions,\n  AnyTask,\n} from \"./shared\";\n\nexport type {\n  TaskOptions,\n  Task,\n  Queue,\n  RunHandle,\n  BatchRunHandle,\n  TaskRunResult,\n  BatchResult,\n  BatchItem,\n  TaskPayload,\n  TaskOutput,\n  TaskIdentifier,\n  TaskRunOptions,\n  AnyTask,\n};\n\n/** Creates a task that can be triggered\n * @param options - Task options\n * @example \n * \n * ```ts\n * import { task } from \"@trigger.dev/sdk/v3\";\n *\n * export const helloWorld = task({\n    id: \"hello-world\",\n *    run: async (payload: { url: string }) => {\n *    return { hello: \"world\" };\n *  },\n * });\n *\n * ```\n * \n * @returns A task that can be triggered\n */\nexport function task<\n  TIdentifier extends string,\n  TInput = void,\n  TOutput = unknown,\n  TInitOutput extends InitOutput = any,\n>(\n  options: TaskOptions<TIdentifier, TInput, TOutput, TInitOutput>\n): Task<TIdentifier, TInput, TOutput> {\n  return createTask<TIdentifier, TInput, TOutput, TInitOutput>(options);\n}\n\nexport const tasks = {\n  trigger,\n  triggerAndPoll,\n  batchTrigger,\n  triggerAndWait,\n  batchTriggerAndWait,\n};\n", "import { SemanticInternalAttributes, accessoryAttributes, runtime } from \"@trigger.dev/core/v3\";\nimport { tracer } from \"./tracer\";\n\nexport type WaitOptions =\n  | {\n      seconds: number;\n    }\n  | {\n      minutes: number;\n    }\n  | {\n      hours: number;\n    }\n  | {\n      days: number;\n    }\n  | {\n      weeks: number;\n    }\n  | {\n      months: number;\n    }\n  | {\n      years: number;\n    };\n\nexport const wait = {\n  for: async (options: WaitOptions) => {\n    return tracer.startActiveSpan(\n      `wait.for()`,\n      async (span) => {\n        const start = Date.now();\n        const durationInMs = calculateDurationInMs(options);\n\n        await runtime.waitForDuration(durationInMs);\n      },\n      {\n        attributes: {\n          [SemanticInternalAttributes.STYLE_ICON]: \"wait\",\n          ...accessoryAttributes({\n            items: [\n              {\n                text: nameForWaitOptions(options),\n                variant: \"normal\",\n              },\n            ],\n            style: \"codepath\",\n          }),\n        },\n      }\n    );\n  },\n  until: async (options: { date: Date; throwIfInThePast?: boolean }) => {\n    return tracer.startActiveSpan(\n      `wait.until()`,\n      async (span) => {\n        const start = Date.now();\n\n        if (options.throwIfInThePast && options.date < new Date()) {\n          throw new Error(\"Date is in the past\");\n        }\n\n        const durationInMs = options.date.getTime() - start;\n\n        await runtime.waitForDuration(durationInMs);\n      },\n      {\n        attributes: {\n          [SemanticInternalAttributes.STYLE_ICON]: \"wait\",\n          ...accessoryAttributes({\n            items: [\n              {\n                text: options.date.toISOString(),\n                variant: \"normal\",\n              },\n            ],\n            style: \"codepath\",\n          }),\n        },\n      }\n    );\n  },\n};\n\nfunction nameForWaitOptions(options: WaitOptions): string {\n  if (\"seconds\" in options) {\n    return options.seconds === 1 ? `1 second` : `${options.seconds} seconds`;\n  }\n\n  if (\"minutes\" in options) {\n    return options.minutes === 1 ? `1 minute` : `${options.minutes} minutes`;\n  }\n\n  if (\"hours\" in options) {\n    return options.hours === 1 ? `1 hour` : `${options.hours} hours`;\n  }\n\n  if (\"days\" in options) {\n    return options.days === 1 ? `1 day` : `${options.days} days`;\n  }\n\n  if (\"weeks\" in options) {\n    return options.weeks === 1 ? `1 week` : `${options.weeks} weeks`;\n  }\n\n  if (\"months\" in options) {\n    return options.months === 1 ? `1 month` : `${options.months} months`;\n  }\n\n  if (\"years\" in options) {\n    return options.years === 1 ? `1 year` : `${options.years} years`;\n  }\n\n  return \"NaN\";\n}\n\nfunction calculateDurationInMs(options: WaitOptions): number {\n  if (\"seconds\" in options) {\n    return options.seconds * 1000;\n  }\n\n  if (\"minutes\" in options) {\n    return options.minutes * 1000 * 60;\n  }\n\n  if (\"hours\" in options) {\n    return options.hours * 1000 * 60 * 60;\n  }\n\n  if (\"days\" in options) {\n    return options.days * 1000 * 60 * 60 * 24;\n  }\n\n  if (\"weeks\" in options) {\n    return options.weeks * 1000 * 60 * 60 * 24 * 7;\n  }\n\n  if (\"months\" in options) {\n    return options.months * 1000 * 60 * 60 * 24 * 30;\n  }\n\n  if (\"years\" in options) {\n    return options.years * 1000 * 60 * 60 * 24 * 365;\n  }\n\n  throw new Error(\"Invalid options\");\n}\n\ntype RequestOptions = {\n  to: (url: string) => Promise<void>;\n  timeout: WaitOptions;\n};\n", "import { usage as usageApi, taskContext } from \"@trigger.dev/core/v3\";\n\nexport type ComputeUsage = {\n  costInCents: number;\n  durationMs: number;\n};\n\n// What about run start cost and what should we call that? Some better names\nexport type CurrentUsage = {\n  compute: {\n    attempt: ComputeUsage;\n    total: ComputeUsage;\n  };\n  baseCostInCents: number;\n  totalCostInCents: number;\n};\n\nexport const usage = {\n  /**\n   * Get the current running usage of this task run.\n   *\n   * @example\n   *\n   * ```typescript\n   * import { usage, task } from \"@trigger.dev/sdk/v3\";\n   *\n   * export const myTask = task({\n   *  id: \"my-task\",\n   *  run: async (payload, { ctx }) => {\n   *   // ... Do a bunch of work\n   *\n   *   const currentUsage = usage.getCurrent();\n   *\n   *   // You have access to the current compute cost and duration up to this point\n   *   console.log(\"Current attempt compute cost and duration\", {\n   *     cost: currentUsage.compute.attempt.costInCents,\n   *     duration: currentUsage.compute.attempt.durationMs,\n   *   });\n   *\n   *   // You also can see the total compute cost and duration up to this point in the run, across all attempts\n   *   console.log(\"Current total compute cost and duration\", {\n   *     cost: currentUsage.compute.total.costInCents,\n   *     duration: currentUsage.compute.total.durationMs,\n   *   });\n   *\n   *   // You can see the base cost of the run, which is the cost of the run before any compute costs\n   *   console.log(\"Total cost\", {\n   *     cost: currentUsage.totalCostInCents,\n   *     baseCost: currentUsage.baseCostInCents,\n   *   });\n   *  },\n   * });\n   * ```\n   */\n  getCurrent: (): CurrentUsage => {\n    const sample = usageApi.sample();\n    const machine = taskContext.ctx?.machine;\n    const run = taskContext.ctx?.run;\n\n    if (!sample) {\n      return {\n        compute: {\n          attempt: {\n            costInCents: 0,\n            durationMs: 0,\n          },\n          total: {\n            costInCents: run?.costInCents ?? 0,\n            durationMs: run?.durationMs ?? 0,\n          },\n        },\n        baseCostInCents: run?.baseCostInCents ?? 0,\n        totalCostInCents: (run?.costInCents ?? 0) + (run?.baseCostInCents ?? 0),\n      };\n    }\n\n    const currentCostInCents = machine?.centsPerMs ? sample.cpuTime * machine.centsPerMs : 0;\n\n    return {\n      compute: {\n        attempt: {\n          costInCents: currentCostInCents,\n          durationMs: sample.cpuTime,\n        },\n        total: {\n          costInCents: (run?.costInCents ?? 0) + currentCostInCents,\n          durationMs: (run?.durationMs ?? 0) + sample.cpuTime,\n        },\n      },\n      baseCostInCents: run?.baseCostInCents ?? 0,\n      totalCostInCents: (run?.costInCents ?? 0) + currentCostInCents + (run?.baseCostInCents ?? 0),\n    };\n  },\n  /**\n   * Measure the cost and duration of a function.\n   *\n   * @example\n   *\n   * ```typescript\n   * import { usage } from \"@trigger.dev/sdk/v3\";\n   *\n   * export const myTask = task({\n   *  id: \"my-task\",\n   *  run: async (payload, { ctx }) => {\n   *    const { result, compute } = await usage.measure(async () => {\n   *      // Do some work\n   *      return \"result\";\n   *    });\n   *\n   *    console.log(\"Result\", result);\n   *    console.log(\"Cost and duration\", { cost: compute.costInCents, duration: compute.durationMs });\n   *  },\n   * });\n   * ```\n   */\n  measure: async <T>(cb: () => Promise<T>): Promise<{ result: T; compute: ComputeUsage }> => {\n    const measurement = usageApi.start();\n\n    const result = await cb();\n\n    const sample = usageApi.stop(measurement);\n    const machine = taskContext.ctx?.machine;\n\n    const costInCents = machine?.centsPerMs ? sample.cpuTime * machine.centsPerMs : 0;\n\n    return {\n      result,\n      compute: {\n        costInCents,\n        durationMs: sample.cpuTime,\n      },\n    };\n  },\n};\n", "import type { ApiRequestOptions, RunTags } from \"@trigger.dev/core/v3\";\nimport {\n  UnprocessableEntityError,\n  accessoryAttributes,\n  apiClientManager,\n  logger,\n  mergeRequestOptions,\n  taskContext,\n} from \"@trigger.dev/core/v3\";\nimport { apiClientMissingError } from \"./shared\";\nimport { tracer } from \"./tracer\";\n\nexport const tags = {\n  add: addTags,\n};\n\nasync function addTags(tags: RunTags, requestOptions?: ApiRequestOptions) {\n  const apiClient = apiClientManager.client;\n\n  if (!apiClient) {\n    throw apiClientMissingError();\n  }\n\n  const run = taskContext.ctx?.run;\n  if (!run) {\n    throw new Error(\n      \"Can't set tags outside of a run. You can trigger a task and set tags in the options.\"\n    );\n  }\n\n  const $requestOptions = mergeRequestOptions(\n    {\n      tracer,\n      name: \"tags.set()\",\n      icon: \"tag\",\n      attributes: {\n        ...accessoryAttributes({\n          items: [\n            {\n              text: typeof tags === \"string\" ? tags : tags.join(\", \"),\n              variant: \"normal\",\n            },\n          ],\n          style: \"codepath\",\n        }),\n      },\n    },\n    requestOptions\n  );\n\n  try {\n    await apiClient.addTags(run.id, { tags }, $requestOptions);\n  } catch (error) {\n    if (error instanceof UnprocessableEntityError) {\n      logger.error(error.message, {\n        existingTags: run.tags,\n        newTags: tags,\n      });\n      return;\n    }\n\n    logger.error(\"Failed to set tags\", { error });\n\n    throw error;\n  }\n}\n", "export * from \"./cache\";\nexport * from \"./config\";\nexport { retry, type RetryOptions } from \"./retry\";\nexport { queue } from \"./shared\";\nexport * from \"./tasks\";\nexport * from \"./wait\";\nexport * from \"./usage\";\nexport * from \"./idempotencyKeys\";\nexport * from \"./tags\";\nexport type { Context };\n\nimport type { Context } from \"./shared\";\n\nimport type { ApiClientConfiguration } from \"@trigger.dev/core/v3\";\nimport { apiClientManager } from \"@trigger.dev/core/v3\";\n\nexport type { ApiClientConfiguration };\n\nexport {\n  ApiError,\n  AuthenticationError,\n  BadRequestError,\n  ConflictError,\n  InternalServerError,\n  NotFoundError,\n  PermissionDeniedError,\n  RateLimitError,\n  UnprocessableEntityError,\n  AbortTaskRunError,\n  logger,\n  type LogLevel,\n} from \"@trigger.dev/core/v3\";\n\nexport { runs } from \"./runs\";\nexport * as schedules from \"./schedules\";\nexport * as envvars from \"./envvars\";\nexport type { ImportEnvironmentVariablesParams } from \"./envvars\";\n\n/**\n * Register the global API client configuration. Alternatively, you can set the `TRIGGER_SECRET_KEY` and `TRIGGER_API_URL` environment variables.\n * @param options The API client configuration.\n * @param options.baseURL The base URL of the Trigger API. (default: `https://api.trigger.dev`)\n * @param options.secretKey The secret key to authenticate with the Trigger API. (default: `process.env.TRIGGER_SECRET_KEY`) This can be found in your Trigger.dev project \"API Keys\" settings.\n *\n * @example\n *\n * ```typescript\n * import { configure } from \"@trigger.dev/sdk/v3\";\n *\n * configure({\n *  baseURL: \"https://api.trigger.dev\",\n *  secretKey: \"tr_dev_1234567890\"\n * });\n * ```\n */\nexport function configure(options: ApiClientConfiguration) {\n  apiClientManager.setGlobalAPIClientConfiguration(options);\n}\n", "import {\n  ApiPromise,\n  ApiRequestOptions,\n  DeletedScheduleObject,\n  InitOutput,\n  OffsetLimitPagePromise,\n  ScheduleObject,\n  TimezonesResult,\n  accessoryAttributes,\n  apiClientManager,\n  mergeRequestOptions,\n  taskCatalog,\n} from \"@trigger.dev/core/v3\";\nimport { zodfetch } from \"@trigger.dev/core/v3/zodfetch\";\nimport { Task, TaskOptions, apiClientMissingError, createTask } from \"../shared\";\nimport * as SchedulesAPI from \"./api\";\nimport { tracer } from \"../tracer\";\n\nexport type ScheduleOptions<\n  TIdentifier extends string,\n  TOutput,\n  TInitOutput extends InitOutput,\n> = TaskOptions<TIdentifier, SchedulesAPI.ScheduledTaskPayload, TOutput, TInitOutput> & {\n  /** You can optionally specify a CRON schedule on your task. You can also dynamically add a schedule in the dashboard or using the SDK functions.\n   *\n   * 1. Pass a CRON pattern string\n   * ```ts\n   * \"0 0 * * *\"\n   * ```\n   *\n   * 2. Or an object with a pattern and an optional timezone (default is \"UTC\")\n   * ```ts\n   * {\n   *   pattern: \"0 0 * * *\",\n   *   timezone: \"America/Los_Angeles\"\n   * }\n   * ```\n   *\n   * @link https://trigger.dev/docs/v3/tasks-scheduled\n   */\n  cron?:\n    | string\n    | {\n        pattern: string;\n        timezone?: string;\n      };\n};\n\nexport function task<TIdentifier extends string, TOutput, TInitOutput extends InitOutput>(\n  params: ScheduleOptions<TIdentifier, TOutput, TInitOutput>\n): Task<TIdentifier, SchedulesAPI.ScheduledTaskPayload, TOutput> {\n  const task = createTask(params);\n\n  const cron = params.cron\n    ? typeof params.cron === \"string\"\n      ? params.cron\n      : params.cron.pattern\n    : undefined;\n  const timezone =\n    (params.cron && typeof params.cron !== \"string\" ? params.cron.timezone : \"UTC\") ?? \"UTC\";\n\n  taskCatalog.updateTaskMetadata(task.id, {\n    triggerSource: \"schedule\",\n    schedule: cron\n      ? {\n          cron: cron,\n          timezone,\n        }\n      : undefined,\n  });\n\n  return task;\n}\n\n/**\n * Creates a new schedule\n * @param options\n * @param options.task - The identifier of the task to be scheduled (Must already exist and be a scheduled task)\n * @param options.cron - The cron expression for the schedule (e.g. `0 0 * * *`)\n * @param options.timezone - An optional timezone for the schedule in the IANA format (e.g. `America/Los_Angeles`). Defaults to \"UTC\".\n * @param options.externalId - An optional external identifier for the schedule\n * @param options.deduplicationKey - An optional deduplication key for the schedule\n * @returns The created schedule\n */\nexport function create(\n  options: SchedulesAPI.CreateScheduleOptions,\n  requestOptions?: ApiRequestOptions\n): ApiPromise<ScheduleObject> {\n  const apiClient = apiClientManager.client;\n\n  if (!apiClient) {\n    throw apiClientMissingError();\n  }\n\n  const $requestOptions = mergeRequestOptions(\n    {\n      tracer,\n      name: \"schedules.create()\",\n      icon: \"clock\",\n      attributes: {\n        ...accessoryAttributes({\n          items: [\n            {\n              text: options.cron,\n              variant: \"normal\",\n            },\n          ],\n          style: \"codepath\",\n        }),\n      },\n    },\n    requestOptions\n  );\n\n  return apiClient.createSchedule(options, $requestOptions);\n}\n\n/**\n * Retrieves a schedule\n * @param scheduleId - The ID of the schedule to retrieve\n * @returns The retrieved schedule\n */\nexport function retrieve(\n  scheduleId: string,\n  requestOptions?: ApiRequestOptions\n): ApiPromise<ScheduleObject> {\n  const apiClient = apiClientManager.client;\n\n  if (!apiClient) {\n    throw apiClientMissingError();\n  }\n\n  const $requestOptions = mergeRequestOptions(\n    {\n      tracer,\n      name: \"schedules.retrieve()\",\n      icon: \"clock\",\n      attributes: {\n        scheduleId,\n        ...accessoryAttributes({\n          items: [\n            {\n              text: scheduleId,\n              variant: \"normal\",\n            },\n          ],\n          style: \"codepath\",\n        }),\n      },\n    },\n    requestOptions\n  );\n\n  return apiClient.retrieveSchedule(scheduleId, $requestOptions);\n}\n\n/**\n * Updates a schedule\n * @param scheduleId - The ID of the schedule to update\n * @param options - The updated schedule options\n * @param options.task - The identifier of the task to be scheduled (Must already exist and be a scheduled task)\n * @param options.cron - The cron expression for the schedule (e.g. `0 0 * * *`)\n * @param options.timezone - An optional timezone for the schedule in the IANA format (e.g. `America/Los_Angeles`). Defaults to \"UTC\".\n * @param options.externalId - An optional external identifier for the schedule\n * @returns The updated schedule\n */\nexport function update(\n  scheduleId: string,\n  options: SchedulesAPI.UpdateScheduleOptions,\n  requestOptions?: ApiRequestOptions\n): ApiPromise<ScheduleObject> {\n  const apiClient = apiClientManager.client;\n\n  if (!apiClient) {\n    throw apiClientMissingError();\n  }\n\n  const $requestOptions = mergeRequestOptions(\n    {\n      tracer,\n      name: \"schedules.update()\",\n      icon: \"clock\",\n      attributes: {\n        scheduleId,\n        ...accessoryAttributes({\n          items: [\n            {\n              text: scheduleId,\n              variant: \"normal\",\n            },\n          ],\n          style: \"codepath\",\n        }),\n      },\n    },\n    requestOptions\n  );\n\n  return apiClient.updateSchedule(scheduleId, options, $requestOptions);\n}\n\n/**\n * Deletes a schedule\n * @param scheduleId - The ID of the schedule to delete\n */\nexport function del(\n  scheduleId: string,\n  requestOptions?: ApiRequestOptions\n): ApiPromise<DeletedScheduleObject> {\n  const apiClient = apiClientManager.client;\n\n  if (!apiClient) {\n    throw apiClientMissingError();\n  }\n\n  const $requestOptions = mergeRequestOptions(\n    {\n      tracer,\n      name: \"schedules.delete()\",\n      icon: \"clock\",\n      attributes: {\n        scheduleId,\n        ...accessoryAttributes({\n          items: [\n            {\n              text: scheduleId,\n              variant: \"normal\",\n            },\n          ],\n          style: \"codepath\",\n        }),\n      },\n    },\n    requestOptions\n  );\n\n  return apiClient.deleteSchedule(scheduleId, $requestOptions);\n}\n\n/**\n * Deactivates a schedule\n * @param scheduleId - The ID of the schedule to deactivate\n */\nexport function deactivate(\n  scheduleId: string,\n  requestOptions?: ApiRequestOptions\n): ApiPromise<ScheduleObject> {\n  const apiClient = apiClientManager.client;\n\n  if (!apiClient) {\n    throw apiClientMissingError();\n  }\n\n  const $requestOptions = mergeRequestOptions(\n    {\n      tracer,\n      name: \"schedules.deactivate()\",\n      icon: \"clock\",\n      attributes: {\n        scheduleId,\n        ...accessoryAttributes({\n          items: [\n            {\n              text: scheduleId,\n              variant: \"normal\",\n            },\n          ],\n          style: \"codepath\",\n        }),\n      },\n    },\n    requestOptions\n  );\n\n  return apiClient.deactivateSchedule(scheduleId, $requestOptions);\n}\n\n/**\n * Activates a schedule\n * @param scheduleId - The ID of the schedule to activate\n */\nexport function activate(\n  scheduleId: string,\n  requestOptions?: ApiRequestOptions\n): ApiPromise<ScheduleObject> {\n  const apiClient = apiClientManager.client;\n\n  if (!apiClient) {\n    throw apiClientMissingError();\n  }\n\n  const $requestOptions = mergeRequestOptions(\n    {\n      tracer,\n      name: \"schedules.activate()\",\n      icon: \"clock\",\n      attributes: {\n        scheduleId,\n        ...accessoryAttributes({\n          items: [\n            {\n              text: scheduleId,\n              variant: \"normal\",\n            },\n          ],\n          style: \"codepath\",\n        }),\n      },\n    },\n    requestOptions\n  );\n\n  return apiClient.activateSchedule(scheduleId, $requestOptions);\n}\n\n/**\n * Lists schedules\n * @param options - The list options\n * @param options.page - The page number\n * @param options.perPage - The number of schedules per page\n * @returns The list of schedules\n */\nexport function list(\n  options?: SchedulesAPI.ListScheduleOptions,\n  requestOptions?: ApiRequestOptions\n): OffsetLimitPagePromise<typeof ScheduleObject> {\n  const apiClient = apiClientManager.client;\n\n  if (!apiClient) {\n    throw apiClientMissingError();\n  }\n\n  const $requestOptions = mergeRequestOptions(\n    {\n      tracer,\n      name: \"schedules.list()\",\n      icon: \"clock\",\n    },\n    requestOptions\n  );\n\n  return apiClient.listSchedules(options, $requestOptions);\n}\n\n/**\n * Lists the possible timezones we support\n * @param excludeUtc - By default \"UTC\" is included and is first. If true, \"UTC\" will be excluded.\n */\nexport function timezones(options?: { excludeUtc?: boolean }) {\n  const baseUrl = apiClientManager.baseURL;\n\n  if (!baseUrl) {\n    throw apiClientMissingError();\n  }\n\n  return zodfetch(\n    TimezonesResult,\n    `${baseUrl}/api/v1/timezones${options?.excludeUtc === true ? \"?excludeUtc=true\" : \"\"}`,\n    {\n      method: \"GET\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n      },\n    }\n  );\n}\n", "import type {\n  ApiPromise,\n  ApiRequestOptions,\n  CreateEnvironmentVariableParams,\n  EnvironmentVariableResponseBody,\n  EnvironmentVariableValue,\n  EnvironmentVariables,\n  ImportEnvironmentVariablesParams,\n  UpdateEnvironmentVariableParams,\n} from \"@trigger.dev/core/v3\";\nimport {\n  apiClientManager,\n  isRequestOptions,\n  mergeRequestOptions,\n  taskContext,\n} from \"@trigger.dev/core/v3\";\nimport { apiClientMissingError } from \"./shared\";\nimport { tracer } from \"./tracer\";\n\nexport type { CreateEnvironmentVariableParams, ImportEnvironmentVariablesParams };\n\nexport function upload(\n  projectRef: string,\n  slug: string,\n  params: ImportEnvironmentVariablesParams,\n  requestOptions?: ApiRequestOptions\n): ApiPromise<EnvironmentVariableResponseBody>;\nexport function upload(\n  params: ImportEnvironmentVariablesParams,\n  requestOptions?: ApiRequestOptions\n): ApiPromise<EnvironmentVariableResponseBody>;\nexport function upload(\n  projectRefOrParams: string | ImportEnvironmentVariablesParams,\n  slugOrRequestOptions?: string | ApiRequestOptions,\n  params?: ImportEnvironmentVariablesParams,\n  requestOptions?: ApiRequestOptions\n): ApiPromise<EnvironmentVariableResponseBody> {\n  let $projectRef: string;\n  let $params: ImportEnvironmentVariablesParams;\n  let $slug: string;\n  const $requestOptions = overloadRequestOptions(\"upload\", slugOrRequestOptions, requestOptions);\n\n  if (taskContext.ctx) {\n    if (typeof projectRefOrParams === \"string\") {\n      $projectRef = projectRefOrParams;\n      $slug =\n        typeof slugOrRequestOptions === \"string\"\n          ? slugOrRequestOptions\n          : taskContext.ctx.environment.slug;\n\n      if (!params) {\n        throw new Error(\"params is required\");\n      }\n\n      $params = params;\n    } else {\n      $params = projectRefOrParams;\n      $projectRef = taskContext.ctx.project.ref;\n      $slug = taskContext.ctx.environment.slug;\n    }\n  } else {\n    if (typeof projectRefOrParams !== \"string\") {\n      throw new Error(\"projectRef is required\");\n    }\n\n    if (!slugOrRequestOptions || typeof slugOrRequestOptions !== \"string\") {\n      throw new Error(\"slug is required\");\n    }\n\n    if (!params) {\n      throw new Error(\"params is required\");\n    }\n\n    $projectRef = projectRefOrParams;\n    $slug = slugOrRequestOptions;\n    $params = params;\n  }\n\n  const apiClient = apiClientManager.client;\n\n  if (!apiClient) {\n    throw apiClientMissingError();\n  }\n\n  return apiClient.importEnvVars($projectRef, $slug, $params, $requestOptions);\n}\n\nexport function list(\n  projectRef: string,\n  slug: string,\n  requestOptions?: ApiRequestOptions\n): ApiPromise<EnvironmentVariables>;\nexport function list(requestOptions?: ApiRequestOptions): ApiPromise<EnvironmentVariables>;\nexport function list(\n  projectRefOrRequestOptions?: string | ApiRequestOptions,\n  slug?: string,\n  requestOptions?: ApiRequestOptions\n): ApiPromise<EnvironmentVariables> {\n  const $projectRef = !isRequestOptions(projectRefOrRequestOptions)\n    ? projectRefOrRequestOptions\n    : taskContext.ctx?.project.ref;\n  const $slug = slug ?? taskContext.ctx?.environment.slug;\n  let $requestOptions = isRequestOptions(projectRefOrRequestOptions)\n    ? projectRefOrRequestOptions\n    : requestOptions;\n\n  if (!$projectRef) {\n    throw new Error(\"projectRef is required\");\n  }\n\n  if (!$slug) {\n    throw new Error(\"slug is required\");\n  }\n\n  $requestOptions = mergeRequestOptions(\n    {\n      tracer,\n      name: \"envvars.list()\",\n      icon: \"id-badge\",\n    },\n    $requestOptions\n  );\n\n  const apiClient = apiClientManager.client;\n\n  if (!apiClient) {\n    throw apiClientMissingError();\n  }\n\n  return apiClient.listEnvVars($projectRef, $slug, $requestOptions);\n}\n\nexport function create(\n  projectRef: string,\n  slug: string,\n  params: CreateEnvironmentVariableParams,\n  requestOptions?: ApiRequestOptions\n): ApiPromise<EnvironmentVariableResponseBody>;\nexport function create(\n  params: CreateEnvironmentVariableParams,\n  requestOptions?: ApiRequestOptions\n): ApiPromise<EnvironmentVariableResponseBody>;\nexport function create(\n  projectRefOrParams: string | CreateEnvironmentVariableParams,\n  slugOrRequestOptions?: string | ApiRequestOptions,\n  params?: CreateEnvironmentVariableParams,\n  requestOptions?: ApiRequestOptions\n): ApiPromise<EnvironmentVariableResponseBody> {\n  let $projectRef: string;\n  let $slug: string;\n  let $params: CreateEnvironmentVariableParams;\n  const $requestOptions = overloadRequestOptions(\"create\", slugOrRequestOptions, requestOptions);\n\n  if (taskContext.ctx) {\n    if (typeof projectRefOrParams === \"string\") {\n      $projectRef = projectRefOrParams;\n      $slug =\n        typeof slugOrRequestOptions === \"string\"\n          ? slugOrRequestOptions\n          : taskContext.ctx.environment.slug;\n\n      if (!params) {\n        throw new Error(\"params is required\");\n      }\n\n      $params = params;\n    } else {\n      $params = projectRefOrParams;\n      $projectRef = taskContext.ctx.project.ref;\n      $slug = taskContext.ctx.environment.slug;\n    }\n  } else {\n    if (typeof projectRefOrParams !== \"string\") {\n      throw new Error(\"projectRef is required\");\n    }\n\n    if (!slugOrRequestOptions || typeof slugOrRequestOptions !== \"string\") {\n      throw new Error(\"slug is required\");\n    }\n\n    if (!params) {\n      throw new Error(\"params is required\");\n    }\n\n    $projectRef = projectRefOrParams;\n    $slug = slugOrRequestOptions;\n    $params = params;\n  }\n\n  const apiClient = apiClientManager.client;\n\n  if (!apiClient) {\n    throw apiClientMissingError();\n  }\n\n  return apiClient.createEnvVar($projectRef, $slug, $params, $requestOptions);\n}\n\nexport function retrieve(\n  projectRef: string,\n  slug: string,\n  name: string,\n  requestOptions?: ApiRequestOptions\n): ApiPromise<EnvironmentVariableValue>;\nexport function retrieve(\n  name: string,\n  requestOptions?: ApiRequestOptions\n): ApiPromise<EnvironmentVariableValue>;\nexport function retrieve(\n  projectRefOrName: string,\n  slugOrRequestOptions?: string | ApiRequestOptions,\n  name?: string,\n  requestOptions?: ApiRequestOptions\n): ApiPromise<EnvironmentVariableValue> {\n  let $projectRef: string;\n  let $slug: string;\n  let $name: string;\n  const $requestOptions = overloadRequestOptions(\"retrieve\", slugOrRequestOptions, requestOptions);\n\n  if (typeof name === \"string\") {\n    $projectRef = projectRefOrName;\n    $slug =\n      typeof slugOrRequestOptions === \"string\"\n        ? slugOrRequestOptions\n        : taskContext.ctx?.environment.slug!;\n    $name = name;\n  } else {\n    $projectRef = taskContext.ctx?.project.ref!;\n    $slug = taskContext.ctx?.environment.slug!;\n    $name = projectRefOrName;\n  }\n\n  if (!$projectRef) {\n    throw new Error(\"projectRef is required\");\n  }\n\n  if (!$slug) {\n    throw new Error(\"slug is required\");\n  }\n\n  const apiClient = apiClientManager.client;\n\n  if (!apiClient) {\n    throw apiClientMissingError();\n  }\n\n  return apiClient.retrieveEnvVar($projectRef, $slug, $name, $requestOptions);\n}\n\nexport function del(\n  projectRef: string,\n  slug: string,\n  name: string,\n  requestOptions?: ApiRequestOptions\n): ApiPromise<EnvironmentVariableResponseBody>;\nexport function del(\n  name: string,\n  requestOptions?: ApiRequestOptions\n): ApiPromise<EnvironmentVariableResponseBody>;\nexport function del(\n  projectRefOrName: string,\n  slugOrRequestOptions?: string | ApiRequestOptions,\n  name?: string,\n  requestOptions?: ApiRequestOptions\n): ApiPromise<EnvironmentVariableResponseBody> {\n  let $projectRef: string;\n  let $slug: string;\n  let $name: string;\n  const $requestOptions = overloadRequestOptions(\"del\", slugOrRequestOptions, requestOptions);\n\n  if (typeof name === \"string\") {\n    $projectRef = projectRefOrName;\n    $slug =\n      typeof slugOrRequestOptions === \"string\"\n        ? slugOrRequestOptions\n        : taskContext.ctx?.environment.slug!;\n    $name = name;\n  } else {\n    $projectRef = taskContext.ctx?.project.ref!;\n    $slug = taskContext.ctx?.environment.slug!;\n    $name = projectRefOrName;\n  }\n\n  if (!$projectRef) {\n    throw new Error(\"projectRef is required\");\n  }\n\n  if (!$slug) {\n    throw new Error(\"slug is required\");\n  }\n\n  const apiClient = apiClientManager.client;\n\n  if (!apiClient) {\n    throw apiClientMissingError();\n  }\n\n  return apiClient.deleteEnvVar($projectRef, $slug, $name, $requestOptions);\n}\n\nexport function update(\n  projectRef: string,\n  slug: string,\n  name: string,\n  params: UpdateEnvironmentVariableParams,\n  requestOptions?: ApiRequestOptions\n): ApiPromise<EnvironmentVariableResponseBody>;\nexport function update(\n  name: string,\n  params: UpdateEnvironmentVariableParams,\n  requestOptions?: ApiRequestOptions\n): ApiPromise<EnvironmentVariableResponseBody>;\nexport function update(\n  projectRefOrName: string,\n  slugOrParams: string | UpdateEnvironmentVariableParams,\n  nameOrRequestOptions?: string | ApiRequestOptions,\n  params?: UpdateEnvironmentVariableParams,\n  requestOptions?: ApiRequestOptions\n): ApiPromise<EnvironmentVariableResponseBody> {\n  let $projectRef: string;\n  let $slug: string;\n  let $name: string;\n  let $params: UpdateEnvironmentVariableParams;\n  const $requestOptions = overloadRequestOptions(\"update\", nameOrRequestOptions, requestOptions);\n\n  if (taskContext.ctx) {\n    if (typeof slugOrParams === \"string\") {\n      $projectRef = slugOrParams;\n      $slug = slugOrParams ?? taskContext.ctx.environment.slug;\n      $name =\n        typeof nameOrRequestOptions === \"string\"\n          ? nameOrRequestOptions\n          : taskContext.ctx.environment.slug;\n\n      if (!params) {\n        throw new Error(\"params is required\");\n      }\n\n      $params = params;\n    } else {\n      $params = slugOrParams;\n      $projectRef = taskContext.ctx.project.ref;\n      $slug = taskContext.ctx.environment.slug;\n      $name = projectRefOrName;\n    }\n  } else {\n    if (typeof slugOrParams !== \"string\") {\n      throw new Error(\"slug is required\");\n    }\n\n    if (!projectRefOrName) {\n      throw new Error(\"projectRef is required\");\n    }\n\n    if (!params) {\n      throw new Error(\"params is required\");\n    }\n\n    $projectRef = projectRefOrName;\n    $slug = slugOrParams;\n    $name = name!;\n    $params = params;\n  }\n\n  const apiClient = apiClientManager.client;\n\n  if (!apiClient) {\n    throw apiClientMissingError();\n  }\n\n  return apiClient.updateEnvVar($projectRef, $slug, $name, $params, $requestOptions);\n}\n\nfunction overloadRequestOptions(\n  name: string,\n  slugOrRequestOptions?: string | ApiRequestOptions,\n  requestOptions?: ApiRequestOptions\n): ApiRequestOptions {\n  if (isRequestOptions(slugOrRequestOptions)) {\n    return mergeRequestOptions(\n      {\n        tracer,\n        name: `envvars.${name}()`,\n        icon: \"id-badge\",\n      },\n      slugOrRequestOptions\n    );\n  } else {\n    return mergeRequestOptions(\n      {\n        tracer,\n        name: `envvars.${name}()`,\n        icon: \"id-badge\",\n      },\n      requestOptions\n    );\n  }\n}\n", "var __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));\nvar __async = (__this, __arguments, generator) => {\n  return new Promise((resolve, reject) => {\n    var fulfilled = (value) => {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    };\n    var rejected = (value) => {\n      try {\n        step(generator.throw(value));\n      } catch (e) {\n        reject(e);\n      }\n    };\n    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);\n    step((generator = generator.apply(__this, __arguments)).next());\n  });\n};\n\n// package.json\nvar version = \"4.0.0\";\n\n// src/api-keys/api-keys.ts\nvar ApiKeys = class {\n  constructor(resend) {\n    this.resend = resend;\n  }\n  create(_0) {\n    return __async(this, arguments, function* (payload, options = {}) {\n      const data = yield this.resend.post(\n        \"/api-keys\",\n        payload,\n        options\n      );\n      return data;\n    });\n  }\n  list() {\n    return __async(this, null, function* () {\n      const data = yield this.resend.get(\"/api-keys\");\n      return data;\n    });\n  }\n  remove(id) {\n    return __async(this, null, function* () {\n      const data = yield this.resend.delete(\n        `/api-keys/${id}`\n      );\n      return data;\n    });\n  }\n};\n\n// src/audiences/audiences.ts\nvar Audiences = class {\n  constructor(resend) {\n    this.resend = resend;\n  }\n  create(_0) {\n    return __async(this, arguments, function* (payload, options = {}) {\n      const data = yield this.resend.post(\n        \"/audiences\",\n        payload,\n        options\n      );\n      return data;\n    });\n  }\n  list() {\n    return __async(this, null, function* () {\n      const data = yield this.resend.get(\"/audiences\");\n      return data;\n    });\n  }\n  get(id) {\n    return __async(this, null, function* () {\n      const data = yield this.resend.get(\n        `/audiences/${id}`\n      );\n      return data;\n    });\n  }\n  remove(id) {\n    return __async(this, null, function* () {\n      const data = yield this.resend.delete(\n        `/audiences/${id}`\n      );\n      return data;\n    });\n  }\n};\n\n// src/batch/batch.ts\nimport { renderAsync } from \"@react-email/render\";\nvar Batch = class {\n  constructor(resend) {\n    this.resend = resend;\n  }\n  send(_0) {\n    return __async(this, arguments, function* (payload, options = {}) {\n      return this.create(payload, options);\n    });\n  }\n  create(_0) {\n    return __async(this, arguments, function* (payload, options = {}) {\n      for (const email of payload) {\n        if (email.react) {\n          email.html = yield renderAsync(email.react);\n          delete email.react;\n        }\n      }\n      const data = yield this.resend.post(\n        \"/emails/batch\",\n        payload,\n        options\n      );\n      return data;\n    });\n  }\n};\n\n// src/contacts/contacts.ts\nvar Contacts = class {\n  constructor(resend) {\n    this.resend = resend;\n  }\n  create(_0) {\n    return __async(this, arguments, function* (payload, options = {}) {\n      const data = yield this.resend.post(\n        `/audiences/${payload.audienceId}/contacts`,\n        {\n          unsubscribed: payload.unsubscribed,\n          email: payload.email,\n          first_name: payload.firstName,\n          last_name: payload.lastName\n        },\n        options\n      );\n      return data;\n    });\n  }\n  list(options) {\n    return __async(this, null, function* () {\n      const data = yield this.resend.get(\n        `/audiences/${options.audienceId}/contacts`\n      );\n      return data;\n    });\n  }\n  get(options) {\n    return __async(this, null, function* () {\n      const data = yield this.resend.get(\n        `/audiences/${options.audienceId}/contacts/${options.id}`\n      );\n      return data;\n    });\n  }\n  update(payload) {\n    return __async(this, null, function* () {\n      const data = yield this.resend.patch(\n        `/audiences/${payload.audienceId}/contacts/${payload.id}`,\n        {\n          unsubscribed: payload.unsubscribed,\n          first_name: payload.firstName,\n          last_name: payload.lastName\n        }\n      );\n      return data;\n    });\n  }\n  remove(payload) {\n    return __async(this, null, function* () {\n      const data = yield this.resend.delete(\n        `/audiences/${payload.audienceId}/contacts/${(payload == null ? void 0 : payload.email) ? payload == null ? void 0 : payload.email : payload == null ? void 0 : payload.id}`\n      );\n      return data;\n    });\n  }\n};\n\n// src/domains/domains.ts\nvar Domains = class {\n  constructor(resend) {\n    this.resend = resend;\n  }\n  create(_0) {\n    return __async(this, arguments, function* (payload, options = {}) {\n      const data = yield this.resend.post(\n        \"/domains\",\n        payload,\n        options\n      );\n      return data;\n    });\n  }\n  list() {\n    return __async(this, null, function* () {\n      const data = yield this.resend.get(\"/domains\");\n      return data;\n    });\n  }\n  get(id) {\n    return __async(this, null, function* () {\n      const data = yield this.resend.get(\n        `/domains/${id}`\n      );\n      return data;\n    });\n  }\n  update(payload) {\n    return __async(this, null, function* () {\n      const data = yield this.resend.patch(\n        `/domains/${payload.id}`,\n        {\n          click_tracking: payload.clickTracking,\n          open_tracking: payload.openTracking,\n          tls: payload.tls\n        }\n      );\n      return data;\n    });\n  }\n  remove(id) {\n    return __async(this, null, function* () {\n      const data = yield this.resend.delete(\n        `/domains/${id}`\n      );\n      return data;\n    });\n  }\n  verify(id) {\n    return __async(this, null, function* () {\n      const data = yield this.resend.post(\n        `/domains/${id}/verify`\n      );\n      return data;\n    });\n  }\n};\n\n// src/emails/emails.ts\nimport { renderAsync as renderAsync2 } from \"@react-email/render\";\nvar Emails = class {\n  constructor(resend) {\n    this.resend = resend;\n  }\n  send(_0) {\n    return __async(this, arguments, function* (payload, options = {}) {\n      return this.create(payload, options);\n    });\n  }\n  create(_0) {\n    return __async(this, arguments, function* (payload, options = {}) {\n      if (payload.react) {\n        payload.html = yield renderAsync2(payload.react);\n        delete payload.react;\n      }\n      const data = yield this.resend.post(\n        \"/emails\",\n        {\n          attachments: payload.attachments,\n          bcc: payload.bcc,\n          cc: payload.cc,\n          from: payload.from,\n          headers: payload.headers,\n          html: payload.html,\n          reply_to: payload.replyTo,\n          scheduled_at: payload.scheduledAt,\n          subject: payload.subject,\n          tags: payload.tags,\n          text: payload.text,\n          to: payload.to\n        },\n        options\n      );\n      return data;\n    });\n  }\n  get(id) {\n    return __async(this, null, function* () {\n      const data = yield this.resend.get(\n        `/emails/${id}`\n      );\n      return data;\n    });\n  }\n  update(payload) {\n    return __async(this, null, function* () {\n      const data = yield this.resend.patch(\n        `/emails/${payload.id}`,\n        {\n          scheduled_at: payload.scheduledAt\n        }\n      );\n      return data;\n    });\n  }\n  cancel(id) {\n    return __async(this, null, function* () {\n      const data = yield this.resend.post(\n        `/emails/${id}/cancel`\n      );\n      return data;\n    });\n  }\n};\n\n// src/resend.ts\nvar defaultBaseUrl = \"https://api.resend.com\";\nvar defaultUserAgent = `resend-node:${version}`;\nvar baseUrl = typeof process !== \"undefined\" && process.env ? process.env.RESEND_BASE_URL || defaultBaseUrl : defaultBaseUrl;\nvar userAgent = typeof process !== \"undefined\" && process.env ? process.env.RESEND_USER_AGENT || defaultUserAgent : defaultUserAgent;\nvar Resend = class {\n  constructor(key) {\n    this.key = key;\n    this.apiKeys = new ApiKeys(this);\n    this.audiences = new Audiences(this);\n    this.batch = new Batch(this);\n    this.contacts = new Contacts(this);\n    this.domains = new Domains(this);\n    this.emails = new Emails(this);\n    if (!key) {\n      if (typeof process !== \"undefined\" && process.env) {\n        this.key = process.env.RESEND_API_KEY;\n      }\n      if (!this.key) {\n        throw new Error(\n          'Missing API key. Pass it to the constructor `new Resend(\"re_123\")`'\n        );\n      }\n    }\n    this.headers = new Headers({\n      Authorization: `Bearer ${this.key}`,\n      \"User-Agent\": userAgent,\n      \"Content-Type\": \"application/json\"\n    });\n  }\n  fetchRequest(_0) {\n    return __async(this, arguments, function* (path, options = {}) {\n      try {\n        const response = yield fetch(`${baseUrl}${path}`, options);\n        if (!response.ok) {\n          try {\n            const rawError = yield response.text();\n            return { data: null, error: JSON.parse(rawError) };\n          } catch (err) {\n            if (err instanceof SyntaxError) {\n              return {\n                data: null,\n                error: {\n                  name: \"application_error\",\n                  message: \"Internal server error. We are unable to process your request right now, please try again later.\"\n                }\n              };\n            }\n            const error = {\n              message: response.statusText,\n              name: \"application_error\"\n            };\n            if (err instanceof Error) {\n              return { data: null, error: __spreadProps(__spreadValues({}, error), { message: err.message }) };\n            }\n            return { data: null, error };\n          }\n        }\n        const data = yield response.json();\n        return { data, error: null };\n      } catch (error) {\n        return {\n          data: null,\n          error: {\n            name: \"application_error\",\n            message: \"Unable to fetch data. The request could not be resolved.\"\n          }\n        };\n      }\n    });\n  }\n  post(_0, _1) {\n    return __async(this, arguments, function* (path, entity, options = {}) {\n      const requestOptions = __spreadValues({\n        method: \"POST\",\n        headers: this.headers,\n        body: JSON.stringify(entity)\n      }, options);\n      return this.fetchRequest(path, requestOptions);\n    });\n  }\n  get(_0) {\n    return __async(this, arguments, function* (path, options = {}) {\n      const requestOptions = __spreadValues({\n        method: \"GET\",\n        headers: this.headers\n      }, options);\n      return this.fetchRequest(path, requestOptions);\n    });\n  }\n  put(_0, _1) {\n    return __async(this, arguments, function* (path, entity, options = {}) {\n      const requestOptions = __spreadValues({\n        method: \"PUT\",\n        headers: this.headers,\n        body: JSON.stringify(entity)\n      }, options);\n      return this.fetchRequest(path, requestOptions);\n    });\n  }\n  patch(_0, _1) {\n    return __async(this, arguments, function* (path, entity, options = {}) {\n      const requestOptions = __spreadValues({\n        method: \"PATCH\",\n        headers: this.headers,\n        body: JSON.stringify(entity)\n      }, options);\n      return this.fetchRequest(path, requestOptions);\n    });\n  }\n  delete(path, query) {\n    return __async(this, null, function* () {\n      const requestOptions = {\n        method: \"DELETE\",\n        headers: this.headers,\n        body: JSON.stringify(query)\n      };\n      return this.fetchRequest(path, requestOptions);\n    });\n  }\n};\nexport {\n  Resend\n};\n", "import { render } from \"@react-email/components\";\nimport { createClient } from \"@supabase/supabase-js\";\nimport { envvars, logger, task } from \"@trigger.dev/sdk/v3\";\nimport { UnconfirmedDeletionEmail } from \"@v1/email/unconfirmed-deletion-email\";\nimport React from \"react\";\nimport { Resend } from \"resend\";\n\nexport const deleteUnconfirmedEmails = task({\n  id: \"delete-unconfirmed-emails\",\n  run: async (payload: { id: string }, { ctx }) => {\n    const userId = payload.id;\n    const SUPABASE_URL = await envvars.retrieve(\"SUPABASE_URL\");\n    const SUPABASE_SERVICE_KEY = await envvars.retrieve(\"SUPABASE_SERVICE_KEY\");\n    const RESEND_API_KEY = await envvars.retrieve(\"RESEND_API_KEY\");\n    const resend = new Resend(RESEND_API_KEY.value);\n    const supabase = createClient(\n      SUPABASE_URL.value,\n      SUPABASE_SERVICE_KEY.value,\n    );\n\n    const { data: authUser, error: authUserError } =\n      await supabase.auth.admin.getUserById(userId);\n\n    if (authUserError) {\n      logger.error(\"Error getting user\", { authUserError });\n      throw authUserError;\n    }\n\n    if (authUser.user.email_confirmed_at) {\n      logger.info(\"User already confirmed\", { userId });\n      return;\n    }\n\n    const { data, error } = await supabase.auth.admin.deleteUser(userId);\n    if (error) {\n      logger.error(\"Error deleting user\", { error });\n      throw error;\n    }\n\n    const email = data.user.email;\n\n    if (email) {\n      const emailHtml = await render(\n        React.createElement(UnconfirmedDeletionEmail),\n      );\n      try {\n        await resend.emails.send({\n          from: \"noreply@hrtoolkit.app\",\n          to: email,\n          subject: \"Account Deletion Confirmation\",\n          html: emailHtml,\n        });\n        logger.info(\"Deletion confirmation email sent\", { email });\n      } catch (emailError) {\n        logger.error(\"Error sending deletion confirmation email\", {\n          emailError,\n        });\n      }\n    }\n\n    logger.info(\"User deleted successfully\", { userId });\n  },\n});\n", "// src/index.ts\nexport * from \"@react-email/body\";\nexport * from \"@react-email/button\";\nexport * from \"@react-email/code-block\";\nexport * from \"@react-email/code-inline\";\nexport * from \"@react-email/column\";\nexport * from \"@react-email/container\";\nexport * from \"@react-email/font\";\nexport * from \"@react-email/head\";\nexport * from \"@react-email/heading\";\nexport * from \"@react-email/hr\";\nexport * from \"@react-email/html\";\nexport * from \"@react-email/img\";\nexport * from \"@react-email/link\";\nexport * from \"@react-email/markdown\";\nexport * from \"@react-email/preview\";\nexport * from \"@react-email/render\";\nexport * from \"@react-email/row\";\nexport * from \"@react-email/section\";\nexport * from \"@react-email/tailwind\";\nexport * from \"@react-email/text\";\n", "import { logger, task, wait } from \"@trigger.dev/sdk/v3\";\n\nexport const helloWorldTask = task({\n  id: \"hello-world\",\n  run: async (payload: unknown, { ctx }) => {\n    logger.log(\"Hello, world!\", { payload, ctx });\n\n    await wait.for({ seconds: 5 });\n\n    return {\n      message: \"Hello, world!\",\n    };\n  },\n});\n"],
  "mappings": "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",
  "names": ["context", "propagation", "version", "CreateAuthorizationCodeResponseSchema", "url", "string", "authorizationCode", "GetPersonalAccessTokenRequestSchema", "GetPersonalAccessTokenResponseSchema", "token", "obfuscatedToken", "z", "literal", "MachineMemory", "MachineConfig", "cpu", "MachineCpu", "optional", "memory", "preset", "MachinePresetName", "MachinePreset", "object", "name", "number", "centsPerMs", "TaskRunBuiltInError", "type", "stackTrace", "TaskRunCustomErrorObject", "raw", "TaskRunStringError", "COULD_NOT_FIND_EXECUTOR", "COULD_NOT_FIND_TASK", "CONFIGURED_INCORRECTLY", "TASK_ALREADY_RUNNING", "TASK_EXECUTION_FAILED", "TASK_EXECUTION_ABORTED", "TASK_PROCESS_EXITED_WITH_NON_ZERO_CODE", "TASK_RUN_CANCELLED", "TASK_OUTPUT_ERROR", "HANDLE_ERROR_ERROR", "GRACEFUL_EXIT_TIMEOUT", "TASK_RUN_CRASHED", "TaskRunInternalError", "code", "message", "TaskRunError", "discriminatedUnion", "TaskRun", "id", "payload", "payloadType", "any", "tags", "array", "isTest", "boolean", "default", "createdAt", "coerce", "date", "startedAt", "maxAttempts", "durationMs", "costInCents", "baseCostInCents", "TaskRunExecutionTask", "filePath", "exportName", "TaskRunExecutionAttempt", "backgroundWorkerId", "backgroundWorkerTaskId", "status", "TaskRunExecutionEnvironment", "slug", "TaskRunExecutionOrganization", "TaskRunExecutionProject", "ref", "TaskRunExecutionBatch", "TaskRunExecution", "task", "attempt", "run", "environment", "organization", "project", "batch", "machine", "TaskRunContext", "omit", "TaskRunExecutionRetry", "delay", "error", "unknown", "TaskRunExecutionUsage", "TaskRunFailedExecutionResult", "retry", "skippedRetrying", "usage", "ok", "output", "TaskRunExecutionResult", "BatchTaskRunExecutionResult", "items", "EnvironmentType", "TaskRunExecutionPayload", "execution", "traceContext", "record", "ProdTaskRunExecution", "worker", "contentHash", "ProdTaskRunExecutionPayload", "FixedWindowRateLimit", "limit", "window", "seconds", "hours", "SlidingWindowRateLimit", "RateLimitOptions", "concurrencyLimit", "rateLimit", "ScheduleMetadata", "cron", "timezone", "TaskMetadata", "queue", "RetryOptions", "schedule", "TaskFileMetadata", "TaskMetadataWithFilePath", "packageVersion", "QueueOptions", "triggerSource", "PreStopCauses", "test", "Config", "triggerDirectories", "triggerUrl", "projectDir", "tsconfigPath", "retries", "enabledInDev", "additionalPackages", "additionalFiles", "dependenciesToBundle", "union", "logLevel", "enableConsoleLogging", "postInstall", "WaitReason", "enum", "TaskRunExecutionLazyAttemptPayload", "TaskResource", "BackgroundWorkerMetadata", "tasks", "ImageDetailsMetadata", "imageTag", "AbortTaskRunError", "constructor", "Error", "parseError", "stringify", "createErrorTaskError", "String", "e", "stack", "JSON", "SerializedError", "createJsonErrorObject", "replace", "__name", "sanitizeError", "correctErrorStackTrace", "correctStackTraceLine", "isDev", "LINES_TO_IGNORE", "regex", "line", "trim", "groupTaskMetadataIssuesByTask", "issues", "issue", "taskIndex", "acc", "restOfPath", "taskName", "key", "taskId", "existing", "WhoAmIResponseSchema", "userId", "email", "dashboardUrl", "GetProjectResponseBody", "externalRef", "title", "GetProjectsResponseBody", "apiKey", "apiUrl", "localOnly", "metadata", "supportsLazyAttempts", "RunTag", "max", "RunTags", "TriggerTaskRequestBody", "options", "dependentAttempt", "dependentBatch", "lockToVersion", "idempotencyKey", "nonnegative", "TriggerTaskResponse", "BatchTriggerTaskRequestBody", "BatchTriggerTaskResponse", "batchId", "runs", "GetBatchResponseBody", "taskRunId", "AddTagsRequestBody", "GetEnvironmentVariablesResponseBody", "StartDeploymentIndexingRequestBody", "imageReference", "selfHosted", "StartDeploymentIndexingResponseBody", "ExternalBuildData", "buildId", "buildToken", "projectId", "InitializeDeploymentResponseBody", "externalBuildData", "registryHost", "DeploymentErrorData", "stderr", "GetDeploymentResponseBody", "shortCode", "errorData", "CreateUploadPayloadUrlResponseBody", "presignedUrl", "UpdateScheduleOptions", "deduplicationKey", "ScheduleGenerator", "expression", "description", "ScheduleObject", "ScheduleType", "active", "generator", "environments", "userName", "nullish", "ListSchedulesResult", "data", "currentPage", "totalPages", "perPage", "AttemptStatus", "RunEnvironmentDetails", "user", "RunScheduleDetails", "externalId", "CommonRunFields", "RunStatus", "taskIdentifier", "isQueued", "isExecuting", "isCompleted", "isSuccess", "isFailed", "isCancelled", "updatedAt", "finishedAt", "delayedUntil", "ttl", "expiredAt", "RetrieveRunResponse", "payloadPresignedUrl", "outputPresignedUrl", "completedAt", "env", "ListRunResponse", "pagination", "next", "CreateEnvironmentVariableRequestBody", "value", "variables", "override", "success", "EnvironmentVariableValue", "EnvironmentVariables", "BackgroundWorkerServerMessages", "payloads", "taskAttemptId", "image", "envType", "orgId", "serverWebsocketMessages", "SERVER_READY", "BACKGROUND_WORKER_MESSAGE", "BackgroundWorkerClientMessages", "BackgroundWorkerProperties", "clientWebsocketMessages", "READY_FOR_TASKS", "inProgressRuns", "BACKGROUND_WORKER_DEPRECATED", "workerToChildMessages", "EXECUTE_TASK_RUN", "TASK_RUN_COMPLETED_NOTIFICATION", "completion", "CLEANUP", "flush", "kill", "UncaughtExceptionMessage", "origin", "zodIssues", "childToWorkerMessages", "TASK_RUN_COMPLETED", "result", "TASKS_READY", "TASKS_FAILED_TO_PARSE", "TASK_HEARTBEAT", "TASK_RUN_HEARTBEAT", "READY_TO_DISPOSE", "undefined", "WAIT_FOR_DURATION", "WAIT_FOR_TASK", "WAIT_FOR_BATCH", "UNCAUGHT_EXCEPTION", "ProdChildToWorkerMessages", "TaskMetadataFailedToParseData", "now", "waitThresholdInMs", "batchFriendlyId", "runFriendlyIds", "ProdWorkerToChildMessages", "callback", "void", "WAIT_COMPLETED_NOTIFICATION", "ProviderToPlatformMessages", "LOG", "LOG_WITH_ACK", "WORKER_CRASHED", "runId", "reason", "exitCode", "logs", "overrideCompletion", "INDEXING_FAILED", "deploymentId", "PlatformToProviderMessages", "INDEX", "envId", "attemptNumber", "checkpointId", "PRE_PULL_DEPLOYMENT", "imageRef", "CreateWorkerMessage", "projectRef", "cliPackageVersion", "CoordinatorToPlatformMessages", "CREATE_WORKER", "CREATE_TASK_RUN_ATTEMPT", "executionPayload", "READY_FOR_EXECUTION", "READY_FOR_LAZY_ATTEMPT", "lazyPayload", "READY_FOR_RESUME", "attemptFriendlyId", "docker", "location", "TASK_RUN_FAILED_TO_RUN", "CHECKPOINT_CREATED", "ms", "keepRunAlive", "RUN_CRASHED", "PlatformToCoordinatorMessages", "RESUME_AFTER_DEPENDENCY", "completions", "executions", "RESUME_AFTER_DURATION", "attemptId", "REQUEST_ATTEMPT_CANCELLATION", "REQUEST_RUN_CANCELLATION", "delayInMs", "DYNAMIC_CONFIG", "checkpointThresholdInMs", "SharedQueueToClientMessages", "ProdWorkerToCoordinatorMessages", "INDEX_TASKS", "IndexTasksMessage", "totalCompletions", "READY_FOR_CHECKPOINT", "CANCEL_CHECKPOINT", "checkpointCanceled", "willCheckpointAndRestore", "shouldExit", "friendlyId", "UNRECOVERABLE_ERROR", "SET_STATE", "CoordinatorToProdWorkerMessages", "EXECUTE_TASK_RUN_LAZY_ATTEMPT", "REQUEST_EXIT", "READY_FOR_RETRY", "ProdWorkerSocketData", "podName", "deploymentVersion", "CoordinatorSocketData", "supportsDynamicConfig", "PRIMARY_VARIANT", "Variant", "AccessoryItem", "text", "variant", "Accessory", "style", "TaskEventStyle", "icon", "stringPatternMatchers", "$endsWith", "$startsWith", "$ignoreCaseEquals", "EventMatcher", "$anythingBut", "$gt", "$lt", "$gte", "tuple", "EventFilter", "FetchRetryHeadersStrategy", "strategy", "limitHeader", "remainingHeader", "resetHeader", "resetFormat", "FetchRetryStrategy", "FetchRetryBackoffStrategy", "FetchRetryByStatusOptions", "FetchTimeoutOptions", "durationInMs", "byStatus", "timeout", "connectionError", "ExceptionEventProperties", "stacktrace", "ExceptionSpanEvent", "time", "exception", "properties", "OtherSpanEvent", "SpanEvent", "isExceptionSpanEvent", "api", "isCancellationSpanEvent", "SpanMessagingEvent", "system", "operation", "destination", "_globalThis", "globalThis", "GLOBAL_TRIGGER_DOT_DEV_KEY", "Symbol", "registerGlobal", "_global", "allowOverride", "instance", "getGlobal", "unregisterGlobal", "SemanticInternalAttributes", "ENVIRONMENT_ID", "ENVIRONMENT_TYPE", "ORGANIZATION_ID", "ORGANIZATION_SLUG", "ORGANIZATION_NAME", "PROJECT_ID", "PROJECT_REF", "PROJECT_NAME", "PROJECT_DIR", "ATTEMPT_ID", "ATTEMPT_NUMBER", "RUN_ID", "RUN_IS_TEST", "BATCH_ID", "TASK_SLUG", "TASK_PATH", "TASK_EXPORT_NAME", "QUEUE_NAME", "QUEUE_ID", "MACHINE_PRESET_NAME", "MACHINE_PRESET_CPU", "MACHINE_PRESET_MEMORY", "MACHINE_PRESET_CENTS_PER_MS", "SPAN_PARTIAL", "SPAN_ID", "OUTPUT", "OUTPUT_TYPE", "STYLE_ACCESSORY", "METADATA", "TRIGGER", "_TaskContextAPI", "PAYLOAD", "PAYLOAD_TYPE", "SHOW", "SHOW_ACTIONS", "WORKER_ID", "WORKER_VERSION", "CLI_VERSION", "SDK_VERSION", "SDK_LANGUAGE", "RETRY_AT", "RETRY_DELAY", "RETRY_COUNT", "LINK_TITLE", "IDEMPOTENCY_KEY", "USAGE_DURATION_MS", "USAGE_COST_IN_CENTS", "RATE_LIMIT_LIMIT", "RATE_LIMIT_REMAINING", "RATE_LIMIT_RESET", "API_NAME", "TaskContextAPI", "getInstance", "isInsideTask", "ctx", "attributes", "contextAttributes", "workerAttributes", "disable", "setGlobalTaskContext", "taskContext", "resets", "format", "calculateISO8601DurationOpenAIVariantResetAt", "calculateISO8601ResetAt", "calculateUnixTimestampResetAt", "calculateResetAt", "isNaN", "Date", "resetAt", "calculateUnixTimestampInMsResetAt", "parseInt", "defaultRetryOptions", "defaultFetchRetryOptions", "match", "minutes", "milliseconds", "setSeconds", "getSeconds", "factor", "minTimeoutInMs", "maxTimeoutInMs", "calculateResetAt2", "_ApiError", "calculateNextRetryDelay", "opts", "random", "Math", "ApiError", "makeMessage", "msg", "ConflictError", "UnprocessableEntityError", "RateLimitError", "generate", "errorResponse", "headers", "ApiConnectionError", "BadRequestError", "__publicField", "NotFoundError", "AuthenticationError", "PermissionDeniedError", "cause", "millisecondsUntilReset", "resetAtUnixEpochMs", "resetAtUnixEpoch", "InternalServerError", "err", "castToError", "NULL_SENTINEL", "flattenAttributes", "obj", "prefix", "newPrefix", "Array", "length", "i", "Object", "isRecord", "assign", "unflattenAttributes", "rehydrateNull", "keys", "entries", "part", "nextPart", "parts", "current", "accessoryAttributes", "maxIndex", "arrayResult", "primitiveValueOrflattenedAttributes", "accessory", "CursorPage", "getPaginatedItems", "hasNextPage", "hasPreviousPage", "getNextPage", "pageFetcher", "getPreviousPage", "page", "asyncIterator", "iterPages", "OffsetLimitPage", "defaultRetryOptions2", "isRequestOptions", "zodfetch", "item", "randomize", "requestOptionsKeys", "schema", "requestInit", "ApiPromise", "zodfetchCursorPage", "query", "URLSearchParams", "params", "after", "before", "cursorPageSchema", "$url", "search", "CursorPagePromise", "fetchResult", "zodfetchOffsetLimitPage", "URL", "toString", "offsetLimitPageSchema", "OffsetLimitPagePromise", "method", "pathname", "span", "safeJsonParse", "traceZodFetch", "$requestInit", "_doZodFetch", "_doZodFetchWithRetries", "response", "responseHeaders", "retryResult", "waitForRetry", "errJSON", "errMessage", "parsedResult", "fromZodError", "shouldRetry", "shouldRetryForOptions", "retryOptions", "shouldRetryHeader", "fromEntries", "createResponseHeaders", "withCache", "requestInitWithCache", "resolve", "responsePromise", "asResponse", "withResponse", "parse", "onrejected", "finally", "Promise", "fetchPage_fn", "_fetchPage", "tracer", "startActiveSpan", "baseUrl", "setTimeout", "isEmptyObj", "mergeRequestOptions", "hasOwn", "hasOwnProperty", "DEFAULT_ZOD_FETCH_OPTIONS", "ApiClient", "requestOptions", "accessToken", "defaultRequestOptions", "getRunResult", "getBatchResults", "triggerTask", "encodedTaskId", "body", "batchTriggerTask", "createUploadPayloadUrl", "getPayloadUrl", "retrieveRun", "listRuns", "searchParams", "createSearchQueryForListRuns", "ListRunResponseItem", "listProjectRuns", "replayRun", "cancelRun", "CanceledRunResponse", "rescheduleRun", "addTags", "createSchedule", "listSchedules", "append", "retrieveSchedule", "scheduleId", "updateSchedule", "deactivateSchedule", "activateSchedule", "deleteSchedule", "DeletedScheduleObject", "listEnvVars", "importEnvVars", "EnvironmentVariableResponseBody", "retrieveEnvVar", "createEnvVar", "updateEnvVar", "deleteEnvVar", "Authorization", "spanParentAsLink", "from", "to", "defaultOptions", "_ClockAPI", "SimpleClock", "preciseNow", "nowStruct", "reset", "ClockAPI", "_instance", "setGlobalClock", "clock", "SIMPLE_CLOCK", "OTEL_LOG_ATTRIBUTE_COUNT_LIMIT", "OTEL_SPAN_ATTRIBUTE_VALUE_LENGTH_LIMIT", "OTEL_SPAN_EVENT_COUNT_LIMIT", "OTEL_LINK_COUNT_LIMIT", "OTEL_ATTRIBUTE_PER_EVENT_COUNT_LIMIT", "newAttributes", "imposeAttributeLimits", "_LoggerAPI", "calculateAttributeValueLength", "NoopTaskLogger", "debug", "log", "info", "warn", "trace", "LoggerAPI", "logger", "setGlobalTaskLogger", "NOOP_TASK_LOGGER", "NoopRuntimeManager", "waitForDuration", "waitUntil", "waitForTask", "_UsageAPI", "NoopUsageManager", "start", "cpuTime", "stop", "measurement", "pauseAsync", "sample", "NOOP_USAGE_MANAGER", "UsageAPI", "_RuntimeAPI", "setGlobalUsageManager", "manager", "NOOP_RUNTIME_MANAGER", "RuntimeAPI", "runtime", "getEnvVar", "_APIClientManagerAPI", "waitForBatch", "setGlobalRuntimeManager", "runtimeManager", "config", "process", "APIClientManagerAPI", "apiClientManager", "setGlobalAPIClientConfiguration", "store", "client", "_TaskCatalogAPI", "NoopTaskCatalog", "registerTaskMetadata", "registerTaskFileMetadata", "taskCatalog2", "updateTaskMetadata", "updates", "getAllTaskMetadata", "getTaskMetadata", "getTask", "taskExists", "TaskCatalogAPI", "taskCatalog", "dateDifference", "formatDuration", "end", "formatDurationMilliseconds", "nanosecondsToMilliseconds", "nanoseconds", "millisecondsToNanoseconds", "formatDurationNanoseconds", "belowOneSecondUnits", "duration", "maxDecimalPoints", "largest", "formatDurationInDays", "units", "TriggerTracer", "_config", "_logger", "extractContext", "fn", "parentContext", "startTime", "eventFilterMatches", "setAttributes", "startSpan", "patternKey", "patternValue", "includes", "payloadValue", "contentFiltersMatches", "objectArray", "contentFilter", "contentFilters", "contentFilterMatches", "actualValue", "parsePacket", "sensitivity", "$isNull", "stringifyIO", "detectDependencyVersion", "dataType", "conditionallyExportPacket", "needsOffloading", "pathPrefix", "conditionallyImportPacket", "packet", "byteSize", "lengthLimit", "size", "packetRequiresOffloading", "presignedResponse", "filename", "uploadResponse", "fetch", "exportPacket", "importPacket", "createPacketAttributes", "dataKey", "dataTypeKey", "safeJsonParse2", "safeReplacer", "createPacketAttributesAsJson", "deserialize", "prettyPrintPacket", "rawData", "exports", "RegExp", "v", "outputType", "getPacketExtension", "loadSuperJSON", "SpanKind", "z", "parseError", "error", "name", "stack", "type", "raw", "JSON", "SerializedError", "message", "stackTrace", "sanitizeError", "replace", "code", "DiagConsoleLogger", "logs", "OTLPLogExporter", "OTLPTraceExporter", "registerInstrumentations", "OTEL_LOG_ATTRIBUTE_COUNT_LIMIT", "OTEL_SPAN_ATTRIBUTE_VALUE_LENGTH_LIMIT", "OTEL_LOG_ATTRIBUTE_VALUE_LENGTH_LIMIT", "OTEL_SPAN_EVENT_COUNT_LIMIT", "OTEL_LINK_COUNT_LIMIT", "OTEL_ATTRIBUTE_PER_LINK_COUNT_LIMIT", "OTEL_ATTRIBUTE_PER_EVENT_COUNT_LIMIT", "OFFLOAD_IO_PACKET_LENGTH_LIMIT", "ENVIRONMENT_ID", "ENVIRONMENT_TYPE", "ORGANIZATION_ID", "ORGANIZATION_SLUG", "ORGANIZATION_NAME", "PROJECT_ID", "PROJECT_REF", "PROJECT_NAME", "PROJECT_DIR", "ATTEMPT_ID", "ATTEMPT_NUMBER", "RUN_ID", "RUN_IS_TEST", "BATCH_ID", "TASK_SLUG", "TASK_PATH", "TASK_EXPORT_NAME", "QUEUE_NAME", "QUEUE_ID", "MACHINE_PRESET_NAME", "MACHINE_PRESET_CPU", "MACHINE_PRESET_MEMORY", "MACHINE_PRESET_CENTS_PER_MS", "SPAN_PARTIAL", "SPAN_ID", "OUTPUT", "OUTPUT_TYPE", "STYLE", "STYLE_ICON", "STYLE_VARIANT", "STYLE_ACCESSORY", "METADATA", "TRIGGER", "PAYLOAD", "PAYLOAD_TYPE", "SHOW", "SHOW_ACTIONS", "WORKER_ID", "WORKER_VERSION", "CLI_VERSION", "SDK_VERSION", "SDK_LANGUAGE", "RETRY_AT", "RETRY_DELAY", "RETRY_COUNT", "LINK_TITLE", "IDEMPOTENCY_KEY", "USAGE_DURATION_MS", "USAGE_COST_IN_CENTS", "RATE_LIMIT_LIMIT", "RATE_LIMIT_REMAINING", "RATE_LIMIT_RESET", "flattenAttributes", "result", "obj", "undefined", "prefix", "newPrefix", "Array", "value", "i", "Object", "assign", "NULL_SENTINEL", "__name", "isRecord", "_global", "_globalThis", "registerGlobal", "api", "GLOBAL_TRIGGER_DOT_DEV_KEY", "allowOverride", "Error", "instance", "getGlobal", "unregisterGlobal", "API_NAME", "TaskContextAPI", "getInstance", "_instance", "isInsideTask", "ctx", "worker", "attributes", "contextAttributes", "workerAttributes", "SemanticInternalAttributes", "id", "version", "attempt", "number", "task", "filePath", "exportName", "queue", "environment", "organization", "project", "ref", "run", "isTest", "slug", "batch", "idempotencyKey", "machine", "cpu", "memory", "centsPerMs", "disable", "setGlobalTaskContext", "taskContext", "TaskContextSpanProcessor", "constructor", "innerProcessor", "_innerProcessor", "onStart", "span", "parentContext", "setAttributes", "onEnd", "shutdown", "forceFlush", "TaskContextLogProcessor", "onEmit", "logRecord", "context", "getEnvVar", "process", "env", "_a", "AsyncResourceDetector", "_resolved", "_promise", "Promise", "resolver", "_resolver", "detect", "_config", "Resource", "resolveWithAttributes", "TracingSDK", "config", "asyncResourceDetector", "setLogLevel", "diagLogLevel", "envResourceAttributesSerialized", "envResourceAttributes", "parse", "commonResources", "detectResourcesSync", "detectors", "processDetectorSync", "merge", "SemanticResourceAttributes", "resource", "traceProvider", "NodeTracerProvider", "forceFlushTimeoutMillis", "spanLimits", "attributeCountLimit", "OTEL_SPAN_ATTRIBUTE_COUNT_LIMIT", "attributeValueLengthLimit", "eventCountLimit", "attributePerEventCountLimit", "linkCountLimit", "attributePerLinkCountLimit", "spanExporter", "url", "timeoutMillis", "addSpanProcessor", "BatchSpanProcessor", "maxExportBatchSize", "parseInt", "scheduledDelayMillis", "exportTimeoutMillis", "maxQueueSize", "SimpleSpanProcessor", "register", "instrumentations", "tracerProvider", "logExporter", "loggerProvider", "LoggerProvider", "logRecordLimits", "addLogRecordProcessor", "BatchLogRecordProcessor", "SimpleLogRecordProcessor", "_logProvider", "_spanExporter", "_traceProvider", "setGlobalLoggerProvider", "getLogger", "bind", "getTracer", "flush", "all", "level", "DiagLogLevel", "NONE", "ERROR", "WARN", "INFO", "DEBUG", "VERBOSE", "ALL", "diag", "setLogger", "recordSpanException", "recordException", "sanitizeSpanError", "stringify", "setStatus", "SpanStatusCode", "sanitizedError", "MachineCpu", "literal", "MachinePresetName", "enum", "MachineConfig", "optional", "MachineMemory", "preset", "MachinePreset", "TaskRunBuiltInError", "string", "TaskRunCustomErrorObject", "object", "COULD_NOT_FIND_EXECUTOR", "CONFIGURED_INCORRECTLY", "TASK_ALREADY_RUNNING", "TASK_EXECUTION_FAILED", "TASK_EXECUTION_ABORTED", "TASK_PROCESS_EXITED_WITH_NON_ZERO_CODE", "TASK_PROCESS_SIGKILL_TIMEOUT", "TASK_RUN_CANCELLED", "TASK_OUTPUT_ERROR", "HANDLE_ERROR_ERROR", "GRACEFUL_EXIT_TIMEOUT", "TASK_RUN_CRASHED", "TaskRunInternalError", "TaskRunError", "discriminatedUnion", "TaskRunStringError", "payload", "tags", "array", "boolean", "default", "createdAt", "coerce", "date", "maxAttempts", "durationMs", "costInCents", "baseCostInCents", "TaskRunExecutionAttempt", "startedAt", "backgroundWorkerId", "status", "TaskRunExecutionEnvironment", "TaskRunExecutionOrganization", "TaskRunExecutionQueue", "TaskRunExecutionBatch", "TaskRunExecution", "TaskRunExecutionTask", "TaskRun", "TaskRunExecutionProject", "TaskRunContext", "omit", "payloadType", "TaskRunExecutionRetry", "timestamp", "delay", "TaskRunExecutionUsage", "TaskRunFailedExecutionResult", "ok", "retry", "skippedRetrying", "TaskRunSuccessfulExecutionResult", "usage", "BatchTaskRunExecutionResult", "items", "TaskRunExecutionResult", "EnvironmentType", "TaskRunExecutionPayload", "execution", "traceContext", "contentHash", "ProdTaskRunExecutionPayload", "ProdTaskRunExecution", "FixedWindowRateLimit", "window", "seconds", "minutes", "hours", "SlidingWindowRateLimit", "concurrencyLimit", "rateLimit", "RateLimitOptions", "cron", "timezone", "packageVersion", "QueueOptions", "RetryOptions", "triggerSource", "schedule", "ScheduleMetadata", "TaskFileMetadata", "PostStartCauses", "RegexSchema", "custom", "val", "test", "triggerDirectories", "triggerUrl", "projectDir", "tsconfigPath", "retries", "enabledInDev", "additionalPackages", "additionalFiles", "dependenciesToBundle", "logLevel", "enableConsoleLogging", "postInstall", "extraCACerts", "TaskRunExecutionLazyAttemptPayload", "runId", "attemptCount", "messageId", "record", "unknown", "TaskResource", "BackgroundWorkerMetadata", "cliPackageVersion", "ImageDetailsMetadata", "imageTag", "WhoAmIResponseSchema", "userId", "email", "dashboardUrl", "externalRef", "GetProjectsResponseBody", "GetProjectEnvResponse", "apiKey", "apiUrl", "localOnly", "supportsLazyAttempts", "CreateBackgroundWorkerResponse", "RunTag", "RunTags", "union", "TriggerTaskRequestBody", "any", "options", "dependentAttempt", "lockToVersion", "ttl", "nonnegative", "int", "TriggerTaskResponse", "BatchTriggerTaskRequestBody", "BatchTriggerTaskResponse", "batchId", "runs", "taskRunId", "RescheduleRunRequestBody", "GetEnvironmentVariablesResponseBody", "variables", "imageReference", "selfHosted", "StartDeploymentIndexingResponseBody", "ExternalBuildData", "buildToken", "projectId", "shortCode", "registryHost", "InitializeDeploymentRequestBody", "DeploymentErrorData", "stderr", "GetDeploymentResponseBody", "errorData", "nullable", "tasks", "presignedUrl", "lastTimestamp", "UpdateScheduleOptions", "deduplicationKey", "ScheduleGenerator", "expression", "description", "ScheduleObject", "active", "generator", "nextRun", "environments", "DeletedScheduleObject", "ListSchedulesResult", "data", "currentPage", "page", "timezones", "RunEnvironmentDetails", "user", "RunScheduleDetails", "externalId", "CommonRunFields", "RunStatus", "taskIdentifier", "isQueued", "isExecuting", "isCompleted", "isSuccess", "isFailed", "isCancelled", "updatedAt", "finishedAt", "delayedUntil", "expiredAt", "RetrieveRunResponse", "payloadPresignedUrl", "outputPresignedUrl", "attempts", "AttemptStatus", "completedAt", "ListRunResponseItem", "ListRunResponse", "pagination", "previous", "CreateEnvironmentVariableRequestBody", "ImportEnvironmentVariablesRequestBody", "override", "success", "EnvironmentVariableValue", "EnvironmentVariable", "EnvironmentVariables", "propagation", "fromZodError", "defaultRetryOptions", "minTimeoutInMs", "_ApiError", "maxTimeoutInMs", "randomize", "defaultFetchRetryOptions", "byStatus", "strategy", "connectionError", "timeout", "calculateNextRetryDelay", "opts", "random", "Math", "round", "ApiError", "headers", "makeMessage", "BadRequestError", "param", "msg", "InternalServerError", "errorResponse", "__publicField", "AuthenticationError", "PermissionDeniedError", "UnprocessableEntityError", "RateLimitError", "cause", "NotFoundError", "ConflictError", "resetAtUnixEpochMs", "resetAtUnixEpoch", "castToError", "err", "accessoryAttributes", "accessory", "getPaginatedItems", "hasNextPage", "next", "hasPreviousPage", "getNextPage", "pageFetcher", "getPreviousPage", "iterPages", "Symbol", "asyncIterator", "item", "CursorPage", "defaultRetryOptions2", "zodfetch", "OffsetLimitPage", "factor", "schema", "ApiPromise", "_doZodFetch", "zodfetchCursorPage", "params", "query", "set", "String", "after", "cursorPageSchema", "$url", "URL", "fetchResult", "CursorPagePromise", "zodfetchOffsetLimitPage", "limit", "offsetLimitPageSchema", "search", "callback", "method", "requestInit", "startActiveSpan", "safeJsonParse", "traceZodFetch", "$requestInit", "_doZodFetchWithRetries", "response", "retryResult", "waitForRetry", "errText", "parsedResult", "ApiConnectionError", "shouldRetry", "shouldRetryForOptions", "shouldRetryHeader", "text", "createResponseHeaders", "Request", "withCache", "requestInitWithCache", "resolve", "asResponse", "withResponse", "catch", "onrejected", "finally", "onfinally", "_fetchPage", "fetchPage_fn", "OffsetLimitPagePromise", "tracer", "baseUrl", "mergeRequestOptions", "variant", "style", "setTimeout", "DEFAULT_ZOD_FETCH_OPTIONS", "ApiClient", "accessToken", "getRunResult", "defaultRequestOptions", "requestOptions", "getBatchResults", "triggerTask", "taskId", "encodedTaskId", "encodeURIComponent", "body", "batchTriggerTask", "createUploadPayloadUrl", "filename", "CreateUploadPayloadUrlResponseBody", "getPayloadUrl", "retrieveRun", "listRuns", "createSearchQueryForListRuns", "searchParams", "before", "listProjectRuns", "replayRun", "ReplayRunResponse", "cancelRun", "CanceledRunResponse", "rescheduleRun", "addTags", "createSchedule", "listSchedules", "toString", "perPage", "append", "retrieveSchedule", "updateSchedule", "deactivateSchedule", "activateSchedule", "deleteSchedule", "scheduleId", "listEnvVars", "projectRef", "importEnvVars", "EnvironmentVariableResponseBody", "retrieveEnvVar", "createEnvVar", "updateEnvVar", "deleteEnvVar", "spanParentAsLink", "Authorization", "inject", "URLSearchParams", "from", "_APIClientManagerAPI", "to", "period", "defaultOptions", "apiClientManager", "parsePacket", "setGlobalAPIClientConfiguration", "baseURL", "store", "client", "stringifyIO", "APIClientManagerAPI", "dataType", "exportPacket", "pathPrefix", "byteLength", "packet", "conditionallyExportPacket", "needsOffloading", "size", "byteSize", "packetRequiresOffloading", "uploadResponse", "conditionallyImportPacket", "presignedResponse", "setAttribute", "importPacket", "loadSuperJSON", "parsed", "dataKey", "dataTypeKey", "createPacketAttributes", "Map", "forEach", "k", "v", "safeReplacer", "getPacketExtension", "outputType", "usage2", "TaskExecutor", "_tracingSDK", "tracingSDK", "_tracer", "_consoleInterceptor", "projectConfig", "_importedConfig", "importedConfig", "_handleErrorFn", "handleErrorFn", "execute", "attemptMessage", "originalPacket", "parsedPayload", "initOutput", "finalOutput", "stringifyError", "TaskRunErrorCodes", "handleErrorResult", "kind", "extractContext", "middlewareFn", "runFn", "init", "fns", "onSuccessFn", "output", "onFailureFn", "cleanupFn", "retriesConfig", "max", "rateLimitError", "millisecondsUntilReset", "retryDelayInMs", "retryAt", "skipRetrying", "Date", "PreciseWallClock", "_origin", "clockTime", "origin", "preciseDate", "preciseNow", "elapsedHrTime", "elapsedNanoseconds", "PreciseDate", "dateStruct", "reset", "SeverityNumber", "iconStringForSeverity", "severityNumber", "DEBUG2", "INFO2", "INFO4", "WARN4", "_ClockAPI", "ERROR4", "clock2", "FATAL3", "SimpleClock", "now", "nowStruct", "logLevels", "SIMPLE_CLOCK", "ClockAPI", "setGlobalClock", "clock", "OtelTaskLogger", "debug", "_level", "properties", "warn", "trace", "safeJsonProcess", "icon", "severityText", "jsonErrorReplacer", "ConsoleInterceptor", "_getTimestampInHrTime", "logger", "sendToStdIO", "intercept", "console", "info", "log", "args", "util", "write", "emit", "getTimestampInHrTime_fn", "getLogMessage", "fallback", "tryParseJSON", "e", "_taskMetadata", "_taskFunctions", "_taskFileMetadata", "registerTaskMetadata", "updateTaskMetadata", "existingMetadata", "updates", "registerTaskFileMetadata", "metadata", "fileMetadata", "push", "getTaskMetadata", "_UsageAPI", "taskExists", "StandardTaskCatalog", "NoopUsageManager", "start", "sample", "cpuTime", "measurement", "pauseAsync", "cb", "NOOP_USAGE_MANAGER", "UsageAPI", "calculateDurationInMs", "_a2", "setGlobalUsageManager", "startSeconds", "startNanoseconds", "endSeconds", "endNanoseconds", "end", "nanoseconds", "DevUsageMeasurement", "_pauses", "stop", "_endedAt", "wallTime", "totalPauses", "registerPause", "_currentMeasurements", "_firstMeasurement", "pauseId", "pauseStart", "pauseEnd", "DevUsageManager", "generateRandomString", "characters", "charactersLength", "charAt", "floor", "setInterval", "sendUsageEvent", "event", "accept", "renewedJwt", "UsageClient", "ProdUsageManager", "_usageClient", "isReportingEnabled", "delegageUsageManager", "_measurement", "exports", "setInterval", "maxDelay", "fullTimeouts", "remainingDelay", "delay", "lastTimeoutResult", "setTimeout", "unboundedTimeout", "_taskWaits", "_batchWaits", "Map", "_pendingCompletionNotifications", "disable", "ms", "waitForDuration", "pendingCompletion", "set", "params", "id", "resolve", "length", "Promise", "items", "reject", "results", "resumeTask", "wait", "runId", "DevRuntimeManager", "__name", "z", "constructor", "payload", "error", "message", "Error", "__name", "ZodSchemaParsedError", "ZodMessageSchema", "object", "version", "default", "type", "string", "unknown", "ZodMessageHandler", "options", "messages", "logger", "console", "parsedMessage", "parseMessage", "success", "handler", "data", "ack", "schema", "parsedPayload", "registerHandlers", "log", "emitter", "on", "callback", "info", "eventName", "hasCallback", "handleMessage", "_schema", "ZodMessageSender", "sender", "exports", "exports", "exports", "fetch", "_a", "exports", "exports", "_a", "name", "fetch", "exports", "exports", "createClient", "z", "fromZodError", "maxAttempts", "factor", "minTimeoutInMs", "maxTimeoutInMs", "randomize", "byStatus", "strategy", "connectionError", "timeout", "calculateNextRetryDelay", "options", "attempt", "opts", "defaultRetryOptions", "_ApiError", "random", "Math", "round", "ApiError", "constructor", "status", "error", "message", "name", "headers", "data", "param", "makeMessage", "BadRequestError", "ApiConnectionError", "PermissionDeniedError", "AuthenticationError", "NotFoundError", "ConflictError", "__name", "InternalServerError", "__publicField", "Error", "cause", "undefined", "UnprocessableEntityError", "RateLimitError", "resetAtUnixEpochMs", "resetAtUnixEpoch", "castToError", "err", "SemanticInternalAttributes", "ENVIRONMENT_ID", "ENVIRONMENT_TYPE", "ORGANIZATION_ID", "ORGANIZATION_SLUG", "ORGANIZATION_NAME", "PROJECT_ID", "PROJECT_REF", "PROJECT_NAME", "PROJECT_DIR", "ATTEMPT_ID", "ATTEMPT_NUMBER", "RUN_ID", "RUN_IS_TEST", "BATCH_ID", "TASK_SLUG", "TASK_PATH", "TASK_EXPORT_NAME", "QUEUE_NAME", "QUEUE_ID", "MACHINE_PRESET_NAME", "MACHINE_PRESET_CPU", "MACHINE_PRESET_MEMORY", "MACHINE_PRESET_CENTS_PER_MS", "SPAN_PARTIAL", "SPAN_ID", "OUTPUT", "OUTPUT_TYPE", "STYLE", "STYLE_ICON", "STYLE_VARIANT", "STYLE_ACCESSORY", "METADATA", "TRIGGER", "PAYLOAD", "PAYLOAD_TYPE", "SHOW", "SHOW_ACTIONS", "WORKER_ID", "WORKER_VERSION", "CLI_VERSION", "SDK_VERSION", "SDK_LANGUAGE", "RETRY_AT", "IDEMPOTENCY_KEY", "USAGE_DURATION_MS", "USAGE_COST_IN_CENTS", "RATE_LIMIT_LIMIT", "RATE_LIMIT_REMAINING", "RATE_LIMIT_RESET", "flattenAttributes", "obj", "result", "prefix", "key", "newPrefix", "Array", "Object", "i", "NULL_SENTINEL", "value", "accessoryAttributes", "isRecord", "CursorPage", "pagination", "getPaginatedItems", "hasNextPage", "hasPreviousPage", "getNextPage", "pageFetcher", "getPreviousPage", "page", "asyncIterator", "item", "OffsetLimitPage", "currentPage", "defaultRetryOptions2", "requestOptionsKeys", "isRequestOptions", "zodfetch", "schema", "ApiPromise", "_doZodFetch", "zodfetchCursorPage", "url", "params", "query", "set", "String", "after", "cursorPageSchema", "object", "array", "next", "optional", "previous", "$url", "fetchResult", "CursorPagePromise", "zodfetchOffsetLimitPage", "URLSearchParams", "limit", "offsetLimitPageSchema", "totalPages", "number", "coerce", "search", "toString", "OffsetLimitPagePromise", "callback", "startActiveSpan", "span", "attributes", "traceZodFetch", "requestInit", "onResponseBody", "response", "safeJsonParse", "requestInitWithCache", "responseHeaders", "createResponseHeaders", "waitForRetry", "_doZodFetchWithRetries", "errJSON", "jsonBody", "safeParse", "parsedResult", "retry", "shouldRetry", "retryOptions", "delay", "shouldRetryForOptions", "shouldRetryHeader", "parseInt", "text", "JSON", "parse", "get", "target", "_", "Request", "withCache", "asResponse", "responsePromise", "then", "p", "onfulfilled", "catch", "onrejected", "finally", "onfinally", "Promise", "_fetchPage", "fetchPage_fn", "method", "tracer", "toUpperCase", "isEmptyObj", "exports", "prototype", "hasOwn", "import_v3", "import_workers", "import_zodMessageHandler", "TriggerTracer", "name", "version", "_InMemoryCache", "_cache", "get", "set", "undefined", "delete", "InMemoryCache", "startActiveSpan", "span", "setAttribute", "cacheKey", "SemanticInternalAttributes", "cacheEntry", "updateName", "value", "fn", "attributes", "store", "metadata", "createdTime", "createCache", "SpanStatusCode", "AsyncLocalStorage", "opts", "defaultRetryOptions", "options", "tracer", "attempt", "innerSpan", "startSpan", "items", "style", "result", "maxAttempts", "end", "e", "Error", "recordException", "code", "ERROR", "nextRetryDelay", "calculateNextRetryDelay", "onThrow", "input", "URL", "normalizeHttpMethod", "method", "toUpperCase", "fetchHttpHandlerStorage", "fetchWithInterceptors", "handlers", "getResponse", "request", "Request", "response", "init", "fetch", "FetchErrorWithSpan", "constructor", "originalError", "MAX_ATTEMPTS", "timeoutId", "timeoutInMs", "setTimeout", "abortController", "undefined", "signal", "clearTimeout", "ok", "setAttributes", "createFetchResponseAttributes", "nextRetry", "calculateRetryDelayForResponse", "runtime", "waitForDuration", "now", "isInFuture", "RETRY_AT", "waitUntil", "Date", "name", "createFetchRetryOptionsAttributes", "retry", "retryFetch", "doFetchRequest", "httpMethod", "attemptCount", "createFetchAttributes", "headers", "strategy", "getRetryStrategyForResponse", "resetAt", "statusCodes", "keys", "clonedResponse", "clone", "i", "statusRange", "isStatusCodeInRange", "status", "body", "eventFilterMatches", "statusCode", "includes", "some", "start", "split", "prefix", "slice", "statusCodePrefix", "statusCodeString", "parseInt", "createAttributesFromHeaders", "normalizedHeaderKey", "safeJsonParse", "obj", "defaults", "key", "createFetchAttributes", "normalizeUrlFromInput", "httpMethod", "normalizeHttpMethod", "SEMATTRS_HTTP_METHOD", "SEMATTRS_HTTP_URL", "SEMATTRS_HTTP_HOST", "SEMATTRS_HTTP_SCHEME", "items", "status", "statusText", "SEMATTRS_HTTP_RESPONSE_CONTENT_LENGTH", "response", "createAttributesFromHeaders", "createFetchRetryOptionsAttributes", "retry", "resolveDefaults", "retry", "onThrow", "fetch", "retryFetch", "interceptFetch", "SpanKind", "SEMATTRS_MESSAGING_DESTINATION", "SemanticInternalAttributes", "accessoryAttributes", "apiClientManager", "flattenAttributes", "runs", "replay", "replayRun", "cancel", "cancelRun", "retrieve", "list", "listRuns", "reschedule", "poll", "apiClient", "apiClientMissingError", "$requestOptions", "listRunsRequestOptions", "isRequestOptions", "tracer", "name", "icon", "attributes", "items", "paramsOrProjectRef", "style", "paramsOrOptions", "mergeRequestOptions", "text", "requestOptions", "retrieveRun", "runId", "variant", "rescheduleRun", "MAX_POLL_ATTEMPTS", "attempts", "run", "Promise", "resolve", "taskContext", "idempotencyKeys", "create", "createIdempotencyKey", "isIdempotencyKey", "value", "idempotencyKey", "Array", "key", "concat", "injectScope", "ctx", "id", "generateIdempotencyKey", "hash", "subtle", "digest", "Uint8Array", "byte", "toString", "options", "queue", "customQueue", "params", "undefined", "task", "trigger", "taskMetadata", "taskCatalog", "getTaskMetadata", "trigger_internal", "batchTrigger", "triggerAndWait", "batchTriggerAndWait", "batchTriggerAndWait_internal", "registerTaskMetadata", "defaultRetryOptions", "fns", "init", "middleware", "handleError", "onSuccess", "onStart", "createTask", "payload", "triggerAndWait_internal", "handle", "triggerAndPoll", "batchTrigger_internal", "payloadPacket", "concurrencyKey", "test", "isTest", "payloadType", "delay", "tags", "maxAttempts", "spanParentAsLink", "onResponseBody", "span", "body", "dataType", "makeKey", "item", "SEMATTRS_MESSAGING_OPERATION", "batchId", "response", "startActiveSpan", "data", "dependentAttempt", "lockToVersion", "ttl", "setAttribute", "getRunResult", "logger", "result", "SEMATTRS_MESSAGING_SYSTEM", "stringifyIO", "worker", "version", "getBatchResults", "hasIdempotencyKey", "results", "existingResults", "incompleteRuns", "length", "log", "handleBatchTaskRunExecutionResult", "existingItem", "combinedItems", "newItem", "kind", "some", "outputType", "someObjectStoreOutputs", "handleTaskRunExecutionResult", "output", "importedPacket", "conditionallyImportPacket", "execution", "ok", "error", "createErrorTaskError", "hasBaseUrl", "hasAccessToken", "scope", "makeKey", "options", "createTask", "task", "trigger", "triggerAndPoll", "batchTrigger", "triggerAndWait", "batchTriggerAndWait", "wait", "for", "tracer", "startActiveSpan", "start", "durationInMs", "calculateDurationInMs", "attributes", "accessoryAttributes", "text", "style", "until", "throwIfInThePast", "Error", "runtime", "waitForDuration", "SemanticInternalAttributes", "date", "toISOString", "minutes", "hours", "days", "weeks", "months", "years", "nameForWaitOptions", "measure", "measurement", "usageApi", "costInCents", "result", "compute", "durationMs", "tags", "add", "apiClientManager", "apiClient", "apiClientMissingError", "run", "taskContext", "tracer", "name", "icon", "attributes", "style", "requestOptions", "$requestOptions", "error", "logger", "existingTags", "newTags", "addTags", "ApiError", "task", "TimezonesResult", "createTask", "cron", "params", "taskCatalog", "updateTaskMetadata", "triggerSource", "schedule", "timezone", "options", "createSchedule", "create", "retrieve", "scheduleId", "retrieveSchedule", "update", "updateSchedule", "del", "deleteSchedule", "deactivate", "deactivateSchedule", "activate", "mergeRequestOptions", "accessoryAttributes", "items", "list", "timezones", "baseUrl", "baseURL", "zodfetch", "method", "headers", "upload", "projectRefOrParams", "$params", "$projectRef", "$slug", "slugOrRequestOptions", "environment", "Error", "project", "importEnvVars", "projectRefOrRequestOptions", "slug", "isRequestOptions", "ctx", "client", "createEnvVar", "projectRefOrName", "$name", "overloadRequestOptions", "ref", "slugOrParams", "nameOrRequestOptions", "import_render", "__defProp", "__hasOwnProp", "__defNormalProp", "version", "renderAsync2", "import_supabase_js", "React", "handleError", "tracer", "task", "tracer", "handleError"]
}
